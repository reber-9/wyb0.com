<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>高阶函数 on </title>
    <link>http://wyb0.com/tags/%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/</link>
    <description>Recent content in 高阶函数 on </description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2016-2017 Reber. All Rights Reserved.</copyright>
    <lastBuildDate>Thu, 21 Jan 2016 21:13:17 +0800</lastBuildDate>
    <atom:link href="http://wyb0.com/tags/%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Python的函数式编程</title>
      <link>http://wyb0.com/posts/Python%E7%9A%84%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</link>
      <pubDate>Thu, 21 Jan 2016 21:13:17 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/Python%E7%9A%84%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</guid>
      <description>

&lt;h2 id=&#34;函数式编程:1a599b6eba40e41d04fc87a4ed97ed9a&#34;&gt;函数式编程&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;首先说一下高阶函数，能将函数作为参数来接收的函数就可以称为高阶函数，如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def add(x,y,f):
    return f(x) + f(y)
print add(7,-3,abs) #abs是求绝对值的函数，这里返回的值为10
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将函数作为参数传入，这样的函数就是高阶函数，而函数式编程就是指这种抽象程度很高的编程范式。&lt;br /&gt;
函数式编程的一个特点就是可以将函数作为参数，还允许返回一个函数。&lt;br /&gt;
纯粹的函数式编程语言编写的函数没有变量，因此，任意一个函数，只要输入是确定的，输出就是确定的，这种纯函数我们称之为没有副作用。&lt;br /&gt;
允许使用变量的程序设计语言，由于函数内部的变量状态不确定，同样的输入，可能得到不同的输出，因此，这种函数是有副作用的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;高阶函数:1a599b6eba40e41d04fc87a4ed97ed9a&#34;&gt;高阶函数&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;map()函数&lt;br /&gt;
map接收两个参数，一个是函数，一个是列表(list)，map将函数依次作用到list的每个元素，然后返回新的list&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def f(x):
    return x*x
print map(f,[1,2,3,4]) #返回[1,4,9,16]
print map(str,[1,2,3,4]) # 返回[&#39;1&#39;,&#39;2&#39;,&#39;3&#39;,&#39;4&#39;]
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;reduce()函数&lt;br /&gt;
reduce接收参数和map一样(但传入的函数必须接收两个参数)，reduce会对list的每个元素反复调用函数，然后返回最终值&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def f(x,y):
    return x*y
print reduce(f,[1,2,3,4]) #1*2*3*4，返回24
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;filter()函数&lt;br /&gt;
filter也接收函数和list，函数会对list的每个元素进行判断然后返回True或False，为True的组成新list返回&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def f(x):
    return x &amp;gt; 3
print filter(f,[1,2,3,4,5]) #返回[4,5]
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;sorted()函数&lt;br /&gt;
Python内置的函数sorted()可以对list进行排序&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;sorted([34,2,345,3]) #返回[2,3,34,345]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;sorted也是一个高阶函数，当然也可以接收函数和参数。通常规定，对于两个元素x和y，若认为x &amp;lt; y则返回-1，若认为x == y则返回0，若认为x &amp;gt; y则返回1，从而进行正向排序&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def s(s1,s2):
    u1 = s1.lower()
    u2 = s2.lower()
    if u1 &amp;lt; u2:
        return -1
    if u1 &amp;gt; u2:
        return 1
    return 0
print sorted([&#39;tom,Bob,Jerry,Alim&#39;],s) #返回[&#39;Alim&#39;,&#39;Bob&#39;,&#39;Jerry&#39;,&#39;tom&#39;]
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;匿名函数:1a599b6eba40e41d04fc87a4ed97ed9a&#34;&gt;匿名函数&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;匿名函数有时可以节省代码量，它没有函数名，也不存在return，它会用到关键字lambda，后面跟参数，然后是冒号，冒号后面写表达式(也是返回值)，形如：lambda x,y:x*y代表的就是参数为x,y，返回x*y。Python的匿名函数都可以用def代替&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;print map(lambda x:x*x,[1,2,3,4]) #返回[1,4,9,16]
print reduce(lambda x,y:x*y,[1,2,3,4]) #返回1*2*3*4，即24
print filter(lambda x:x&amp;gt;3,[1,2,3,4,5]) #返回[4,5]
f = lambda x,y:x+y
print f(3,2) #返回5
g = lambda x,y=3:x+y
print g(5) #不输入y值则默认为3，这里返回8
print (lambda s:&#39; &#39;.join(s.split(&#39;*&#39;)))(&amp;quot;I*am*tom&amp;quot;) #返回I am tom
print (lambda x,y:x if x&amp;gt;y else y)(53,34) #返回53
L = [lambda x:x**2,lambda x:x**3,lambda x:x**4]
for f in L:
    print f(2), #输出4 8 16
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;装饰器:1a599b6eba40e41d04fc87a4ed97ed9a&#34;&gt;装饰器&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;装饰器可以提高程序的课重复利用性，并增加程序的可读性&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;不带参数&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#!/usr/bin/env python
# -*- coding: utf-8 -*-

def deco(func):
    def _deco():
        print &amp;quot;before func()&amp;quot;
        func()
        print &amp;quot;after func()&amp;quot;

    return _deco #返回一个修饰过的函数(即修改过的func())


@deco #等价于foo = deco(foo)，即修饰过的函数赋给foo
def foo():
    print &amp;quot;this is foo()&amp;quot;

foo() # 此时的foo()就是deco(foo)的返回值，即函数_deco()
&amp;quot;&amp;quot;&amp;quot;
#结果如下：
# before func()
# this is foo()
# after func()
&amp;quot;&amp;quot;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;带参数&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def deco(func):
    def _deco(*args, **kwargs):
        print &amp;quot;before func()&amp;quot;
        ret = func(*args, **kwargs)
        print &amp;quot;after func()&amp;quot;
        return ret

    return _deco

@deco
def myfunc1(a, b):
    print &amp;quot;myfunc1&amp;quot;
    return a+b

@deco
def myfunc2(a, b, c):
    print &amp;quot;myfunc2&amp;quot;
    return a+b+c

print myfunc1(2,3)
print myfunc2(2,3,4)
&amp;quot;&amp;quot;&amp;quot;
#结果如下：
# before func()
# myfunc1
# after func()
# 5
# before func()
# myfunc2
# after func()
# 9
&amp;quot;&amp;quot;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
  </channel>
</rss>