<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Awk on </title>
    <link>http://wyb0.com/tags/awk/</link>
    <description>Recent content in Awk on </description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2016-2017 Reber. All Rights Reserved.</copyright>
    <lastBuildDate>Wed, 20 Apr 2016 15:54:07 +0800</lastBuildDate>
    <atom:link href="http://wyb0.com/tags/awk/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Linux之文本处理软件awk</title>
      <link>http://wyb0.com/posts/Linux%E4%B9%8B%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E8%BD%AF%E4%BB%B6awk/</link>
      <pubDate>Wed, 20 Apr 2016 15:54:07 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/Linux%E4%B9%8B%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E8%BD%AF%E4%BB%B6awk/</guid>
      <description>

&lt;p&gt;&lt;center&gt;
awk默认是以行为单位处理文本的，对test.txt中的每一行都执行后面 &amp;ldquo;{ }&amp;rdquo; 中的语句。
&lt;/center&gt;&lt;br/&gt;&lt;br/&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;若有一个需要重新格式化的字典test.txt(用户名、密码、地址)：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;xiaosan sadasdw jiaozuo
234wer  asdfasd asdas
1111    aaaa    cccc
2222    aaaa    degd
1111    aaaa    cccc
3333    aaaa    dfger
21asd   sdfsd   sadasd
dwqx    asds    sasdfcv
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;要求：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1.里面有重复数据，使用命令去重
2.提取出用户名和密码 每一行前面加上id数字，递增。
3.只提取出密码作为爆破字典
4.某些公司都是一个公司前缀+姓名简写，所以为用户名一栏全部改为uv_用户名
5.提取出密码一列，有些密码爆破成功率高，所以增加一列，标出密码出现次数
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;去重:42bebd4d9e7287de331693a6d85c474f&#34;&gt;去重：&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;[wyb@localhost ~]$ cat test.txt | awk &#39;!a[$1]++&#39;
[wyb@localhost ~]$ cat test.txt | uniq //作用和上面命令相同
aosan sadasdw jiaozuo
234wer  asdfasd asdas
1111    aaaa    cccc
2222    aaaa    degd
3333    aaaa    dfger
21asd   sdfsd   sadasd
dwqx    asds    sasdfcv
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;去重-添加id:42bebd4d9e7287de331693a6d85c474f&#34;&gt;去重、添加id：&lt;/h2&gt;

&lt;p&gt;一般字典不需要id、user、pass等标示符，这里只是为了便于观看&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[wyb@localhost ~]$ cat test.txt | awk &#39;!a[$1]++&#39; | awk -F &#39;\t&#39; &#39;{print &amp;quot;id:&amp;quot;NR&amp;quot;\tuser:&amp;quot;$1&amp;quot;\tpass:&amp;quot;$2&amp;quot;\taddress:&amp;quot;$3}&#39; | column -t  //最后一个命令可以将列对齐
id:1    user:aosan      pass:sadasdw    address:jiaozuo
id:2    user:234wer     pass:asdfasd    address:asdas
id:3    user:1111       pass:aaaa       address:cccc
id:4    user:2222       pass:aaaa       address:degd
id:5    user:3333       pass:aaaa       address:dfger
id:6    user:21asd      pass:sdfsd      address:sadasd
id:7    user:dwqx       pass:asds       address:sasdfcv
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;去重-添加id-添加公司前缀:42bebd4d9e7287de331693a6d85c474f&#34;&gt;去重、添加id、添加公司前缀：&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;[wyb@localhost ~]$ cat test.txt | awk &#39;!a[$1]++&#39; | awk -F &#39;\t&#39; &#39;{print &amp;quot;id:&amp;quot;NR&amp;quot;\tuser:uv_&amp;quot;$1&amp;quot;\tpass:&amp;quot;$2&amp;quot;\taddress:&amp;quot;$3}&#39;
id:1    user:uv_aosan   pass:sadasdw    address:jiaozuo
id:2    user:uv_234wer  pass:asdfasd    address:asdas
id:3    user:uv_1111    pass:aaaa       address:cccc
id:4    user:uv_2222    pass:aaaa       address:degd
id:5    user:uv_3333    pass:aaaa       address:dfger
id:6    user:uv_21asd   pass:sdfsd      address:sadasd
id:7    user:uv_dwqx    pass:asds       address:sasdfcv
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;去重然后输出密码:42bebd4d9e7287de331693a6d85c474f&#34;&gt;去重然后输出密码：&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;[wyb@localhost ~]$ cat test.txt | awk &#39;!a[$1]++&#39; | awk -F &#39;\t&#39; &#39;{print &amp;quot;pass:&amp;quot;$2}&#39;
pass:sadasdw
pass:asdfasd
pass:aaaa
pass:aaaa
pass:aaaa
pass:sdfsd
pass:asds
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;输出密码-得到密码出现次数:42bebd4d9e7287de331693a6d85c474f&#34;&gt;输出密码、得到密码出现次数：&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;下面的&#39;a[$1]++&#39;是按第一列来去重的,若有两条数据只有第一列重复则成功，可以用$0按行来去重
[wyb@localhost ~]$ cat test.txt | awk &#39;!a[$1]++&#39; | awk -F &#39;\t&#39; &#39;{print $2}&#39; | awk &#39;{a[$1]++} END {for (j in a) print a[j],j}&#39;
1 sadasdw
1 sdfsd
1 asdfasd
1 asds
3 aaaa

uniq 只能去除挨着的重复数据，所以先sort升序排序，然后uniq -c统计重复，再sort -r降序排序
cat test.txt | awk &#39;{print $2}&#39; | sed &#39;1d&#39; |sort | uniq -c |sort -r
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;其他:42bebd4d9e7287de331693a6d85c474f&#34;&gt;其他：&lt;/h2&gt;

&lt;h4 id=&#34;对-a-1-的解释如下:42bebd4d9e7287de331693a6d85c474f&#34;&gt;对&amp;rsquo;!a[$1]++&amp;lsquo;的解释如下：&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;a[e54r56wer]为空，!a[e54r56wer]为真，可以输出，然后++&lt;/li&gt;
&lt;li&gt;若再来一个a[e54r56wer]，因为上一步已经++，此时值为1，!a[e54r56wer]为假，不输出，再++&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;对for输出数组的解释如下:42bebd4d9e7287de331693a6d85c474f&#34;&gt;对for输出数组的解释如下：&lt;/h4&gt;

&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;awk &amp;lsquo;{a[$1]++} END {for (j in a) print a[j],j}&amp;rsquo; test.txt&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在遍历完文件后，通过END把后面的句子连起来&lt;/li&gt;
&lt;li&gt;for (j in a) 是指打印数组a的下标，并定义下标为变量j&lt;/li&gt;
&lt;li&gt;最后print a[j],j就是打印数组下标和数组，这样就相同的$1排重并计数&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Linux之文本处理</title>
      <link>http://wyb0.com/posts/Linux%E4%B9%8B%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86/</link>
      <pubDate>Wed, 20 Apr 2016 07:58:07 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/Linux%E4%B9%8B%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86/</guid>
      <description>

&lt;p&gt;这里介绍3种方式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;==&amp;gt;awk  
==&amp;gt;grep  
==&amp;gt;sed
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;awk处理文本-最常用:007bb002f88c52764f350befc73a2d85&#34;&gt;awk处理文本(&lt;em&gt;最常用&lt;/em&gt;)：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;作用：awk对数据以行分析并生成报告时显得很强大，它将行进行切片，再处理分开的切片，可对格式化的数据重新进行格式化&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;awk命令格式：awk [F filed-separator] &amp;lsquo;commands&amp;rsquo; input-fiel(s)&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;参数-F：可以添加任意的分割符，比较重要&lt;br /&gt;
awk工作流程是这样的：&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;读入有&amp;rsquo;\n&amp;rsquo;换行符分割的一条记录，然后将记录按-F指定的域分隔符划分域，$0则表示所有域,$1表示第一个域,$n表示第n个域。默认域分隔符是&amp;rdquo;空白键&amp;rdquo; 或 &amp;ldquo;[tab]键&amp;rdquo;。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;1-入门示例:007bb002f88c52764f350befc73a2d85&#34;&gt;1. 入门示例：&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;[wyb@localhost temp]$ head -n 5 /etc/passwd
root:x:0:0:root:/root:/bin/bash
bin:x:1:1:bin:/bin:/sbin/nologin
daemon:x:2:2:daemon:/sbin:/sbin/nologin
adm:x:3:4:adm:/var/adm:/sbin/nologin
lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin
[wyb@localhost temp]$ head -n 5 /etc/passwd | awk -F &#39;:&#39; &#39;{print $1}&#39;  //输出第1列，域分隔符为：
root
bin
daemon
adm
lp
[wyb@localhost temp]$ head -n 5 /etc/passwd | awk -F &#39;:&#39;  &#39;{pri
nt &amp;quot;id:&amp;quot;$1&amp;quot;\tshell:&amp;quot;$7}&#39;    //输出第1、7列且给予列名
id:root shell:/bin/bash
id:bin  shell:/sbin/nologin
id:daemon       shell:/sbin/nologin
id:adm  shell:/sbin/nologin
id:lp   shell:/sbin/nologin
[wyb@localhost temp]$ head -n 5 /etc/passwd | awk -F &#39;:&#39;  &#39;BEGIN {print &amp;quot;====begin=====&amp;quot;} {print &amp;quot;id:&amp;quot;$1&amp;quot;\tshell:&amp;quot;$7} END {print &amp;quot;====end====&amp;quot;}&#39;
====begin=====
id:root shell:/bin/bash
id:bin  shell:/sbin/nologin
id:daemon       shell:/sbin/nologin
id:adm  shell:/sbin/nologin
id:lp   shell:/sbin/nologin
====end====
[wyb@localhost temp]$ awk -F: &#39;/root/&#39; /etc/passwd  //搜索含有root关键字的所有行
root:x:0:0:root:/root:/bin/bash
operator:x:11:0:operator:/root:/sbin/nologin
[wyb@localhost temp]$ awk -F: &#39;/root/{print $7}&#39; /etc/passwd    //匹配root并输出对应shell
/bin/bash
/sbin/nologin
[wyb@localhost temp]$ awk -F: &#39;/^root/&#39; /etc/passwd //匹配以root开头的行
root:x:0:0:root:/root:/bin/bash
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-内置变量:007bb002f88c52764f350befc73a2d85&#34;&gt;2. 内置变量：&lt;/h3&gt;

&lt;table&gt;
    &lt;tr&gt;
        &lt;td bgcolor=black&gt;
ARGC&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;命令行参数个数&lt;br/&gt;
ARGV&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;命令行参数排列&lt;br/&gt;
ENVIRON&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;支持队列中系统环境变量的使用&lt;br/&gt;
FILENAME&amp;nbsp;&amp;nbsp;&amp;nbsp;awk浏览的文件名&lt;br/&gt;
FNR&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;浏览文件的记录数&lt;br/&gt;
FS&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;设置输入域分隔符，等价于命令行 -F选项&lt;br/&gt;
NF&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;浏览记录的域的个数&lt;br/&gt;
NR&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;已读的记录数&lt;br/&gt;
OFS&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;输出域分隔符&lt;br/&gt;
ORS&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;输出记录分隔符&lt;br/&gt;
RS&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;控制记录分隔符
        &lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[wyb@localhost temp]$ awk -F: &#39;{print &amp;quot;filename:&amp;quot; FILENAME &amp;quot;,linenumber:&amp;quot; NR &amp;quot;,columns:&amp;quot; NF &amp;quot;,linecontent:&amp;quot;$0}&#39; a.txt
filename:a.txt,linenumber:1,columns:1,linecontent:1     root    12sf34s56
filename:a.txt,linenumber:2,columns:1,linecontent:2     admin   ksdjfiweurf
filename:a.txt,linenumber:3,columns:1,linecontent:3     dome    skd89453
filename:a.txt,linenumber:4,columns:1,linecontent:4     tomkd   3jkke34
filename:a.txt,linenumber:5,columns:1,linecontent:5     jarry   sdkj89ry4
filename:a.txt,linenumber:6,columns:1,linecontent:6     canki   sdkj834
filename:a.txt,linenumber:7,columns:1,linecontent:7     lola    er8f7734
filename:a.txt,linenumber:8,columns:1,linecontent:8     marry   j8jkf78
filename:a.txt,linenumber:9,columns:1,linecontent:9     candy   kd89943
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;3-awk编程:007bb002f88c52764f350befc73a2d85&#34;&gt;3. awk编程：&lt;/h3&gt;

&lt;h5 id=&#34;3-1-变量和赋值:007bb002f88c52764f350befc73a2d85&#34;&gt;3.1 变量和赋值：&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;[wyb@localhost temp]$ head -n 5 /etc/passwd | awk -F &#39;:&#39;  &#39;BEGIN {count=0} {count++; print &amp;quot;username:&amp;quot;$1} END {print &amp;quot;count:&amp;quot;count}&#39;
username:root
username:bin
username:daemon
username:adm
username:lp
count:5
[wyb@localhost ~]$ ls -l aaa/ettercap-0.8.2 | awk &#39;BEGIN {size=0;} {size=size+5;} END {print &amp;quot;[end]size is:&amp;quot;,size,&amp;quot;byte&amp;quot;}&#39;
[end]size is: 160 byte
[wyb@localhost ~]$ ls -l aaa/ettercap-0.8.2 | awk &#39;BEGIN {size=0;} {size=size+5;} END {print &amp;quot;[end]size is:&amp;quot;,size/1024/1024,&amp;quot;M&amp;quot;}&#39;
[end]size is: 0.000152588 M
[wyb@localhost ~]$ 
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;3-2条件语句:007bb002f88c52764f350befc73a2d85&#34;&gt;3.2条件语句：&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;[wyb@localhost ~]$ head -n 6 /etc/passwd | awk -F &#39;:&#39; &#39;{if($1==&amp;quot;root&amp;quot;) print &amp;quot;root bash is:&amp;quot;$7}&#39;
root bash is:/bin/bash
[wyb@localhost ~]$ 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;grep处理文本:007bb002f88c52764f350befc73a2d85&#34;&gt;Grep处理文本：&lt;/h2&gt;

&lt;p&gt;匹配到时输出一行
常用参数：nrABC
&lt;table&gt;
    &lt;tr&gt;
        &lt;td bgcolor=black&gt;
-n&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;输出匹配到的字符串所在行数&lt;br/&gt;
-r&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;遍历子目录文件查找字符串&lt;br/&gt;
-A 3&amp;nbsp;&amp;nbsp;显示匹配行及下面3行&lt;br/&gt;
-B 4&amp;nbsp;&amp;nbsp;显示匹配行及上面4行&lt;br/&gt;
-C 4&amp;nbsp;&amp;nbsp;显示匹配行及上下4行&lt;br/&gt;
-i&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;不区分大小写&lt;br/&gt;
-v&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;显示所有不包含字符的行
        &lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[wyb@localhost ~]$ grep root /etc/passwd    //查找root这个字符
root:x:0:0:root:/root:/bin/bash
operator:x:11:0:operator:/root:/sbin/nologin
[wyb@localhost ~]$ grep -n root /etc/passwd //查找root字符串并输出所在行数
1:root:x:0:0:root:/root:/bin/bash
11:operator:x:11:0:operator:/root:/sbin/nologin
[wyb@localhost ~]$ grep -n root /etc/passwd --color //给字符串不同颜色
1:root:x:0:0:root:/root:/bin/bash
11:operator:x:11:0:operator:/root:/sbin/nologin
[wyb@localhost temp]$ ls
aa  b.txt
[wyb@localhost temp]$ grep -r -n root /home/wyb/temp/ --color   在temp目录及子目录查找字符串root
/home/wyb/temp/b.txt:4:sdkrootwe
/home/wyb/temp/b.txt:6:fsdkfjroot
/home/wyb/temp/b.txt:9:root
/home/wyb/temp/aa/a.txt:1:1     root    12sf34s56
[wyb@localhost temp]$ grep -r -n &amp;quot;^root&amp;quot; /etc/passwd --color    正则查找字符串root
1:root:x:0:0:root:/root:/bin/bash
[wyb@localhost temp]$ grep -r -n &amp;quot;root&amp;quot; /etc/passwd --color -c  匹配的行的数
2
[wyb@localhost temp]$ ps aux | grep &amp;quot;^wyb&amp;quot;
wyb        2185  0.0  0.1  99952  1840 ?        S    16:33   0:02 sshd: wyb@pts/0  
wyb        2186  0.0  0.1 108464  1944 pts/0    Ss   16:33   0:00 -bash
wyb        3229  2.0  0.1 110232  1136 pts/0    R+   18:27   0:00 ps aux
wyb        3230  0.0  0.0 103244   828 pts/0    S+   18:27   0:00 grep ^wyb
[wyb@localhost temp]$ ps aux | grep ora
wyb        3233  0.0  0.0 103244   828 pts/0    S+   18:28   0:00 grep ora
[wyb@localhost temp]$ 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;sed处理文本:007bb002f88c52764f350befc73a2d85&#34;&gt;sed处理文本&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;处理大文本很好用，上几十万、上百万行的数据&lt;/li&gt;
&lt;li&gt;sed主要以行为单位，可以将数据行进行替换、删除、新增、选取等&lt;/li&gt;
&lt;li&gt;sed语法 参数 动作 文件&lt;/li&gt;
&lt;li&gt;-n只把匹配到的输出&lt;/li&gt;

&lt;li&gt;&lt;p&gt;主要参数是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;a 在下面插入数据&lt;/li&gt;
&lt;li&gt;d 删除&lt;/li&gt;
&lt;li&gt;i 在上面插入数据&lt;/li&gt;
&lt;li&gt;p 输出数据&lt;/li&gt;
&lt;li&gt;c 替换字符串，后面可跟字符串，字符串替换n1到n2之间的行&lt;br/&gt;
s 替换字符串，通常搭配正则&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;字符的删除&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[wyb@localhost aa]$ nl a.txt | sed &#39;3,8d&#39;   //不输出3-8行
     1  1     root      12sf34s56
     2  2     admin     ksdjfiweurf
     9  9     candy     kd89943
[wyb@localhost aa]$ nl a.txt | sed &#39;3,$d&#39;   //从第三行删到最后一行
     1  1     root      12sf34s56
     2  2     admin     ksdjfiweurf
[wyb@localhost aa]$ nl a.txt | sed &#39;/root/d&#39;    //正则删除带root的行
     2  2     admin     ksdjfiweurf
     3  3     dome      skd89453
     4  4     tomkd     3jkke34
     5  5     jarry     sdkj89ry4
     6  6     canki     sdkj834
     7  7     lola      er8f7734
     8  8     marry     j8jkf78
     9  9     candy     kd89943
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;a插入字符&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[wyb@localhost aa]$ nl a.txt | sed &#39;2a aaaaaa&#39; | head -n 5  //在第二行下面插入一行字符串aaaaaa
     1  1     root      12sf34s56
     2  2     admin     ksdjfiweurf
aaaaaa
     3  3     dome      skd89453
     4  4     tomkd     3jkke34
[wyb@localhost aa]$ nl a.txt | sed &#39;2i aaaaaa&#39; | head -n 5  //在第二行上面插入一行字符串aaaaaa
     1  1     root      12sf34s56
aaaaaa
     2  2     admin     ksdjfiweurf
     3  3     dome      skd89453
     4  4     tomkd     3jkke34
[wyb@localhost aa]$ nl a.txt | sed &#39;2i aaaaaa \     //增加多行用\
bbbbb\
ccccc\
dddddd&#39; | head -n 7
     1  1     root      12sf34s56
aaaaaa 
bbbbb
ccccc
dddddd
     2  2     admin     ksdjfiweurf
     3  3     dome      skd89453
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;p输出字符&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[wyb@localhost aa]$ nl a.txt | sed &#39;2,5p&#39;
     1  1     root      12sf34s56
     2  2     admin     ksdjfiweurf
     2  2     admin     ksdjfiweurf
     3  3     dome      skd89453
     3  3     dome      skd89453
     4  4     tomkd     3jkke34
     4  4     tomkd     3jkke34
     5  5     jarry     sdkj89ry4
     5  5     jarry     sdkj89ry4
     6  6     canki     sdkj834
     7  7     lola      er8f7734
     8  8     marry     j8jkf78
     9  9     candy     kd89943
[wyb@localhost aa]$ nl a.txt | sed -n &#39;2,5p&#39;    //加-n去除其余行
     2  2     admin     ksdjfiweurf
     3  3     dome      skd89453
     4  4     tomkd     3jkke34
     5  5     jarry     sdkj89ry4
[wyb@localhost aa]$ nl a.txt | sed -n &#39;/root/p&#39; //正则匹配root
     1  1     root      12sf34s56
[wyb@localhost bbb]$ nl /etc/passwd | sed -n &#39;/root/{s/root/111111/;p}&#39;查找root，然后将行中的第一个root替换为abcdefg  -n代表不输出所有的
     1  111111:x:0:0:root:/root:/bin/bash
    11  operator:x:11:0:operator:/111111:/sbin/nologin
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;c和s替换字符&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[wyb@localhost aa]$ nl a.txt | sed &#39;2,5c aaaaaa&#39;    //将第2-5行替换
     1  1     root      12sf34s56
aaaaaa
     6  6     canki     sdkj834
     7  7     lola      er8f7734
     8  8     marry     j8jkf78
     9  9     candy     kd89943
[wyb@localhost aa]$ nl /etc/passwd | sed -n &#39;/root/{s/root/1111/g;p}&#39;查找root，然后将全局的root替换为1111
     1  1111:x:0:0:1111:/1111:/bin/bash
    11  operator:x:11:0:operator:/1111:/sbin/nologin
[wyb@localhost aa]$ nl /etc/passwd | sed -n &#39;1,3{s/root/1111/g;p}&#39;前五行查找root，然后将全局的root替换为1111
     1  1111:x:0:0:1111:/1111:/bin/bash
     2  bin:x:1:1:bin:/bin:/sbin/nologin
     3  daemon:x:2:2:daemon:/sbin:/sbin/nologin
[wyb@localhost aa]$ nl /etc/passwd | sed -n &#39;1,5{s/root/1111/g;p;q}&#39;前五行查找root，然后将整行的root替换为1111,查找到一个就退出
     1  1111:x:0:0:1111:/1111:/bin/bash
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;实例&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[wyb@localhost aa]$ ifconfig eth0
eth0      Link encap:Ethernet  HWaddr 00:0C:29:56:B4:10  
          inet addr:192.168.63.131  Bcast:192.168.63.255  Mask:255.255.255.0
          inet6 addr: fe80::20c:29ff:fe56:b410/64 Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:11732 errors:0 dropped:0 overruns:0 frame:0
          TX packets:7223 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000 
          RX bytes:1148256 (1.0 MiB)  TX bytes:1192150 (1.1 MiB)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;[wyb@localhost aa]$ ifconfig eth0 | grep &#39;inet add&#39; 
          inet addr:192.168.63.131  Bcast:192.168.63.255  Mask:255.255.255.0
[wyb@localhost aa]$ ifconfig eth0 | grep &#39;inet add&#39; | sed &#39;s/Bcast.*$//g&#39;
          inet addr:192.168.63.131  
[wyb@localhost aa]$ 


[wyb@localhost aa]$ nl /etc/passwd | sed &#39;3,$d&#39;
     1  root:x:0:0:root:/root:/bin/bash
     2  bin:x:1:1:bin:/bin:/sbin/nologin
[wyb@localhost aa]$ nl /etc/passwd | sed &#39;3,$d&#39; | sed -n &#39;s/bash/buleshell/p&#39;
     1  root:x:0:0:root:/root:/bin/buleshell


[wyb@localhost aa]$ nl /etc/passwd | sed -e &#39;3,$d&#39; -e &#39;s/bash/buleshell/p&#39;
     1  root:x:0:0:root:/root:/bin/buleshell
     1  root:x:0:0:root:/root:/bin/buleshell
     2  bin:x:1:1:bin:/bin:/sbin/nologin
[wyb@localhost aa]$ 


[wyb@localhost aa]$ nl /etc/passwd | sed -e &#39;3,$d&#39; -e &#39;s/bash/buleshell/p&#39;
     1  root:x:0:0:root:/root:/bin/buleshell
     1  root:x:0:0:root:/root:/bin/buleshell
     2  bin:x:1:1:bin:/bin:/sbin/nologin
[wyb@localhost aa]$ nl /etc/passwd | sed -e &#39;3,$d&#39; -e &#39;s/bash/buleshell/p&#39; &amp;gt; test.txt
[wyb@localhost aa]$ cat test.txt 
     1  root:x:0:0:root:/root:/bin/buleshell
     1  root:x:0:0:root:/root:/bin/buleshell
     2  bin:x:1:1:bin:/bin:/sbin/nologin
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>