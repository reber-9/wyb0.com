<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>多线程 on </title>
    <link>http://wyb0.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</link>
    <description>Recent content in 多线程 on </description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2016-2017 Reber. All Rights Reserved.</copyright>
    <lastBuildDate>Wed, 03 Feb 2016 12:44:38 +0800</lastBuildDate>
    <atom:link href="http://wyb0.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Python的线程</title>
      <link>http://wyb0.com/posts/Python%E7%9A%84%E7%BA%BF%E7%A8%8B/</link>
      <pubDate>Wed, 03 Feb 2016 12:44:38 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/Python%E7%9A%84%E7%BA%BF%E7%A8%8B/</guid>
      <description>

&lt;p&gt;Python的参数传递其实传递的是对象，当传递可变对象(列表、队列)时相当于引用传递，可以修改对象的原始值，当传递不可变对象(字符串、整型)时就相当于传值，不能直接修改原始对象。&lt;/p&gt;

&lt;h2 id=&#34;单线程:d9089b1f26aa05f067c3e67af7b471a1&#34;&gt;单线程&lt;/h2&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#!/usr/bin/env python
# -*- coding: utf-8 -*-

from time import time,ctime,sleep

def music(arg):
    for x in range(2):
        print &amp;quot;I&#39;m listening to %s. %s&amp;quot; % (arg,ctime())
        sleep(1)
def movie(arg):
    for x in range(2):
        print &amp;quot;I&#39;m watching %s. %s&amp;quot; % (arg,ctime())
        sleep(5)

if __name__ == &#39;__main__&#39;:
    start = int(time())
    music(u&#39;我&#39;)
    movie(u&#39;可是&#39;)
    print &amp;quot;All over time:%s&amp;quot; % ctime()
    print &amp;quot;Used time:%d&amp;quot; % int(time()-start)
&lt;/code&gt;&lt;/pre&gt;


&lt;div class=&#34;pure-u-1&#34;&gt;
  &lt;img class=&#34;pure-img&#34; src=&#34;http://wyb0.com/img/post/thread_single.png&#34; alt=&#34;单线程&#34;&gt;
&lt;/div&gt;

&lt;/blockquote&gt;

&lt;h2 id=&#34;多线程:d9089b1f26aa05f067c3e67af7b471a1&#34;&gt;多线程&lt;/h2&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#!/usr/bin/env python
# -*- coding: utf-8 -*-

import re
import requests
import threading
from time import time,ctime,sleep


INDEX = 0

def http_get(sites):
    global INDEX
    while INDEX &amp;lt; len(sites):
        url = sites[INDEX]
        INDEX += 1
        resp = requests.get(url, timeout=3)
        resp.encoding = resp.apparent_encoding
        title = re.search(r&#39;&amp;lt;title&amp;gt;(.*?)&amp;lt;/title&amp;gt;&#39;, resp.text).group(1)
        print &amp;quot;URL:%-30sTitle:%s&amp;quot; % (url, title)

sites = [
    &amp;quot;http://www.baidu.com&amp;quot;,
    &amp;quot;http://www.qq.com&amp;quot;,
    &amp;quot;http://www.github.com&amp;quot;,
    &amp;quot;http://www.jingyingba.com&amp;quot;,
]

if __name__ == &#39;__main__&#39;:
    start = int(time())
    
    threads = []
    for i in range(0, 3):
        t = threading.Thread(target=http_get, args=(sites,))
        threads.append(t)
    for t in threads:
        #t.setDaemon(True) #设为守护线程,主线程结束后不管子线程是否完成,立即结束
        t.start()
    for t in threads:
        t.join() #主线程阻塞，等待子线程完成
        
    print &amp;quot;Used time:%d&amp;quot; % int(time() - start)
&lt;/code&gt;&lt;/pre&gt;


&lt;div class=&#34;pure-u-1&#34;&gt;
  &lt;img class=&#34;pure-img&#34; src=&#34;http://wyb0.com/img/post/thread_multithreading.png&#34; alt=&#34;多线程&#34;&gt;
&lt;/div&gt;

&lt;/blockquote&gt;

&lt;h2 id=&#34;线程同步:d9089b1f26aa05f067c3e67af7b471a1&#34;&gt;线程同步&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;使用多线程时若线程共用一个资源则可能导致线程竞争问题，可以通过互斥锁和队列来解决&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;线程竞争&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#!/usr/bin/env python
# -*- coding: utf-8 -*-

import re
import requests
import threading
from time import time,ctime,sleep

num = 0

def test():
    global num
    sleep(1)
    num = num+1
    msg = &#39;Number: &#39; + str(num)
    print msg

if __name__ == &#39;__main__&#39;:
    start = int(time())
    
    threads = []
    for i in range(0, 20):
        t = threading.Thread(target=test)
        threads.append(t)
    for t in threads:
        t.setDaemon(True)
        t.start()
    for t in threads:
        t.join()
        
    print &amp;quot;Used time:%d&amp;quot; % int(time() - start)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;
&lt;div class=&#34;pure-u-1&#34;&gt;
  &lt;img class=&#34;pure-img&#34; src=&#34;http://wyb0.com/img/post/thread_compete1.png&#34; alt=&#34;线程竞争1&#34;&gt;
&lt;/div&gt;

&lt;br /&gt;&lt;br /&gt;

&lt;div class=&#34;pure-u-1&#34;&gt;
  &lt;img class=&#34;pure-img&#34; src=&#34;http://wyb0.com/img/post/thread_compete2.png&#34; alt=&#34;线程竞争2&#34;&gt;
&lt;/div&gt;
&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;互斥锁&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#!/usr/bin/env python
# -*- coding: utf-8 -*-

&amp;quot;&amp;quot;&amp;quot;
使用步骤：
1. 创建互斥锁 mutex = threading.Lock()
2. 锁定 mutex.acquire([timeout])
3. 释放 mutex.release()
&amp;quot;&amp;quot;&amp;quot;

import re
import requests
import threading
from time import time,ctime,sleep

num = 0
mutex = threading.Lock()

def test():
    global num
    sleep(0.5)

    mutex.acquire() #这里存在线程竞争，设置互斥锁
    num = num+1
    mutex.release()

    msg = &#39;set num to &#39;+str(num)
    mutex.acquire() #输出有可能错乱，还是线程竞争问题
    print msg
    mutex.release()

if __name__ == &#39;__main__&#39;:
    start = int(time())

    threads = []
    for i in range(0, 20):
        t = threading.Thread(target=test)
        threads.append(t)
    for t in threads:
        t.setDaemon(True)
        t.start()
    for t in threads:
        t.join()

    print &amp;quot;Total use time %d&amp;quot; % int(time() - start)
&lt;/code&gt;&lt;/pre&gt;


&lt;div class=&#34;pure-u-1&#34;&gt;
  &lt;img class=&#34;pure-img&#34; src=&#34;http://wyb0.com/img/post/thread_mutex.png&#34; alt=&#34;互斥锁同步&#34;&gt;
&lt;/div&gt;

&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;队列(推荐)&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#!/usr/bin/env python
# -*- coding: utf-8 -*-

import re
import random
import Queue
import requests
import threading
from time import time,ctime,sleep

queue = Queue.Queue()

for i in xrange(1,20+1):
    queue.put(i) #put一次队列里的任务数就加1

def test(queue):
    while not queue.empty():
        sleep(random.random()) #随机生成的一个实数，它在(0,1)范围内
        i = queue.get()
        print i
        queue.task_done()

if __name__ == &#39;__main__&#39;:
    start = int(time())

    threads = []
    for x in range(0, 20):
        t = threading.Thread(target=test, args=(queue,))
        threads.append(t)
    for t in threads:
        t.setDaemon(True)
        t.start()
    queue.join() #等待队列里的任务数为0，即队列为空任务完成

    print &amp;quot;Total use time %d&amp;quot; % int(time() - start)
&lt;/code&gt;&lt;/pre&gt;


&lt;div class=&#34;pure-u-1&#34;&gt;
  &lt;img class=&#34;pure-img&#34; src=&#34;http://wyb0.com/img/post/thread_queue.png&#34; alt=&#34;队列解决线程竞争问题&#34;&gt;
&lt;/div&gt;

&lt;/blockquote&gt;

&lt;h2 id=&#34;多线程与类与队列:d9089b1f26aa05f067c3e67af7b471a1&#34;&gt;多线程与类与队列&lt;/h2&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#!/usr/bin/env python
# -*- coding: utf-8 -*-

&amp;quot;&amp;quot;&amp;quot;
使用步骤：
1. 继承线程类 threading.Thread
2. 重写线程类的__init__方法
3. 重写线程类的run方法
4. 继承类每实例化一次就创建一个线程

__init__方法一般接收外部参数并存放到实例变量
实例化对象调用start()方法后运行了run()方法
&amp;quot;&amp;quot;&amp;quot;

import re
import random
import Queue
import requests
import threading
from time import time,ctime,sleep

hosts = [
    &amp;quot;http://www.baidu.com&amp;quot;,
    &amp;quot;http://www.qq.com&amp;quot;,
    &amp;quot;http://www.github.com&amp;quot;,
    &amp;quot;http://www.jingyingba.com&amp;quot;
]

queue = Queue.Queue()

class ThreadTest(threading.Thread):
    &amp;quot;docstring for ThreadTest&amp;quot;
    def __init__(self, queue):
        threading.Thread.__init__(self)
        self.queue = queue

    def run(self):
        while not self.queue.empty():
            host = self.queue.get()
            resp = requests.get(host)
            resp.encoding = resp.apparent_encoding
            title = re.search(r&#39;&amp;lt;title&amp;gt;(.*?)&amp;lt;/title&amp;gt;&#39;,resp.text,re.I).group(1)
            print &amp;quot;URL:%-30sTitle:%s&amp;quot; % (host, title)
            self.queue.task_done()

def main():
    for host in hosts:
        queue.put(host)

    for x in xrange(1,4):
        t = ThreadTest(queue)
        t.setDaemon(True)
        t.start()
    queue.join()

if __name__ == &#39;__main__&#39;:
    start = time()
    main()
    print &amp;quot;Total use time %d&amp;quot; % int(time() - start)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;
&lt;div class=&#34;pure-u-1&#34;&gt;
  &lt;img class=&#34;pure-img&#34; src=&#34;http://wyb0.com/img/post/thread_multithreading_queue_class.png&#34; alt=&#34;使用多线程和类和队列&#34;&gt;
&lt;/div&gt;
&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
  </channel>
</rss>