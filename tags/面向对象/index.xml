<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>面向对象 on </title>
    <link>http://wyb0.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</link>
    <description>Recent content in 面向对象 on </description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2016-2017 Reber. All Rights Reserved.</copyright>
    <lastBuildDate>Fri, 20 May 2016 16:07:55 +0800</lastBuildDate>
    <atom:link href="http://wyb0.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>PHP之面向对象</title>
      <link>http://wyb0.com/posts/PHP%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</link>
      <pubDate>Fri, 20 May 2016 16:07:55 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/PHP%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</guid>
      <description>

&lt;h2 id=&#34;面向对象:5c6593d80077ae6b6ba6c5030c3b0275&#34;&gt;面向对象&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;面向对象概念

&lt;ul&gt;
&lt;li&gt;面向对象是达到了软件工程的三个目标：重用性、灵活性和扩展性，使其编程的代码更加简洁、更易于维护、并且具有更强的可重用性。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;类和对象的关系

&lt;ul&gt;
&lt;li&gt;在面向对象的编程语言中，类是一个对立的程序单位，而对象的抽象就是类。类描述了一组有相同特性(属性)和相同行为(方法)的对象。开发时要先抽象类再用该类去创建对象。而我们的程序中直接使用的是对象而不是类。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;什么是类

&lt;ul&gt;
&lt;li&gt;在面向对象的编程语言中，类是一个对立的程序单位，是具有相同属性和服务的一组对象的集合。它为属于该类的所有对象提供了同意的抽象描述，其内部包括成员属性和服务的方法两个部分。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;什么是对象

&lt;ul&gt;
&lt;li&gt;在客观世界里，所有的事物都是由对象和对象之间的联系组成的。对象是系统中用来描述客观事物的一个实体，它是构成系统的一个基本单位，一个对象由一组属性和有权对这些属性进行操作的一组服务的封装体。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;类的声明:5c6593d80077ae6b6ba6c5030c3b0275&#34;&gt;类的声明&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;类名和变量名还有函数名的命名规则类似，都遵循PHP中定义名称的命名规则。&lt;/li&gt;
&lt;li&gt;若类名由多个单词组成，习惯上每个单词的首字母要大写&lt;/li&gt;
&lt;li&gt;类中成员可分为属性和方法&lt;/li&gt;
&lt;li&gt;属性为静态描述，方法为动态描述&lt;/li&gt;
&lt;li&gt;在类中声明成员属性时，变量前面一定要有关键字，如：public、private、static等&lt;/li&gt;
&lt;li&gt;若不需要有特定意义的修饰，则使用var关键字&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;格式：
[一些修饰类的关键字] class 类名 {
    类中成员;
}

Class Person {
成员属性：
    姓名、性别、年龄、身高、体重、电话、住址等
成员方法：
    说话、学习、走路、吃饭、开车、使用手机等
}

例子：
&amp;lt;?php
    class Person {
        var $name;
        var $age;
        var $sex;
        function say() {
            echo &amp;quot;人在说话&amp;quot;;
        }
        function run() {
            echo &amp;quot;人在走路&amp;quot;;
        }
    }
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;实例化对象:5c6593d80077ae6b6ba6c5030c3b0275&#34;&gt;实例化对象&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;格式：
$变量名 = new 类名称([参数列表]);
$变量名 = new 类名称;

例子：
&amp;lt;?php
    class Phone {
    // ...
    }
    class Person {
    // ...
    }
    $person1 = new Person();
    $person2 = new Person();
    $person3 = new Person;
    $phone1 = new Phone();
    $phton2 = new Phone();
    $phton3 = new Phone;
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;对象中成员的访问:5c6593d80077ae6b6ba6c5030c3b0275&#34;&gt;对象中成员的访问&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
    /**
    *声明一个人类Person，其中包含三个成员属性和两个成员方法
    */
    class Person
    {
        var $name;
        var $age;
        var $sex;
        
        function say() {
            echo &amp;quot;我的名字：&amp;quot;.$this-&amp;gt;name.&amp;quot;,性别：&amp;quot;.$this-&amp;gt;sex.&amp;quot;，年龄：&amp;quot;.$this-&amp;gt;age.&amp;quot;。&amp;lt;br /&amp;gt;\n&amp;quot;;
        }
        function run() {
            echo $this-&amp;gt;name.&amp;quot;在走路&amp;lt;br /&amp;gt;\n&amp;quot;;
        }
    }
    
    $xiaoming = new Person();
    $wyb = new Person();
    
    $xiaoming-&amp;gt;name = &amp;quot;小明&amp;quot;;
    $xiaoming-&amp;gt;sex = &amp;quot;男&amp;quot;;
    $xiaoming-&amp;gt;age = 16;
    
    $wyb-&amp;gt;name = &amp;quot;wyb&amp;quot;;
    $wyb-&amp;gt;sex = &amp;quot;男&amp;quot;;
    $wyb-&amp;gt;age = 18;
    
    $xiaoming-&amp;gt;say();
    $wyb-&amp;gt;run();
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;构造方法和析构方法:5c6593d80077ae6b6ba6c5030c3b0275&#34;&gt;构造方法和析构方法&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;构造方法和析构方法是对象中两个特殊的方法&lt;/li&gt;
&lt;li&gt;构造方法是对象创建完成后第一个被对象自动调用的方法&lt;/li&gt;
&lt;li&gt;析构方法是对象在销毁之前最后一个被对象自动调用的方法&lt;/li&gt;
&lt;li&gt;通常用构造方法完成一些对象的初始化工作，用析构方法完成一些对象在销毁前的清理工作&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;function _ _construct([参数列表]) {
    //方法体，通常用来对成员属性进行初始化赋值
}

function _ _destruct([参数列表]) {
    //方法体，通常用来完成一些在对象销毁前的清理工作
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Python的面向对象</title>
      <link>http://wyb0.com/posts/Python%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</link>
      <pubDate>Mon, 25 Jan 2016 11:17:59 +0800</pubDate>
      
      <guid>http://wyb0.com/posts/Python%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</guid>
      <description>

&lt;h2 id=&#34;面向对象:04cc230c80adb1c364afa7c8dc32cd14&#34;&gt;面向对象&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;面向对象是为了解决系统的可维护性，可扩展性，可重用性&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;三个基本特征：封装、继承、多态&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;封装：对一类事物，将其相同特点和功能提取出来，所共有的特点叫做属性，共有的功能就叫做方法，将属性和方法组合在一起就叫做封装。&lt;br /&gt;
如：人具有姓名、年龄、性别，这些就是属性，人可以说话、可以走、可以跑，这些就是方法，封装起来就是一个类，而类的实例化就是对象&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;继承：继承可以使得子类具有父类的属性和方法，不需要再次编写相同的代码，子类可以对继承的代码进行重写，也可以追加新的属性和方法。&lt;br /&gt;
如：有一个类People，教师就可以继承自People，可以添加自己的属性，如：工资、职工号，也可以添加自己的方法，如：备课、写教案&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;多态：首先，多态必有继承，没有继承就没有多态，继承后一个父类的引用变量可以指向其任意一个子类对象。&lt;br /&gt;
如：有一个People类，它的子类可以有学生、老师、工人，有多种形态，这就是多态&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;类的实例:04cc230c80adb1c364afa7c8dc32cd14&#34;&gt;类的实例&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;注意：类中每个方法后面都要写self，self就是当前对象指针&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;示例一&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#!/usr/bin/env python
# -*- coding:utf-8 -*-

# 声明一个People类
class People(object):
    &amp;quot;&amp;quot;&amp;quot;docstring for People&amp;quot;&amp;quot;&amp;quot;
    def __init__(self, name, age):
        super(People, self).__init__()
        self.name = name
        self.age = age

    def running(self):
        print &amp;quot;%s is running&amp;quot; % self.name

    def print_base_msg(self):
        print &amp;quot;Name:%s Age:%d&amp;quot; % (self.name,self.age)

# 继承自People类
class Teacher(People):
    &amp;quot;&amp;quot;&amp;quot;docstring for Teacher&amp;quot;&amp;quot;&amp;quot;
    def __init__(self, name, age, salary):
        super(Teacher, self).__init__(name, age)
        self.name = name
        self.age = age
        self.salary = salary

    def print_base_msg(self): #对父类方法进行重写，会覆盖原方法
        print &amp;quot;Name:%s Age:%d Salary:%d&amp;quot; % (self.name,self.age,self.salary)

# 继承自People类
class Student(People):
    &amp;quot;&amp;quot;&amp;quot;docstring for Student&amp;quot;&amp;quot;&amp;quot;
    def __init__(self, name, age, score):
        super(Student, self).__init__(name, age)
        self.name = name
        self.age = age
        self.score = score

    def print_base_msg(self): #对父类方法进行重写，会覆盖原方法
        print &amp;quot;Name:%s Age:%d Score:%d&amp;quot; % (self.name,self.age,self.score)

t = Teacher(&#39;tom&#39;,40,13000)
t.running() #tom is running 调用时会先查找当前类中有无此方法，没有的话再从父类查找
t.print_base_msg() #Name:tom Age:40 Salary:13000

s = Student(&#39;xiaoming&#39;,16,97)
s.running() #xiaoming is running
s.print_base_msg() #Name:xiaoming Age:16 Score:97
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;示例二&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#!/usr/bin/env python
# -*- coding:utf-8 -*-

class A(object):
    &amp;quot;&amp;quot;&amp;quot;docstring for A&amp;quot;&amp;quot;&amp;quot;
    def __init__(self, arg):
        super(A, self).__init__()
        self.arg = arg

    def print_a(self):
        print &amp;quot;A class&amp;quot;

    def print_arg(self):
        print &amp;quot;A output arg: %s&amp;quot; % (self.arg+&#39;-a&#39;)

    # 以__开头的是私有成员
    def __print_pravite(self): #子类不能直接用A.__print_pravite()调用它
        a = &amp;quot;A pravite&amp;quot;
        return a

    def get_pravite(self): #可以使用自己的私有方法
        t = self.__print_pravite()
        print t

class B(A):
    &amp;quot;&amp;quot;&amp;quot;docstring for B&amp;quot;&amp;quot;&amp;quot;
    def __init__(self, arg):
        super(B, self).__init__(arg)
        self.arg = arg
 
    def print_b(self):
        print &amp;quot;B class&amp;quot;

    def print_arg(self):
        print &amp;quot;B output arg: %s&amp;quot; % (self.arg+&#39;-b&#39;)

    def call_a_fun(self):
        self.print_b()
        self.print_arg()

    def call_b_fun(self):
        A.print_a(self) #调用父类方法。当父类名称改变时子类所有父类名都要变
        super(B, self).print_arg() #调用父类方法，父类名称改变时子类不用调整
        super(B, self).get_pravite() #子类可以使用父类的公有方法
        # super(B, self).__print_pravite() #出错，子类不能使用父类的私有方法

b = B(&#39;test&#39;)
b.call_b_fun()
b.call_a_fun()

# 输出如下：
# A class
# A output arg: test-a
# A pravite
# B class
# B output arg: test-b
# [Finished in 0.1s]
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;示例三&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#!/usr/bin/env python
# -- coding: utf-8 -*-

class People(object):
    &amp;quot;&amp;quot;&amp;quot;docstring for People&amp;quot;&amp;quot;&amp;quot;

    peoplecount = 0 #类属性

    def __init__(self, name, age, salary):
        super(People, self).__init__()
        self.name = name #对象属性
        self.age = age
        self.__salary = salary #私有属性，外部不能访问
        People.peoplecount += People.peoplecount + 1

    def display_count(self):
        print People.peoplecount #访问类属性

    def display_msg(self):
        print &amp;quot;name:%s age:%d&amp;quot; % (self.name,self.age)

    def set_salary(self, v):
        if v &amp;gt; 0:
            self.__salary = v
        else:
            print &amp;quot;value is error&amp;quot;

    def display_salary(self):
        print &amp;quot;salary:%d&amp;quot; % self.__salary


print People.peoplecount
p1 = People(&#39;tom&#39;, 21, 20000)
p2 = People(&#39;jack&#39;, 25, 14900)
p1.display_msg()
p2.display_msg()
p2.display_count()

# 结果如下：
# 0
# name:tom age:21
# name:jack age:25
# 3
# [Finished in 0.1s]
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
  </channel>
</rss>